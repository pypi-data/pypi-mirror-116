import glob
import hashlib
import logging
import os
import subprocess

from pelican import signals
from pelican.readers import Readers

log = logging.getLogger(__name__)

content_files = {}
primary_lang = None


def _get_content_type(path, settings):
    """Determine the content format by filename extension."""
    if "." not in path:
        log.error("%s has no extension, skipping!", path)
        return None

    # Get all known readers and find reader for extension
    readers = Readers(settings=settings)
    ext = path.split(".")[-1]
    reader_class = readers.reader_classes.get(ext, None)

    if reader_class is None:
        log.error("No reader found for %s", path)
        return None

    # Map reader class names to po4a format names
    reader_mapping = {
        "HTMLReader": "xhtml",
        "MarkdownReader": "markdown",
        "AsciiDocReader": "asciidoc",
    }
    reader_name = reader_class.__name__
    # We support readers wrapped by the jinja2content plugin
    reader_name = reader_name.removeprefix("Jinja")
    return reader_mapping.get(reader_name, None)


def _get_file_hashsum(name):
    """Get a hash sum of a file by its path."""
    with open(name, "rb") as file_in:
        return hashlib.md5(file_in.read()).digest()


def _get_dir_hashsums(path):
    """Return a list of tuples with name, hashsum entries for all files below path."""
    return [
        (name, _get_file_hashsum(name))
        for name in filter(
            lambda f: os.path.isfile(f), glob.glob(path + "/**", recursive=True)
        )
    ]


def register_content_file(sender, context):
    """Register a content file as known translation set."""
    # Determine type of content
    if "article" in context:
        content_obj = context["article"]
    elif "page" in context:
        content_obj = context["page"]
    else:
        log.debug("Skipped {}: Neither article nor page", sender)
        return

    # Track main language
    # When using the i18n_subsites plugin, DEFAULT_LANG is set to a different language
    # on each run, so we need to inspect main_lang in that case
    global primary_lang
    if primary_lang is None:
        if "I18N_SUBSITES" in context:
            primary_lang = context["main_lang"]
        else:
            primary_lang = context["DEFAULT_LANG"]

    # Only handle if handling main language
    # The i18n_subsites plugin will build all language sites in order,
    # but it may build the translated sites first
    if content_obj.lang != primary_lang:
        return

    # Get configuration
    po4a_conf = os.path.abspath(context.get("PO4A_CONF", "./po4a.conf"))
    po4a_dir = os.path.dirname(po4a_conf)

    # Generate relative paths
    source_path_orig = os.path.relpath(content_obj.source_path, po4a_dir)
    source_paths_trans = {
        trans_obj.lang: os.path.relpath(trans_obj.source_path, po4a_dir)
        for trans_obj in content_obj.translations
    }

    # Register in global dict for later dump
    content_files[source_path_orig] = source_paths_trans


def do_po4a(sender):
    """Do everything needed to generate po4a config, catalogs, and translations."""
    # Only write po4a.conf when handling main language
    if sender.settings["DEFAULT_LANG"] != primary_lang:
        return

    # Get configuration
    po4a_conf = os.path.abspath(sender.settings.get("PO4A_CONF", "./po4a.conf"))
    po4a_dir = os.path.dirname(po4a_conf)
    po_dir = os.path.relpath(sender.settings.get("PO4A_PO_DIR", "./po"), po4a_dir)
    content_path = sender.settings["PATH"]
    catalog = sender.settings.get("PO4A_CATALOG", "pelican-website")
    post_pattern = sender.settings.get("PO4A_POST_PATTERN", None)
    page_pattern = sender.settings.get("PO4A_PAGE_PATTERN", None)
    post_pattern_orig_base = post_pattern.format(lang=primary_lang, relpath="")
    page_pattern_orig_base = page_pattern.format(lang=primary_lang, relpath="")
    site_name = sender.settings.get("SITENAME", "pelican-website")
    author = sender.settings.get("AUTHOR", "Nobody in particular")

    # Get all languges used for content
    langs = set()
    for slug, trans in content_files.items():
        langs |= set(filter(lambda l: l != primary_lang, trans.keys()))

    # First lines are configuration data
    langs_str = " ".join(langs)
    lines = [
        "# po4a.conf generated by pelican-po4a; do not modify\n",
        "\n",
        f"[po4a_langs] {langs_str}\n",
        f"[po4a_paths] {po_dir}/{catalog}.pot $lang:po/$lang.po\n",
        f"\n",
        f"[options] --master-language {primary_lang} --master-charset utf-8\n",
        f'[options] --package-name "{site_name}" --copyright-holder "{author}"\n',
        f"[options] --keep-translations\n",
        "\n",
        '[po4a_alias:markdown] text opt:"-o markdown"\n',
        "\n",
    ]

    # Now, generate all content file lines
    for orig, trans in content_files.items():
        # Skip if no translations
        # FIXME Handle pattern setting for generating new translations
        if not trans:
            log.warn("No translations for %s, skipping!", orig)
            continue

        # Determine content types
        content_type = _get_content_type(orig, sender.settings)
        if content_type is None:
            log.warn("%s has unknown type, skipping!", orig)
            continue
        try:
            for lang, path in trans.items():
                if _get_content_type(path, sender.settings) != content_type:
                    log.error(
                        "Translation %s of %s has different format, skipping!",
                        lang,
                        orig,
                    )
                    raise ValueError
        except ValueError:
            continue

        # Build parts of generic po4a language path template
        if orig.startswith(page_pattern_orig_base):
            pattern = page_pattern
            relpath = orig.removeprefix(page_pattern_orig_base)
        elif orig.startswith(post_pattern_orig_base):
            pattern = post_pattern
            relpath = orig.removeprefix(post_pattern_orig_base)
        else:
            pattern = None

        # Build relevant language paths
        paths = []
        if pattern is not None:
            paths += [f"$lang:{pattern}".format(lang="$lang", relpath=relpath)]
        for lang, path in trans.items():
            if pattern is not None and path == pattern.format(
                lang=lang, relpath=relpath
            ):
                log.debug(
                    "No need for explicit mention of %s, path matches generic pattern",
                    path,
                )
                continue
            else:
                log.warn("Path %s does not match generic pattern!", path)
                paths += [f"{lang}:{path}"]

        trans_str = " ".join(paths)
        lines += [f"[type:{content_type}] {orig} {trans_str}\n"]

    # Compare po4a.conf
    po4a_conf_changed = False
    if not os.path.exists(po4a_conf):
        po4a_conf_changed = True
    else:
        with open(po4a_conf, "rt") as po4a_in:
            lines_old = po4a_in.readlines()
        if lines_old != lines:
            log.critical("po4a.conf is updated, you probably need to rebuild!")
        else:
            log.info("po4a.conf is unchanged")

    # Write out
    with open(po4a_conf, "wt") as po4a_out:
        po4a_out.writelines(lines)
        log.info("po4a.conf written to %s", po4a_conf)

    # Rebuild message catalogs
    hashsums_old = _get_dir_hashsums(po_dir)
    subprocess.run(["po4a", "--no-translations", po4a_conf])
    hashsums_new = _get_dir_hashsums(po_dir)
    if hashsums_old != hashsums_new:
        log.critical("Message catalogs changed, you probably need to rebuild!")
    else:
        log.info("Message catalogs unchanged")

    # Rebuild translated files
    hashsums_old = _get_dir_hashsums(content_path)
    subprocess.run(["po4a", "--no-update", po4a_conf])
    hashsums_new = _get_dir_hashsums(content_path)
    if hashsums_old != hashsums_new:
        log.critical("Translated files changed, you probably need to rebuild!")
    else:
        log.info("Translated files unchanged")


def register():
    signals.content_written.connect(register_content_file)
    signals.finalized.connect(do_po4a)
