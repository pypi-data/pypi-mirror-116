import logging
import os

from pelican import signals

log = logging.getLogger(__name__)

content_files = {}
primary_lang = None

def _get_content_type(path):
    if path.endswith(".html"):
        return "xhtml"

    return None


def register_content_file(sender, context):
    if "article" in context:
        content_obj = context["article"]
    elif "page" in context:
        content_obj = context["page"]
    else:
        log.debug("Skipped {}: Neither article nor page", sender)
        return

    # Track main language
    global primary_lang
    if primary_lang is None:
        if "I18N_SUBSITES" in context:
            primary_lang = context["main_lang"]
        else:
            primary_lang = context["DEFAULT_LANG"]

    # Only handle if handling main language
    if content_obj.lang != primary_lang:
        return

    # Get configuration
    po4a_conf = os.path.abspath(context.get("PO4A_CONF", "./po4a.conf"))
    po4a_dir = os.path.dirname(po4a_conf)

    # Generate relative paths
    source_path_orig = os.path.relpath(content_obj.source_path, po4a_dir)
    source_paths_trans = {trans_obj.lang: os.path.relpath(trans_obj.source_path, po4a_dir) for trans_obj in content_obj.translations}

    # Register in global dict for later dump
    content_files[source_path_orig] = source_paths_trans

def write_po4a_conf(sender):
    breakpoint()
    # Only write po4a.conf when handling main language
    if sender.settings["DEFAULT_LANG"] != primary_lang:
        return

    # Get configuration
    po4a_conf = os.path.abspath(sender.settings.get("PO4A_CONF", "./po4a.conf"))
    po4a_dir = os.path.dirname(po4a_conf)
    po_dir = os.path.relpath(sender.settings.get("PO4A_PO_DIR", "./po"), po4a_dir)
    catalog = sender.settings.get("PO4A_CATALOG", "pelican-website")

    # Get all languges used for content
    langs = set()
    for slug, trans in content_files.items():
        langs |= set(filter(lambda l: l != primary_lang, trans.keys()))

    # First lines are configuration data
    langs_str = " ".join(langs)
    lines = [
        "# po4a.conf generated by pelican-po4a; do not modify\n",
        "\n",
        f"[po4a_langs] {langs_str}\n",
        f"[po4a_paths] {po_dir}/{catalog}.pot $lang:po/$lang.po\n",
        f"[options] --master-language {primary_lang} --master-charset utf-8\n",
        "\n"
    ]

    # Now, generate all content file lines
    for orig, trans in content_files.items():
        # Skip if no translations
        # FIXME Handle pattern setting for generating new translations
        if not trans:
            log.warn("No translations for %s, skipping!", orig)
            continue

        # Determine content types
        content_type = _get_content_type(orig)
        if content_type is None:
            log.warn("%s has unknown type, skipping!", orig)
            continue
        try:
            for lang, path in trans.items():
                if _get_content_type(path) != content_type:
                    log.error("Translation %s of %s has different format, skipping!", lang, orig)
                    raise ValueError
        except ValueError:
            continue

        trans_str = " ".join([f"{lang}:{path}" for lang, path in trans.items()])
        lines += [
            f"[type:{content_type}] {orig} {trans_str}\n"
        ]

    # Write out
    with open(po4a_conf, "wt") as po4a_out:
        po4a_out.writelines(lines)
        log.info("po4a.conf written to %s", po4a_conf)

def register():
    signals.content_written.connect(register_content_file)
    signals.finalized.connect(write_po4a_conf)
