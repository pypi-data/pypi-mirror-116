# cython: boundscheck=False
# cython: wraparound=False
# cython: nonecheck=False
# cython: infertypes=True
# cython: initializedcheck=False
# cython: cdivision=True
# cython: language_level=3
# distutils: define_macros=NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION
# coding: utf8

"""
In this module there are the data structures necessary for the working of the
library.

"""
cimport cython

import numpy as np
cimport numpy as np
np.import_array()

from libc.string cimport memcpy as c_memcpy
from cpython.mem cimport PyMem_Malloc, PyMem_Realloc, PyMem_Free
from .cython_ubsplclib cimport (
        splpev,
        splcev,
        dsplpev,
        dsplcev,
        dsplcpts2,
        asplcpts,
        distintknots,
        degelevc,
        splkins,
        splkref,
        splkrem,
        splksrem,
        splkrem_notol,
        averagcpts,
        knotuniondim,
        splcsum
        )

cdef object os
import os

cdef object etree
from lxml import etree

cdef object re
import re

cdef object iptp
import pyiptp as iptp

__all__ = [
    "ConvergenceError",
    "CorruptedFileError",
    "PyIPTPObject",
    "Trajectory1d",
    "Point1d"
    ]

class ConvergenceError(Exception):
    """
    An error when a macro-instruction loop fails.
    
    """
    pass

class CorruptedFileError(Exception):
    """
    An error when an uploaded file is corrupted.
    """
    pass

cdef class PyIPTPObject:
    """
    An abstract class for python_iptp type.
    
    """
    @staticmethod
    cdef PyIPTPObject c_loadxml(str fname, str ID):
        pass
    
    @staticmethod
    def loadxml(fname: str, ID: str) -> PyIPTPObject:
        NotImplementedError('abstract method')
    
    cpdef void savexml(self, str fname, str ID):
        """
        Method to save a PyIPTPObject object to a file in .xml format.
        
        Parameters
        ----------
        fname: str
            File name. If the file extension is not specified, the .pyiptp
            extension is used.
        ID: str
            Object ID.
        
        """
        cdef str extension
        cdef object parser
        cdef list matchlist
        cdef object tree
        cdef object root, node
        
        # check if the file name contains the extension
        extension = os.path.splitext(fname)[1]
        
        # if the file extension is not specified, the default is set
        if extension == "":
            fname += DEF_EXT
        
        if os.path.isfile(fname): # the file already exists
            parser = etree.XMLParser(remove_blank_text = True)
            tree = etree.parse(fname, parser)
            root = tree.getroot()
            
            if root.tag == "PyIPTPObjectList":
                matchlist = tree.xpath(
                    f"/PyIPTPObjectList/{self.__class__.__name__}[@ID='{ID}']")
                
                if matchlist.__len__() == 0: # no node match
                    self._addPyIPTPObject(root, ID)
                
                elif matchlist.__len__() == 1: # 1 node match
                    node = matchlist[0]
                    self._updatePyIPTPObject(tree, node, ID)
                
                else: # multiple node matches
                    raise CorruptedFileError(
                        f"multiple matches in the uploaded file: {ID}")
            else:
                raise CorruptedFileError(
                    f"corrupt root node in the uploaded file: {root.tag}")
        else:
            root = etree.Element("PyIPTPObjectList")
            tree = etree.ElementTree(root)
            root.addprevious(etree.Comment(
                f"Generated by python_iptp {iptp.__version__}"))
            self._addPyIPTPObject(root, ID)
        
        with open(fname, "wb") as f:
            tree.write(f, xml_declaration = True, encoding = 'utf-8',
                       pretty_print = True)
    
    # savexml method interface
    cpdef dict _getAttrib(self):
        NotImplementedError('abstract method')
    
    cpdef void _addPyIPTPObject(self, object root, str ID):
        NotImplementedError('abstract method')
    
    cpdef void _updatePyIPTPObject(self, object tree, object node, str ID):
        NotImplementedError('abstract method')

cdef class Trajectory1d(PyIPTPObject):
    """
    One-dimensional trajectory extension type.
    
    Attributes
    ----------
    p: int
        Degree of the univariate B-spline that parameterizes the trajectory.
    n: int
        The highest index of the trajectory parameterization coefficients.
        
            len(cpts) = n + 1
    
    ptrs_owner: bint
        Setting 'owner' flag to 'True' causes the extension type to 'free' the
        structures pointed to by '_knotvector' and '_cpts' when the wrapper
        object is deallocated.
    order: int
        Order of derivation to which the trajectory refers. Must be greater
        than or equal to zero. Example:
            
            0: displacement
            1: velocity
            2: acceleration
            3: jerk
            ...
    
    start: double
        Left end of the curve domain.
    stop: double
        Right end of the curve domain.
    
    StaticMethods
    -------------
    loadxml(fname: str, ID: str):
        Method to load a Trajectory1d object from a file in .xml format.
    
    Methods
    -------
    _sget_knotvector():
        Need to pickle protocol.
    _sget_cpts():
        Need to pickle protocol.
    _dset_data(bytes knots, bytes cpts, int p, int n, unsigned int order,
               bint owner):
        Need to pickle protocol.
    peval(double x):
        Evaluates the trajectory.
    ceval(double[::1] xp):
        Evaluates the trajectory in a set of data points.
    dpeval(double x, int nu = 1):
        Evaluates the derivative of the trajectory.
    dceval(double[::1] xp, int nu = 1):
        Evaluates the derivative of a set of data points.
    rshift(self, double x):
        Relative translation of 'self' along x-axis.
    ashift(self, double x):
        Translates 'self' along the x-axis so that the curve starts at the
        'x' coordinate.
    hscale(self, double k):
        Scales 'self' horizontally keeping the start of the domain fixed.
    adapt(self, double start, double stop):
        Adapt 'self' in a new domain.
    derivative(int nu = 1):
        Returns a Trajectory1d object representing the derivative.
    antiderivative(int nu = 1):
        Returns a Trajectory1d object representing the antiderivative.
    knotins(double u, int r):
        Returns a new Trajectory1d object with same shape and the knot 'u'
        inserted 'r' times.
    knotref(double[::1] X):
        Returns a new Trajectory1d object with same shape and new knots
        inserted.
    knotrem(double u, int r, double tol = 1e-11):
        Returns a new Trajectory1d object with, if possible, the knot 'u'
        removed 'r' times.
    knotsrem(double tol = 1e-11):
        Returns a new Trajectory1d object with as many knots removed as
        possible.
    knotrem_notol(double u, int r):
        Returns a new Trajectory1d object with knot 'u' removed 'r' times
        without tolerance check.
    copy():
        Return a copy of the object.
    degelev(int nu = 1):
        Increases the degree of the B-Spline interpolating the trajectory.
    setValueTr(point):
        Sets a condition by vertical shift of the trajectory.
    setValueAm(point):
        Sets a condition multiplying the trajectory by a calculated constant.
    get_xcpts():
        Returns the x-coordinates of the control points.
    get_knotvector_asarray():
        Creates an array wrapper around '_knotvector' pointer.
    get_cpts_asarray():
        Creates an array wrapper around '_cpts' pointer.
    _getAttrib():
        Returns the attributes of the object as a dictionary.
    _addPyIPTPObject(object root, str ID):
        Need to 'savexml' method.
    _updatePyIPTPObject(object element, str ID):
        Need to 'savexml' method.
    savexml(str fname, str ID):
        Method to save a Trajectory1d object to .xml file.
    
    """
    def __cinit__(self):
        self.ptrs_owner = False
    
    def __dealloc__(self):
        if self._knotvector is not NULL and self.ptrs_owner is True:
            PyMem_Free(self._knotvector)
            self._knotvector = NULL
        
        if self._cpts is not NULL and self.ptrs_owner is True:
            PyMem_Free(self._cpts)
            self._cpts = NULL
    
    @staticmethod
    cdef Trajectory1d from_ptrs(double *knotvector, double *cpts, int p,
                                int n, unsigned int order, bint owner=False):
        """
        Factory function to create Trajectory1d objects from given pointers.
        
        Setting 'owner' flag to 'True' causes the extension type to 'free' the
        structure pointed to by '_knotvector' and '_cpts' when the wrapper
        object is deallocated.
        
        """
        # Call to __new__ bypasses __init__ constructor
        cdef Trajectory1d wrapper = Trajectory1d.__new__(Trajectory1d)
        
        wrapper._knotvector = knotvector
        wrapper._cpts = cpts
        wrapper.p = p
        wrapper.n = n
        wrapper.order = order
        wrapper.ptrs_owner = owner
        
        return wrapper
    
    @staticmethod
    cdef Trajectory1d new_struct(int p, int n, unsigned int order):
        """
        Factory function to create Trajectory1d objects with newly allocated
        '_knotvector' and '_cpts' pointers.
        
        """
        cdef double *knotvector = <double*>PyMem_Malloc(
                (n + p + 2)*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        
        cdef double *cpts = <double*>PyMem_Malloc((n + 1)*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        
        return Trajectory1d.from_ptrs(knotvector, cpts, p, n, order,
                                      owner = True)
    
    @staticmethod
    cdef Trajectory1d c_loadxml(str fname, str ID):
        """
        C-method to load a Trajectory1d object from a file in .xml format.
        
        Parameters
        ----------
        fname: str
            File name. If the file extension is not specified, the .pyiptp
            extension is used.
        ID: str
            Object ID.
        
        """
        cdef str extension
        cdef object tree
        cdef list matchlist
        cdef int p, n, order
        cdef bint owner
        cdef object node
        cdef object subnode_cpts, subnode_knots
        cdef double[::1] knotvector_mv, cpts_mv
        
        # check if the file name contains the extension
        extension = os.path.splitext(fname)[1]
        
        # if the file extension is not specified, the default is set
        if extension == "":
            fname += DEF_EXT
        
        tree = etree.parse(fname)
        matchlist = tree.xpath(f"/PyIPTPObjectList/Trajectory1d[@ID='{ID}']")
        
        if not matchlist.__len__():
            raise ValueError(f"no match for ID: {ID}")
        
        node = matchlist[0]
        p = int(node.get("p"))
        n = int(node.get("n"))
        order = int(node.get("order"))
        owner = bool(node.get("owner"))
        
        cdef double *knotvector = <double*>PyMem_Malloc(
                (n + p + 2)*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        
        cdef double *cpts = <double*>PyMem_Malloc((n + 1)*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        
        subnode_knots = tree.xpath(
            f"/PyIPTPObjectList/Trajectory1d[@ID='{ID}']/knots")[0]
        subnode_cpts = tree.xpath(
            f"/PyIPTPObjectList/Trajectory1d[@ID='{ID}']/cpts")[0]
        
        knotvector_mv = np.array(
            list(map(float, subnode_knots.text.split(" "))), order = "C")
        cpts_mv = np.array(
            list(map(float, subnode_cpts.text.split(" "))), order = "C")
        
        c_memcpy(cpts, &cpts_mv[0], (n + 1)*sizeof(double))
        c_memcpy(knotvector, &knotvector_mv[0], (n + p + 2)*sizeof(double))
        
        return Trajectory1d.from_ptrs(knotvector, cpts, p, n, order, owner)
    
    @staticmethod
    def loadxml(fname: str, ID: str) -> Trajectory1d:
        """
        Method to load a Trajectory1d object from a file in .xml format.
        
        Parameters
        ----------
        fname: str
            File name. If the file extension is not specified, the .pyiptp
            extension is used.
        ID: str
            Object ID.
        
        """
        return Trajectory1d.c_loadxml(fname, ID)
    
    cdef bint c_eq(self, Trajectory1d other) except? False:
        if not (
                self.p == other.p and
                self.n == other.n and
                self.order == other.order and
                self.ptrs_owner == other.ptrs_owner
                ):
            return False
        
        # If the previous check is successful, M and N are the same
        cdef int N = self.n + 1, M = self.n + self.p + 2
        cdef double[::1] knots_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        cdef double[::1] otherknots_mv = <double[:M]>other._knotvector
        cdef double[::1] othercpts_mv = <double[:N]>other._cpts
        
        if not isclose(knots_mv, otherknots_mv, rtol = RTOL, atol = ATOL):
            return False
        
        elif not isclose(cpts_mv, othercpts_mv, rtol = RTOL, atol = ATOL):
            return False
        
        return True
    
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.c_eq(other)
        else:
            return False
    
    def __ne__(self, other):
        return not self.__eq__(other)
    
    cdef void c_iadd(self, double x) nogil:
        cdef size_t i
        if self._cpts is not NULL:
            for i in range(self.n + 1):
                self._cpts[i] += x
    
    def __iadd__(self, x):
        self.c_iadd(x)
        return self
    
    def __isub__(self, x):
        self.c_iadd(-x)
        return self
    
    cdef void c_imul(self, double x) nogil:
        cdef size_t i
        if self._cpts is not NULL: 
            for i in range(self.n + 1):
                self._cpts[i] *= x
    
    def __imul__(self, x):
        self.c_imul(x)
        return self
    
    def __itruediv__(self, x):
        self.c_imul(x**-1.)
        return self
    
    def __neg__(self):
        self.c_imul(-1.)
        return self
    
    cpdef Trajectory1d c_splcsum(self, Trajectory1d other):
        if not self.p == other.p:
            raise ValueError("the input traiectories must have the same order")
        if not self.start == other.start and self.stop == other.stop:
            raise ValueError(
                "the input traiectories must have the same extremes of domain")
        if not self.order == other.order:
            raise ValueError("the trajectories must have the same 'order'")
        
        cdef int N = self.n + 1, M = self.n + self.p + 2
        cdef double[::1] knots1_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts1_mv = <double[:N]>self._cpts
        
        cdef int N_other = other.n + 1, M_other = other.n + other.p + 2
        cdef double[::1] knots2_mv = <double[:M_other]>other._knotvector
        cdef double[::1] cpts2_mv = <double[:N_other]>other._cpts
        
        cdef int mk, nk
        mk, nk = knotuniondim(knots1_mv, knots2_mv, self.p)
        
        cdef double *knotvector = <double*>PyMem_Malloc(
            (mk + 1)*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] knotvector_mv = <double[:mk + 1]>knotvector
        
        cdef double *cpts = <double*>PyMem_Malloc((nk + 1)*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] cpts_mv = <double[:nk + 1]>cpts
        
        splcsum(knots1_mv, cpts1_mv, knots2_mv, cpts2_mv, self.p,
                mk, knotvector_mv, nk, cpts_mv)
        
        return Trajectory1d.from_ptrs(knotvector, cpts, self.p, nk, self.order,
                                      owner = True)
    
    cpdef Trajectory1d c_splcmul(self, Trajectory1d other):
        raise NotImplementedError
    
    # Note: Extension types do not support __radd__; instead, they
    # (effectively) overload __add__ to do the job of both the regular __add__
    # and __radd__ in one special method.
    def __add__(x, y):
        if isinstance(x, Trajectory1d) and isinstance(y, Trajectory1d):
            return x.c_splcsum(y)
        
        elif isinstance(x, Trajectory1d): # Regular __add__ behavior
            newtraj = x.copy()
            newtraj.__iadd__(y)
            return newtraj
        
        else: # __radd__ behavior
            newtraj = y.copy()
            newtraj.__iadd__(x)
            return newtraj
    
    # same for the other pairs of __<method>__ and __r<method>__
    
    def __sub__(x, y):
        if isinstance(x, Trajectory1d) and isinstance(y, Trajectory1d):
            return x.c_splcsum(y.__neg__())
        
        elif isinstance(x, Trajectory1d): # Regular __sub__ behavior
            newtraj = x.copy()
            newtraj.__isub__(y)
            return newtraj
    
        else: # __rsub__ behavior
            newtraj = y.copy()
            newtraj.__isub__(x)
            return newtraj
    
    def __mul__(x, y):
        if isinstance(x, Trajectory1d) and isinstance(y, Trajectory1d):
            return x.c_splcmul(y)
        
        elif isinstance(x, Trajectory1d): # Regular __mul__ behavior
            newtraj = x.copy()
            newtraj.__imul__(y)
            return newtraj
        
        else: # __rmul__ behavior
            newtraj = y.copy()
            newtraj.__imul__(x)
            return newtraj
    
    def __truediv__(x, y):
        if isinstance(x, Trajectory1d) and isinstance(y, Trajectory1d):
            NotImplemented
        
        elif isinstance(x, Trajectory1d): # Regular __truediv__ behavior
            newtraj = x.copy()
            newtraj.__itruediv__(y)
            return newtraj
        
        else: # __rtruediv__ behavior
            newtraj = y.copy()
            newtraj.__itruediv__(x)
            return newtraj
    
    def __repr__(self):
        return (f"{{\'start\': {self.start}, \'stop\': {self.stop}, "
                f"\'p\': {self.p}, \'n\': {self.n}, \'order\': {self.order}}}")
    
    def __str__(self):
        return (f"Trajectory1d(start = {self.start}, stop = {self.stop}, "
                f"p = {self.p}, n = {self.n}, order = {self.order})")
    
    # pickle protocol
    cpdef bytes _sget_knotvector(self): # serializes array to a bytes object
        cdef int M = self.n + self.p + 2
        
        if self._knotvector is NULL:
            return None
        
        return <bytes>(<char *>self._knotvector)[:sizeof(double)*M]
    
    cpdef bytes _sget_cpts(self): # serializes array to a bytes object
        cdef int N = self.n + 1
        
        if self._cpts is NULL:
            return None
        
        return <bytes>(<char *>self._cpts)[:sizeof(double)*N]
    
    cpdef void _dset_data(
        self, bytes knots, bytes cpts, int p, int n, unsigned int order,
        bint owner): # deserializes a bytes object to an array
        cdef int N = n + 1, M = n + p + 2
        
        PyMem_Free(self._knotvector)
        PyMem_Free(self._cpts)
        
        self.p = p
        self.n = n
        self.order = order
        self.ptrs_owner = owner
        
        self._knotvector = <double*>PyMem_Malloc((n + p + 2)*sizeof(double))
        if self._knotvector is NULL:
            raise MemoryError("memory allocation failed")
        c_memcpy(self._knotvector, <char *>knots, (n + p + 2)*sizeof(double))
        
        self._cpts = <double*>PyMem_Malloc((n + 1)*sizeof(double))
        if self._cpts is NULL:
            raise MemoryError("memory allocation failed")
        c_memcpy(self._cpts, <char *>cpts, (n + 1)*sizeof(double))
    
    def __getstate__(self):
        return (self._sget_knotvector(),
                self._sget_cpts(),
                self.p,
                self.n,
                self.order,
                self.ptrs_owner)
    
    def __setstate__(self, state):
        self._dset_data(*state)
    
    
    cpdef double peval(self, double x):
        """
        Evaluates the trajectory.
        
        Parameters
        ----------
        x: double
            x-coordinate to evaluate the trajectory.
        
        Returns
        -------
        out: double
            Value evaluated at the point 'x'.
        
        """
        cdef int N = self.n + 1, M = self.n + self.p + 2
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        cdef double result
        
        if x < self.start or x > self.stop:
            raise ValueError(f"'x' out of domain: {x}")
        
        result = splpev(x, knotvector_mv, cpts_mv, self.p)
        return result
    
    cpdef void ceval(self, double[::1] xp):
        """
        Evaluates the trajectory in a set of data points. The array 'xp' is
        overwritten with the resultes.
        
        Parameters
        ----------
        xp: double C-contiguous array
            The x-coordinates of the data points, must be increasing.
        
        """
        cdef int n = xp.shape[0]
        cdef int N = self.n + 1, M = self.n + self.p + 2
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        
        if n == 0:
            raise ValueError("zero size arrays are not allowed")
        if not issorted(xp, n):
            raise ValueError("'xp' must be increasing")
        if xp[0] < self.start or xp[n - 1] > self.stop:
            raise ValueError("domain error")
        
        splcev(xp, knotvector_mv, cpts_mv, self.p)
    
    cpdef double dpeval(self, double x, int nu = 1):
        """
        Evaluates the derivative of the trajectory.
        
        Parameters
        ----------
        x: double
            x-coordinate to evaluate the derivative.
        nu: int
            Derivative order. Must be non-negative number. Default is 1.
        
        Returns
        -------
        out: double
            Derivative evaluated at the point 'x'.
        
        """
        cdef double[::1] CK = np.empty(nu + 1, dtype=np.float64)
        cdef int N = self.n + 1, M = self.n + self.p + 2
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        
        if x < self.start or x > self.stop:
            raise ValueError(f"'x' out of domain: {x}")
        if nu < 0:
            raise ValueError("'nu' must be non-negative number")
        
        dsplpev(x, knotvector_mv, cpts_mv, self.p, nu, CK)
        return CK[nu]
    
    cpdef void dceval(self, double[::1] xp, int nu = 1):
        """
        Evaluates the derivative of a set of data points. The array 'xp' is
        overwritten with the resultes.
        
        Parameters
        ----------
        xp: double C-contiguous array
            The x-coordinates of the data points, must be increasing.
        nu: int
            Derivative order. Must be non-negative number. Default is 1.
        
        Notes
        -----
        For a large number of points it might be more efficient to use the
        'self.derivative' and 'self.ceval' functions.
        
        """
        cdef int n = xp.shape[0]
        cdef int N = self.n + 1, M = self.n + self.p + 2
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        cdef double[:, ::1] CK = np.empty((1, xp.shape[0]), dtype=np.float64)
        
        if n == 0:
            raise ValueError("zero size arrays are not allowed")
        if not issorted(xp, n):
            raise ValueError("'xp' must be increasing")
        if xp[0] < self.start or xp[n - 1] > self.stop:
            raise ValueError("domain error")
        if nu < 0:
            raise ValueError("'nu' must be non-negative number")
        
        dsplcev(xp, knotvector_mv, cpts_mv, self.p, nu, nu, CK)
        xp[...] = CK[0][:]
    
    def __call__(self, x, int nu = 0):
        """
        Evaluates the trajectory or its dervative.
        
        Parameters
        ----------
        x: double or array_like
            The x-coordinate(s) of the data point(s).
        nu: int
            Derivative order. Default is 0.
        
        Returns
        -------
        out: float or ndarray
            If 'x' is a scalar number, a float type is returned. Otherwise a
            numpy array is returned.
        
        """
        if np.isscalar(x):
            if nu == 0:
                return self.peval(x)
            elif nu > 0:
                return self.dpeval(x, nu)
            else:
                raise ValueError("'nu' must be non-negative number")
        else:
            ndarray = np.array(x, copy = True, ndmin = 1)
            if ndarray.ndim > 1:
                raise ValueError("'x' must be one-dimensional")
            
            ndarray = np.ascontiguousarray(ndarray.ravel(), dtype=np.float64)
            
            sort = True
            if not issorted(ndarray, ndarray.shape[0]):
                idx = np.argsort(ndarray)
                ndarray = ndarray[idx]
                sort = False
            
            if nu == 0:
                self.ceval(ndarray)
            elif nu > 0:
                self.dceval(ndarray, nu)
            else:
                raise ValueError("'nu' must be non-negative number")
            
            if not sort:
                idx = np.argsort(idx)
                ndarray = ndarray[idx]
            
            return ndarray
    
    cdef void c_shift(self, double x) nogil:
        cdef size_t i
        cdef int m = self.n + self.p + 1
        
        if self._knotvector is not NULL:
            for i in range(m + 1):
                self._knotvector[i] += x
    
    cpdef void rshift(self, double x):
        """
        Relative translation of 'self' along x-axis.
        
        Parameters
        ----------
        x: double
            Translation value.
        
        """
        self.c_shift(x)
    
    cpdef void ashift(self, double x):
        """
        Translates 'self' along the x-axis so that the curve starts at the
        'x' coordinate.
        
        Parameters
        ----------
        x: double
            Reference x-coordinate.
        
        """
        cdef double dx
        
        dx = x - self.start
        self.c_shift(dx)
    
    cdef void c_hscale(self, double k) nogil:
        cdef size_t i
        cdef int m = self.n + self.p + 1
        cdef double dx, start
        
        if self._knotvector is not NULL:
            dx = self._knotvector[0]*(k - 1.)
            
            for i in range(1, m + 1):
                self._knotvector[i] = self._knotvector[i]*k - dx
    
    cpdef void hscale(self, double k):
        """
        Scales 'self' horizontally keeping the start of the domain fixed.
        
        Parameters
        ----------
        k: double
            Scale factor.
        
        """
        self.c_hscale(k)
    
    cpdef void adapt(self, double start, double stop):
        """
        Adapts 'self' in a new domain.
        
        Parameters
        ----------
        start: double
            New domain start.
        stop: double
            New domain stop. Must be greather than 'start'.
        
        """
        cdef double k, dx
        
        if start >= stop:
            raise ValueError("'stop' must be strictly greater than 'start'")
        
        k = (stop - start)/(self.stop - self.start)
        self.c_hscale(k)
        
        if self.start != start:
            dx = start - self.start
            self.c_shift(dx)
    
    cpdef Trajectory1d derivative(self, int nu = 1):
        """
        Returns a Trajectory1d object representing the derivative.
        
        Parameters
        ----------
        nu: int
            Derivative order. Default is 1.
        
        Returns
        -------
        out: Trajectory1d
            New Trajectory1d object.
        
        """
        cdef int N = self.n + 1, M = self.n + self.p + 2
        cdef int nk, new_p
        
        if nu < 0:
            raise ValueError(f"'nu' must be greater than or "
                             "equal to zero: {nu}")
        
        cdef double *knotvector = <double*>PyMem_Malloc(M*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] newknotvector_mv = <double[:M]>knotvector
        
        cdef double *cpts = <double*>PyMem_Malloc(N*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] newcpts_mv = <double[:N]>cpts
        
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        
        if nu < 0:
            raise ValueError("'nu' must be non-negative number")
        
        nk = dsplcpts2(knotvector_mv, cpts_mv, self.p, nu, newknotvector_mv,
                       newcpts_mv)
        new_p = self.p - nu
        
        knotvector = <double*>PyMem_Realloc(
                knotvector, (nk + new_p + 2)*sizeof(double))
        cpts = <double*>PyMem_Realloc(cpts, (nk + 1)*sizeof(double))
        
        return Trajectory1d.from_ptrs(knotvector, cpts, new_p, nk,
                                      self.order + nu, owner = True)
    
    cpdef Trajectory1d antiderivative(self, int nu = 1):
        """
        Returns a Trajectory1d object representing the antiderivative.
        
        Parameters
        ----------
        nu: int
            Antiderivative order. Default is 1.
        
        Returns
        -------
        out: Trajectory1d
            New Trajectory1d object.
        
        """
        cdef int N = self.n + 1, M = self.n + self.p + 2
        
        if nu < 0:
            raise ValueError(f"'nu' must be greater than or "
                             "equal to zero: {nu}")
        elif nu > self.order:
            raise ValueError(f"negative 'order' not allowed")
        
        cdef double *knotvector = <double*>PyMem_Malloc(
            (M + 2*nu)*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] newknotvector_mv = <double[:M + 2*nu]>knotvector
        
        cdef double *cpts = <double*>PyMem_Malloc((N + nu)*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] newcpts_mv = <double[:N + nu]>cpts
        
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        
        if nu < 0:
            raise ValueError("'nu' must be non-negative number")
        
        asplcpts(knotvector_mv, cpts_mv, self.p, nu, newknotvector_mv,
                 newcpts_mv)
        
        return Trajectory1d.from_ptrs(knotvector, cpts, self.p + nu,
                                  self.n + nu, self.order - nu, owner = True)
    
    cpdef Trajectory1d knotins(self, double u, int r):
        """
        Returns a new Trajectory1d object with same shape and the knot 'u'
        inserted 'r' times.
        
        Parameters
        ----------
        u: double
            Knot to insert.
        r: int
            Number of times the knot must be inserted.
        
        Returns
        -------
        out: Trajectory1d
            New Trajectory1d object.
        
        """
        cdef int N = self.n + 1, M = self.n + self.p + 2
        
        cdef double *knotvector = <double*>PyMem_Malloc((M + r)*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] newknotvector_mv = <double[:M + r]>knotvector
        
        cdef double *cpts = <double*>PyMem_Malloc((N + r)*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] newcpts_mv = <double[:N + r]>cpts
        
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        
        if u < self.start or u > self.stop:
            raise ValueError("'u' out of domain: {}".format(u))
        if r < 0:
            raise ValueError("'r' must be non-negative number")
        elif r > self.p:
            raise ValueError("'r' must be less than or equal to 'p'")
        
        splkins(knotvector_mv, cpts_mv, self.p, u, r, newknotvector_mv,
                newcpts_mv)
        
        return Trajectory1d.from_ptrs(knotvector, cpts, self.p, self.n + r,
                                      self.order, owner = True)
    
    cpdef Trajectory1d knotref(self, double[::1] X):
        """
        Returns a new Trajectory1d object with same shape and new knots
        inserted.
        
        Parameters
        ----------
        X: double C-contiguous array
            New knots array. Must be in ascending order. New knots x(i)
            should be repeated in X with their multiplicities. Must be
            increasing.
        
        Returns
        -------
        out: Trajectory1d
            New Trajectory1d object.
        
        """
        cdef int N = self.n + 1, M = self.n + self.p + 2
        cdef int r = X.shape[0]
        
        cdef double *knotvector = <double*>PyMem_Malloc((M + r)*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] newknotvector_mv = <double[:M + r]>knotvector
        
        cdef double *cpts = <double*>PyMem_Malloc((N + r)*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] newcpts_mv = <double[:N + r]>cpts
        
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        
        if not issorted(X, r):
            raise ValueError("'X' must be increasing")
        
        splkref(knotvector_mv, cpts_mv, self.p, X, newknotvector_mv,
                newcpts_mv)
        
        return Trajectory1d.from_ptrs(knotvector, cpts, self.p, self.n + r,
                                      self.order, owner = True)
    
    cpdef Trajectory1d knotrem(self, double u, int r, double tol = ATOL):
        """
        Returns a new Trajectory1d object with, if possible, the knot 'u'
        removed 'r' times. If the node 'u' cannot be removed 'r' times, it is
        removed as many times as possible.
        
        Parameters
        ----------
        u: double
            Knot to remove.
        r: int
            Number of times the knot must be removed.
        tol: double
            Tolerance.
        
        Returns
        -------
        out: Trajectory1d
            New Trajectory1d object.
        
        """
        cdef int t, N = self.n + 1, M = self.n + self.p + 2
        
        cdef double *knotvector = <double*>PyMem_Malloc(M*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        c_memcpy(knotvector, self._knotvector, M*sizeof(double))
        cdef double[::1] newknotvector_mv = <double[:M]>knotvector
        
        cdef double *cpts = <double*>PyMem_Malloc(N*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        c_memcpy(cpts, self._cpts, N*sizeof(double))
        cdef double[::1] newcpts_mv = <double[:N]>cpts
        
        if u < self.start or u > self.stop:
            raise ValueError("'u' out of domain: {}".format(u))
        if r < 0:
            raise ValueError("'r' must be non-negative number")
        
        t = splkrem(newknotvector_mv, newcpts_mv, self.p, u, r, tol)
        
        M -= t; N -= t
        knotvector = <double*>PyMem_Realloc(knotvector, M*sizeof(double))
        cpts = <double*>PyMem_Realloc(cpts, N*sizeof(double))
        
        return Trajectory1d.from_ptrs(knotvector, cpts, self.p, N - 1,
                                      self.order, owner = True)
    
    cpdef Trajectory1d knotsrem(self, double tol = ATOL):
        """
        Returns a new Trajectory1d object with as many knots removed as
        possible.
        
        Parameters
        ----------
        tol: double
            Tolerance. Default 1e-11.
        
        Returns
        -------
        out: Trajectory1d
            New Trajectory1d object.
        
        Notes
        -----
        The knot removal tolerance is applied step by step, it is not
        indicative of the error band at the end of the iteration.
        
        """
        cdef int t, N = self.n + 1, M = self.n + self.p + 2
        cdef double *tmpknots
        cdef double *tmpcpts
        
        cdef double *knotvector = <double*>PyMem_Malloc(M*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        c_memcpy(knotvector, self._knotvector, M*sizeof(double))
        cdef double[::1] newknotvector_mv = <double[:M]>knotvector
        
        cdef double *cpts = <double*>PyMem_Malloc(N*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        c_memcpy(cpts, self._cpts, N*sizeof(double))
        cdef double[::1] newcpts_mv = <double[:N]>cpts
        
        t = splksrem(newknotvector_mv, newcpts_mv, self.p, tol)
        
        M -= t; N -= t
        tmpknots = <double*>PyMem_Realloc(knotvector, M*sizeof(double))
        if tmpknots is NULL:
            raise MemoryError("memory allocation failed")
        knotvector = tmpknots
        
        tmpcpts = <double*>PyMem_Realloc(cpts, N*sizeof(double))
        if tmpcpts is NULL:
            raise MemoryError("memory allocation failed")
        cpts = tmpcpts
        
        return Trajectory1d.from_ptrs(knotvector, cpts, self.p, N - 1,
                                      self.order, owner = True)
    
    cpdef Trajectory1d knotrem_notol(self, double u, int r):
        """
        Returns a new Trajectory1d object with knot 'u' removed 'r' times
        without tolerance check.
        
        Parameters
        ----------
        u: double
            Knot to remove.
        r: int
            Number of times the knot must be removed.
        
        Returns
        -------
        out: Trajectory1d
            New Trajectory1d object.
        
        """
        cdef int t, N = self.n + 1, M = self.n + self.p + 2
        
        cdef double *knotvector = <double*>PyMem_Malloc(M*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        c_memcpy(knotvector, self._knotvector, M*sizeof(double))
        cdef double[::1] newknotvector_mv = <double[:M]>knotvector
        
        cdef double *cpts = <double*>PyMem_Malloc(N*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        c_memcpy(cpts, self._cpts, N*sizeof(double))
        cdef double[::1] newcpts_mv = <double[:N]>cpts
        
        if u < self.start or u > self.stop:
            raise ValueError("'u' out of domain: {}".format(u))
        if r < 0:
            raise ValueError("'r' must be non-negative number")
        
        t = splkrem_notol(newknotvector_mv, newcpts_mv, self.p, u, r)
        
        M -= t; N -= t
        knotvector = <double*>PyMem_Realloc(knotvector, M*sizeof(double))
        cpts = <double*>PyMem_Realloc(cpts, N*sizeof(double))
        
        return Trajectory1d.from_ptrs(knotvector, cpts, self.p, N - 1,
                                      self.order, owner = True)
    
    cpdef Trajectory1d copy(self):
        """
        Return a copy of the object.
        
        """
        cdef int N = self.n + 1, M = self.n + self.p + 2
        
        cdef double *knotvector = <double*>PyMem_Malloc(M*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        c_memcpy(knotvector, self._knotvector, M*sizeof(double))
        
        cdef double *cpts = <double*>PyMem_Malloc(N*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        c_memcpy(cpts, self._cpts, N*sizeof(double))
        
        return Trajectory1d.from_ptrs(knotvector, cpts, self.p, self.n,
                                      self.order, owner = True)
    
    def __copy__(self):
        return self.copy()
    
    def __deepcopy__(self, memo):
        return self.copy()
    
    cpdef Trajectory1d degelev(self, int nu = 1):
        """
        Increases the degree of the B-Spline interpolating the trajectory.
        
        Parameters
        ----------
        nu: int
            Number of degree elevation times.
        
        Returns
        -------
        out: Trajectory1d
            New Trajectory1d object with the same shape and degree
            self.p + 'nu'.
        
        """
        cdef int N = self.n + 1, M = self.n + self.p + 2
        
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        
        cdef int s = distintknots(knotvector_mv, self.p)
        
        cdef double *knotvector = <double*>PyMem_Malloc(
                (M + nu*(s + 2))*sizeof(double))
        if knotvector is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] newknotvector_mv = <double[:M + nu*(s + 2)]>knotvector
        
        cdef double *cpts = <double*>PyMem_Malloc(
                (N + nu*(s + 1))*sizeof(double))
        if cpts is NULL:
            raise MemoryError("memory allocation failed")
        cdef double[::1] newcpts_mv = <double[:N + nu*(s + 1)]>cpts
        
        if nu < 0:
            raise ValueError("'nu' must be non-negative number")
        
        degelevc(knotvector_mv, cpts_mv, self.p, nu, newknotvector_mv,
                 newcpts_mv)
        
        return Trajectory1d.from_ptrs(knotvector, cpts, self.p + nu,
                              self.n + nu*(s + 1), self.order, owner = True)
    
    cpdef void setValueTr(self, constr p):
        """
        Sets a condition by vertical shift of the trajectory. This method
        cannot be used to set a constraint on the n-th antiderivative.
        
        Parameters
        ----------
        p: constr (fused type: Point1d or 3-elements tuple)
            Constraint to be set. If 3-elements tuple must be in format
                
                (t, val, order)
            
            For the description of the 't', 'val' and 'order' attributes
            see Point1d class documentation.
        
        """
        cdef double oldvalue
        cdef int relord
        
        if type(p) is tuple:
            p = Point1d.from_tuple(p)
        
        relord = p.order - self.order
        
        if relord < 0:
            raise ValueError("this method cannot be used to set a constraint "
                             "on the n-th antiderivative")
        
        oldvalue = self.dpeval(p.t, nu = relord)
        self.c_iadd(p.val - oldvalue)
    
    cpdef void setValueAm(self, constr p):
        """
        Sets a constraint multiplying the trajectory by a calculated constant.
        This function cannot be used to set a constraint close to zero,
        otherwise the whole trajectory is set to zero.
        
        Parameters
        ----------
        p: constr (fused type: Point1d or 3-elements tuple)
            Constraint to be set. If 3-elements tuple must be in format
                
                (t, val, order)
            
            For the description of the 't', 'val' and 'order' attributes
            see Point1d class documentation.
        
        """
        cdef double oldvalue
        cdef int relord
        cdef Trajectory1d tmp
        
        if type(p) is tuple:
            p = Point1d.from_tuple(p)
        
        relord = p.order - self.order
        
        if relord >= 0:
            oldvalue = self.dpeval(p.t, nu = relord)
        else:
            tmp = self.antiderivative(nu = -relord)
            oldvalue = tmp.peval(p.t)
        
        self.c_imul(p.val/oldvalue)
    
    property start:
        """ Left end of the curve domain. """
        def __get__(self):
            if self._knotvector is not NULL:
                return self._knotvector[0]
            else:
                return None
    
    property stop:
        """ Right end of the curve domain. """
        def __get__(self):
            if self._knotvector is not NULL:
                return self._knotvector[self.n + self.p + 1]
            else:
                return None
    
    def get_xcpts(self):
        """
        Returns the x-coordinates of the control points.
        
        """
        cdef int N = self.n + 1, M = self.n + self.p + 2
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef np.ndarray[dtype = double, ndim = 1] ndarray
        
        ndarray = np.empty(N, dtype=np.float64)
        averagcpts(knotvector_mv, self.p, ndarray)
        
        return ndarray
    
    def get_knotvector_asarray(self):
        """
        Creates an array wrapper around '_knotvector' pointer. If the new array
        is deallocated the memory is not freed.
        
        """
        cdef np.npy_intp M = self.n + self.p + 2
        cdef np.ndarray[dtype = double, ndim = 1] ndarray
        
        if self._knotvector is not NULL:
            ndarray = np.PyArray_SimpleNewFromData(
                    1, &M, np.NPY_DOUBLE, self._knotvector)
            return ndarray
        else:
            return None
    
    def get_cpts_asarray(self):
        """
        Creates an array wrapper around '_cpts' pointer. If the new array is
        deallocated the memory is not freed.
        
        """
        cdef np.npy_intp N = self.n + 1
        cdef np.ndarray[dtype = double, ndim = 1] ndarray
        
        if self._cpts is not NULL:
            ndarray = np.PyArray_SimpleNewFromData(
                    1, &N, np.NPY_DOUBLE, self._cpts)
            return ndarray
        else:
            return None
    
    cpdef dict _getAttrib(self):
        """
        Returns the attributes of the object as a dictionary.
        
        """
        cdef dict attrib
        
        attrib = dict(
            p = f"{self.p}",
            n = f"{self.n}",
            owner = f"{self.ptrs_owner}",
            order = f"{self.order}",
            start = f"{self.start}",
            stop = f"{self.stop}"
            )
        
        return attrib
    
    cpdef void _addPyIPTPObject(self, object root, str ID):
        cdef int N = self.n + 1, M = self.n + self.p + 2
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        cdef dict attrib = dict(ID = f"{ID}")
        cdef object node, subnode_cpts, subnode_knots
        
        attrib.update(self._getAttrib())
        
        node = etree.SubElement(root, f"{self.__class__.__name__}",
                                attrib = attrib)
        subnode_cpts = etree.SubElement(node, "cpts")
        subnode_cpts.text = ' '.join(map(str, cpts_mv))
        subnode_knots = etree.SubElement(node, "knots")
        subnode_knots.text = ' '.join(map(str, knotvector_mv))
    
    cpdef void _updatePyIPTPObject(self, object tree, object node, str ID):
        cdef int N = self.n + 1, M = self.n + self.p + 2
        cdef double[::1] knotvector_mv = <double[:M]>self._knotvector
        cdef double[::1] cpts_mv = <double[:N]>self._cpts
        cdef dict attrib = self._getAttrib()
        cdef object subnode_cpts, subnode_knots
        cdef str key
        
        for key in attrib.keys():
            node.set(key, attrib[key])
        
        subnode_cpts = tree.xpath(
        f"/PyIPTPObjectList/{self.__class__.__name__}[@ID='{ID}']/cpts")[0]
        subnode_knots = tree.xpath(
        f"/PyIPTPObjectList/{self.__class__.__name__}[@ID='{ID}']/knots")[0]
        
        subnode_cpts.text = ' '.join(map(str, cpts_mv))
        subnode_knots.text = ' '.join(map(str, knotvector_mv))

cdef c_point1d make_point(double u, double value, unsigned int order):
    cdef c_point1d p = c_point1d(u, value, order)
    return p

cdef class Point1d(PyIPTPObject):
    """
    Simple class for storing a point in joint space.
    
    Properties
    ----------
    t: double
        Time coordinate.
    val: double
        Numeric value.
    order: unsigned int
        Order of derivation to which the coordinate refers. Must be greater
        than or equal to zero. Example:
            
            0: displacement
            1: velocity
            2: acceleration
            3: jerk
            ...
    
    Methods
    -------
    copy():
        Return a copy of the object.
    savexml(fname, ID):
        Method to save a Point1d object to a file in .xml format.
    
    Staticmethod
    ------------
    loadxml(fname, ID):
        Method to load a Point1d object from a file in .xml format.
    
    """
    def __init__(self, double t, double val, unsigned int order):
        self.p = make_point(t, val, order)
    
    @staticmethod
    def from_tuple(pnt: tuple) -> Point1d:
        """
        Factory function to create Point1d objects from given tuple.
        
        """
        cdef Point1d wrapper = Point1d.__new__(Point1d)
        
        wrapper.t = <double>pnt[0]
        wrapper.val = <double>pnt[1]
        wrapper.order = <unsigned int>pnt[2]
        return wrapper
    
    @staticmethod
    cdef Point1d c_loadxml(str fname, str ID):
        """
        C-method to load a Point1d object from a file in .xml format.
        
        Parameters
        ----------
        fname: str
            File name. If the file extension is not specified, the .pyiptp
            extension is used.
        ID: str
            Object ID.
        
        """
        # Call to __new__ bypasses __init__ constructor
        cdef Point1d wrapper = Point1d.__new__(Point1d)
        cdef str extension
        cdef object tree
        cdef list matchlist
        cdef object node
        
        # check if the file name contains the extension
        extension = os.path.splitext(fname)[1]
        
        # if the file extension is not specified, the default is set
        if extension == "":
            fname += DEF_EXT
        
        tree = etree.parse(fname)
        matchlist = tree.xpath(
            f"/PyIPTPObjectList/Point1d[@ID='{ID}']")
        
        if not matchlist.__len__():
            raise ValueError(f"no match for ID: {ID}")
        
        node = matchlist[0]
        wrapper.t = float(node.get("t"))
        wrapper.val = float(node.get("val"))
        wrapper.order = int(node.get("order"))
        
        return wrapper
    
    @staticmethod
    def loadxml(fname: str, ID: str) -> Point1d:
        """
        Method to load a Point1d object from a file in .xml format.
        
        Parameters
        ----------
        fname: str
            File name. If the file extension is not specified, the .pyiptp
            extension is used.
        ID: str
            Object ID.
        
        """
        return Point1d.c_loadxml(fname, ID)
    
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (
                self.t == other.t and
                self.val == other.val and
                self.order == other.order
                )
        else:
            return False
    
    def __ne__(self, other):
        return not self.__eq__(other)
    
    cpdef Point1d copy(self):
        """
        Return a copy of the object.
        
        """
        cdef Point1d wrapper = Point1d.__new__(Point1d)
        
        wrapper.p = make_point(self.t, self.val, self.order)
        return wrapper
    
    def __copy__(self):
        return self.copy()
    
    def __deepcopy__(self, memo):
        return self.copy()
    
    cpdef dict _getAttrib(self):
        """
        Returns a dictionary containing the attributes of the object.
        
        """
        cdef dict attrib
        
        attrib = dict(
            t = f"{self.t}",
            val = f"{self.val}",
            order = f"{self.order}"
            )
        
        return attrib
    
    cpdef void _addPyIPTPObject(self, object root, str ID):
        cdef dict attrib = dict(ID = f"{ID}")
        cdef object node
        
        attrib.update(self._getAttrib())
        
        node = etree.SubElement(root, f"{self.__class__.__name__}",
                                attrib = attrib)
    
    cpdef void _updatePyIPTPObject(self, object tree, object node, str ID):
        cdef dict attrib = self._getAttrib()
        cdef str key
        
        for key in attrib.keys():
            node.set(key, attrib[key])
    
    def __repr__(self):
        return (f"{{\'t\': {self.u}, \'val\': {self.value}, "
                f"\'order\': {self.order}}}")
    
    def __str__(self):
        return (f"Point1d(t = {self.t}, val = {self.val}, "
                f"order = {self.order})")
    
    property t:
        def __get__(self): return self.p.t
        def __set__(self, t): self.p.t = t
    
    property val:
        def __get__(self): return self.p.val
        def __set__(self, val): self.p.val = val
    
    property order:
        def __get__(self): return self.p.order
        def __set__(self, order): self.p.order = order

include "utils.pxi"