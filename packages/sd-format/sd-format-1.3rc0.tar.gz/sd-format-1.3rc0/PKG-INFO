Metadata-Version: 2.1
Name: sd-format
Version: 1.3rc0
Summary: Library for working with the .sd format designed to store configuration and service data
Home-page: https://github.com/aleks-daliton/sd
Author: DALITON
Author-email: products_support@daliton.org
License: UNKNOWN
Description: # Library for working with the .sd format designed to store configuration and service data (En)
        
            ####################################################################################################
            #
            # The basic concepts and opportunities incorporated in the development of the format:
            #     Maximum accessibility for the perception of complex structured data
            #     Simple and intuitive syntactic rules
            #     Capability of lists as values
            #     Capability of using dictionaries as values
            #     Possibility of multilinear recording of values
            #     Ability to work with comments to the data
            #     Possibility to work with comments to the file
            # --------------------------------------------------------------------------------------------------
            # To convert data stored in .sd format into python dict format, you need to pass the address of the data file:
            #     from sd_format import sd
            #     sd_obj = sd(sd_file_path)
            #     my_dict = sd_obj.decoding_result
            # If you want to save the Python dictionary as an .sd file, pass in the following address
            # pass in the address where the file should be saved as well as the dictionary itself:
            #     from sd_format import sd
            #     sd(sd_file_path, my_dict)
            # You can get detailed information with a description of the syntax and an example of the contents of the sd file in the console via a function call:
            #     sd_info()
            #
            ####################################################################################################
        
            # Example of recording data in .sd format:
                _main_key_0 = 
        
                # some comment for main_key_1
                main_key_1 =
                .key_1:
                ..key_1_1:  """String with spaces. Possibly other type of quotes."""    # some comment for key_1_1
                ..key_1_2:
                ...key_1_2_1: lue_without_spaces
                ...key_1_2_2:  """triple quoted values can contain characters such as space or comma"""
                .key_2: value_2_1, """last list element"""
                .key_3: a_good_solution_is_to_place_an_element_value_greater_than_50_characters_as_the_only_one
                
                main_key_2 = some_value_will_be_read_as_a_string    # comment for the main_key_2
                main_key_3 = value_3_1, value_3_2, the_long_element_value_over_50_characters_is_placed_last
                main_key_4 = key_4_1: v_4_1_1, key_4_2: in_a_one_line_notation_each_key_has_only_one_str_value
                main_key_5 = key_5_1: v_5_1_1, key_5_2: v_5_2_1, key_5_3: """should be used no more than 3 pair"""
                
                # temporary comment
                main_key_6 =    # comment for the main_key_6
                '''
                Multi-line write of value,
                for main_key_6.
                '''
                
                main_key_7 = """I'm glad to your attention. If bugs are found, write: bug_report@daliton.org"""
        
        
            ####################################################################################################
            #
            # After decoding, the data is converted to Python dict:
            #     dict = {
            #         'keys_comments': {
            #             'own_comments': ['Title of .sd file', 'Top description', 'Bottom description'], 
            #             '_main_key_0': {'own_comments': ['', '']}, 
            #             'main_key_1 ': {
            #                 'key_1': {
            #                     'own_comments': ['', ''], 
            #                     'key_1_1': {'own_comments': ['', 'some comment for key_1_1']}, 
            #                     'key_1_2': {
            #                         'own_comments': ['', ''], 
            #                         'key_1_2_1': {'own_comments': ['', '']}, 
            #                         'key_1_2_2': {'own_comments': ['', '']
            #                                       }
            #                     }
            #                 }, 
            #                 'key_2': {'own_comments': ['', '']}, 
            #                 'key_3': {'own_comments': ['', '']}, 
            #                  'own_comments': ['some comment for main_key_1', '']
            #             }, 
            #             'main_key_2 ': {'own_comments': ['', 'comment for the main_key_2']}, 
            #             'main_key_3 ': {'own_comments': ['', '']}, 
            #             'main_key_4 ': {'own_comments': ['', '']}, 
            #             'main_key_5 ': {'own_comments': ['', '']}, 
            #             'main_key_6 ': {'own_comments': ['temporary comment', 'comment for the main_key_6']}, 
            #             'main_key_7 ': {'own_comments': ['', '']}
            #         }, 
            #         '_main_key_0': '', 
            #         'main_key_1 ': {
            #             'key_1': {
            #                 'key_1_1': 'String with spaces. Possibly other type of quotes.', 
            #                 'key_1_2': {
            #                     'key_1_2_1': 'lue_without_spaces', 
            #                     'key_1_2_2': 'triple quoted values can contain characters such as space or comma'
            #                 }
            #             }, 
            #             'key_2': ['value_2_1', 'last list element'], 
            #             'key_3': 'a_good_solution_is_to_place_an_element_value_greater_than_50_characters_as_the_only_one'
            #         }, 
            #         'main_key_2 ': 'some_value_will_be_read_as_a_string', 
            #         'main_key_3 ': ['value_3_1', 'value_3_2', 'the_long_element_value_over_50_characters_is_placed_last'], 
            #         'main_key_4 ': {'key_4_1': 'v_4_1_1', 'key_4_2': 'in_a_one_line_notation_each_key_has_only_one_str_value'}, 
            #         'main_key_5 ': {'key_5_1': 'v_5_1_1', 'key_5_2': 'v_5_2_1', 'key_5_3': 'should be used no more than 3 pair'}, 
            #         'main_key_6 ': 'Multi-line write of value,\nfor main_key_6.', 
            #         'main_key_7 ': "I'm glad to your attention. If bugs are found, write: bug_report@daliton.org"
            #     }
            #
            ####################################################################################################
            
            
            Translated with www.DeepL.com/Translator (free version)
        
        
        # Библиотека для работы с .sd форматом, предназначенным для записи служебных и конфигурационных данных (Ru)
            # Основные концепции и возможности, заложенные при разработке формата:
            #     Максимальная доступность для восприятия сложных по структуре данных
            #     Простые и интуитивно понятные синтаксические правила
            #     Возможность использования в качестве значений списков
            #     Возможность использования в качестве значений словарей
            #     Возможность многострочной записи значений
            #     Возможность работы с комментариями к данным
            #     Возможность работы с комментариями к файлу
            # -------------------------------------------------------------------------------------------------
            # Для преобразования данных хранящихся в формате .sd в формат python dict, необходимо передать адрес файла с данными:
            #     sd_obj = sd(sd_file_path)
            #     my_dict = sd_obj.decoding_result
            # Для сохранения словаря Python в файл в формате .sd, в качестве параметров необходимо
            # передать адрес по которому нужно сохранить файл, а также сам словарь:
            #     sd(sd_file_path, my_dict)
            # Подробную информацию с описанием синтаксиса и примером содержимого файла sd всегда можно вывести в консоль
            # через вызов функции:
            #     sd_info()
        
            # Пример записи данных в формате .sd:
                # some comment for main_key_1
                main_key_1 =
                .key_1:
                ..key_1_1:  """String with spaces. Possibly other type of quotes."""    # some comment for key_1_1
                ..key_1_2:
                ...key_1_2_1: lue_without_spaces
                ...key_1_2_2:  """triple quoted values can contain characters such as space or comma"""
                .key_2: value_2_1, """last list element"""
                .key_3: a_good_solution_is_to_place_an_element_value_greater_than_50_characters_as_the_only_one
                
                main_key_2 = some_value_will_be_read_as_a_string    # comment for the main_key_2
                main_key_3 = value_3_1, value_3_2, the_long_element_value_over_50_characters_is_placed_last
                main_key_4 = key_4_1: v_4_1_1, key_4_2: in_a_one_line_notation_each_key_has_only_one_str_value
                main_key_5 = key_5_1: v_5_1_1, key_5_2: v_5_2_1, key_5_3: """should be used no more than 3 pair"""
                
                # temporary comment
                main_key_6 =    # comment for the main_key_6
                '''
                Multi-line write of value,
                for main_key_6.
                '''
                
                main_key_7 = """I'm glad to your attention. If bugs are found, write: bug_report@daliton.org"""
        
        
            ####################################################################################################
            #
            # После декодирования данные преобразуются в Python dict:
            #     dict = {
            #         'keys_comments': {
            #             'own_comments': ['Title of .sd file', 'Top description', 'Bottom description'], 
            #             '_main_key_0': {'own_comments': ['', '']}, 
            #             'main_key_1 ': {
            #                 'key_1': {
            #                     'own_comments': ['', ''], 
            #                     'key_1_1': {'own_comments': ['', 'some comment for key_1_1']}, 
            #                     'key_1_2': {
            #                         'own_comments': ['', ''], 
            #                         'key_1_2_1': {'own_comments': ['', '']}, 
            #                         'key_1_2_2': {'own_comments': ['', '']
            #                                       }
            #                     }
            #                 }, 
            #                 'key_2': {'own_comments': ['', '']}, 
            #                 'key_3': {'own_comments': ['', '']}, 
            #                 'own_comments': ['some comment for main_key_1', '']
            #             }, 
            #             'main_key_2 ': {'own_comments': ['', 'comment for the main_key_2']}, 
            #             'main_key_3 ': {'own_comments': ['', '']}, 
            #             'main_key_4 ': {'own_comments': ['', '']}, 
            #             'main_key_5 ': {'own_comments': ['', '']}, 
            #             'main_key_6 ': {'own_comments': ['temporary comment', 'comment for the main_key_6']}, 
            #             'main_key_7 ': {'own_comments': ['', '']}
            #         }, 
            #         '_main_key_0': '', 
            #         'main_key_1 ': {
            #             'key_1': {
            #                 'key_1_1': 'String with spaces. Possibly other type of quotes.', 
            #                 'key_1_2': {
            #                     'key_1_2_1': 'lue_without_spaces', 
            #                     'key_1_2_2': 'triple quoted values can contain characters such as space or comma'
            #                 }
            #             }, 
            #             'key_2': ['value_2_1', 'last list element'], 
            #             'key_3': 'a_good_solution_is_to_place_an_element_value_greater_than_50_characters_as_the_only_one'
            #         }, 
            #         'main_key_2 ': 'some_value_will_be_read_as_a_string', 
            #         'main_key_3 ': ['value_3_1', 'value_3_2', 'the_long_element_value_over_50_characters_is_placed_last'], 
            #         'main_key_4 ': {'key_4_1': 'v_4_1_1', 'key_4_2': 'in_a_one_line_notation_each_key_has_only_one_str_value'}, 
            #         'main_key_5 ': {'key_5_1': 'v_5_1_1', 'key_5_2': 'v_5_2_1', 'key_5_3': 'should be used no more than 3 pair'}, 
            #         'main_key_6 ': 'Multi-line write of value,\nfor main_key_6.', 
            #         'main_key_7 ': "I'm glad to your attention. If bugs are found, write: bug_report@daliton.org"
            #     }
            #
            ####################################################################################################
        
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3.8
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.6
Description-Content-Type: text/markdown
