

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Genetic algorithm &mdash; ACAT 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/table_styling.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/acat_favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Other utilities" href="utilities.html" />
    <link rel="prev" title="Building things" href="build.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> ACAT
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">Base modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html">Building things</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Genetic algorithm</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-acat.ga.adsorbate_operators">Optimize adsorbate overlayer pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-acat.ga.group_operators">Symmetry-constrained genetic algorithm for nanoalloys</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Other utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes.html">Notes</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ACAT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Genetic algorithm</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/ga.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="genetic-algorithm">
<h1>Genetic algorithm<a class="headerlink" href="#genetic-algorithm" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-acat.ga.adsorbate_operators">
<span id="optimize-adsorbate-overlayer-pattern"></span><h2>Optimize adsorbate overlayer pattern<a class="headerlink" href="#module-acat.ga.adsorbate_operators" title="Permalink to this headline">¶</a></h2>
<p>Adsorbate procreation operators that adds an adsorbate to the surface of
a particle or given structure.</p>
<dl class="py class">
<dt id="acat.ga.adsorbate_operators.AdsorbateOperator">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.adsorbate_operators.</code><code class="sig-name descname">AdsorbateOperator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">adsorbate_species</span></em>, <em class="sig-param"><span class="n">num_muts</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#AdsorbateOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.AdsorbateOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ase.ga.offspring_creator.OffspringCreator</span></code></p>
<p>Base class for all operators that add, move or remove adsorbates.</p>
<p>Don’t use this operator directly!</p>
<dl class="py method">
<dt id="acat.ga.adsorbate_operators.AdsorbateOperator.initialize_individual">
<em class="property">classmethod </em><code class="sig-name descname">initialize_individual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parent</span></em>, <em class="sig-param"><span class="n">indi</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#AdsorbateOperator.initialize_individual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.AdsorbateOperator.initialize_individual" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a new individual that inherits some parameters
from the parent, and initializes the info dictionary.
If the new individual already has more structure it can be
supplied in the parameter indi.</p>
</dd></dl>

<dl class="py method">
<dt id="acat.ga.adsorbate_operators.AdsorbateOperator.get_new_individual">
<code class="sig-name descname">get_new_individual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parents</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#AdsorbateOperator.get_new_individual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.AdsorbateOperator.get_new_individual" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns a new individual.
Overwrite in subclass.</p>
</dd></dl>

<dl class="py method">
<dt id="acat.ga.adsorbate_operators.AdsorbateOperator.add_adsorbate">
<code class="sig-name descname">add_adsorbate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atoms</span></em>, <em class="sig-param"><span class="n">hetero_site_list</span></em>, <em class="sig-param"><span class="n">heights</span></em>, <em class="sig-param"><span class="n">adsorbate_species</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_adsorbate_distance</span><span class="o">=</span><span class="default_value">2.0</span></em>, <em class="sig-param"><span class="n">tilt_angle</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#AdsorbateOperator.add_adsorbate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.AdsorbateOperator.add_adsorbate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the adsorbate in self.adsorbate to the supplied atoms
object at the first free site in the specified site_list. A site
is free if no other adsorbates can be found in a sphere of radius
min_adsorbate_distance around the chosen site.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>ase.Atoms object</em>) – The atoms object that the adsorbate will be added to.</p></li>
<li><p><strong>hetero_site_list</strong> (<em>list</em>) – A list of dictionaries, each dictionary contains site
information given by acat.adsorbate_coverage module.</p></li>
<li><p><strong>heights</strong> (<em>dict</em>) – A dictionary that contains the adsorbate height for each site
type.</p></li>
<li><p><strong>adsorbate_species</strong> (<em>str</em><em> or </em><em>list of strs</em><em>, </em><em>default None</em>) – One or a list of adsorbate species to be added to the surface.
Use self.adsorbate_species if not specified.</p></li>
<li><p><strong>min_adsorbate_distance</strong> (<em>float</em><em>, </em><em>default 2.</em>) – The radius of the sphere inside which no other adsorbates
should be found.</p></li>
<li><p><strong>tilt_angle</strong> (<em>float</em><em>, </em><em>default 0.</em>) – Tilt the adsorbate with an angle (in degress) relative to the
surface normal.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="acat.ga.adsorbate_operators.AdsorbateOperator.remove_adsorbate">
<code class="sig-name descname">remove_adsorbate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atoms</span></em>, <em class="sig-param"><span class="n">hetero_site_list</span></em>, <em class="sig-param"><span class="n">return_site_index</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#AdsorbateOperator.remove_adsorbate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.AdsorbateOperator.remove_adsorbate" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes an adsorbate from the atoms object at the first occupied
site in hetero_site_list. If no adsorbates can be found, one will be
added instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>ase.Atoms object</em>) – The atoms object that the adsorbate will be added to</p></li>
<li><p><strong>hetero_site_list</strong> (<em>list</em>) – A list of dictionaries, each dictionary contains site
information given by acat.adsorbate_coverage module.</p></li>
<li><p><strong>return_site_index</strong> (<em>bool</em><em>, </em><em>default False</em>) – Whether to return the site index of the hetero_site_list instead
of the site. Useful for moving or replacing adsorbate.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="acat.ga.adsorbate_operators.AdsorbateOperator.get_adsorbate_indices">
<code class="sig-name descname">get_adsorbate_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atoms</span></em>, <em class="sig-param"><span class="n">position</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#AdsorbateOperator.get_adsorbate_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.AdsorbateOperator.get_adsorbate_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the adsorbate at the supplied position.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.adsorbate_operators.AddAdsorbate">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.adsorbate_operators.</code><code class="sig-name descname">AddAdsorbate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">adsorbate_species</span></em>, <em class="sig-param"><span class="n">heights</span><span class="o">=</span><span class="default_value">{'3fold': 1.3, '4fold': 1.3, '5fold': 1.5, '6fold': 0.0, 'bridge': 1.5, 'fcc': 1.3, 'hcp': 1.3, 'longbridge': 1.5, 'ontop': 1.8, 'shortbridge': 1.5}</span></em>, <em class="sig-param"><span class="n">min_adsorbate_distance</span><span class="o">=</span><span class="default_value">2.0</span></em>, <em class="sig-param"><span class="n">adsorption_sites</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">surface</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allow_6fold</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">site_preference</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">surface_preference</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tilt_angle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_muts</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">dmax</span><span class="o">=</span><span class="default_value">2.5</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#AddAdsorbate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.AddAdsorbate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#acat.ga.adsorbate_operators.AdsorbateOperator" title="acat.ga.adsorbate_operators.AdsorbateOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">acat.ga.adsorbate_operators.AdsorbateOperator</span></code></a></p>
<p>Use this operator to add adsorbates to the surface.
The surface is allowed to change during the algorithm run.</p>
<p>There is no limit of adsorbate species. You can either provide one
species or a list of species.</p>
<p>Site and surface preference can be supplied. If both are supplied site
will be considered first.</p>
<p>Supplying a tilt angle will tilt the adsorbate with an angle relative
to the standard perpendicular to the surface.</p>
<p>The operator is generalized for both periodic and non-periodic systems
(distinguished by atoms.pbc).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adsorbate_species</strong> (<em>str</em><em> or </em><em>list of strs</em>) – One or a list of adsorbate species to be added to the surface.</p></li>
<li><p><strong>heights</strong> (<em>dict</em><em>, </em><em>default acat.settings.site_heights</em>) – A dictionary that contains the adsorbate height for each site
type. Use the default height settings if the height for a site
type is not specified.</p></li>
<li><p><strong>min_adsorbate_distance</strong> (<em>float</em><em>, </em><em>default 2.</em>) – The radius of the sphere inside which no other adsorbates
should be found.</p></li>
<li><p><strong>adsorption_sites</strong> (<em>acat.adsorption_sites.ClusterAdsorptionSites object</em><em>         or </em><em>acat.adsorption_sites.SlabAdsorptionSites object</em><em>, </em><em>default None</em>) – Provide the built-in adsorption sites class to accelerate the
genetic algorithm. Make sure all the operators used with this
operator preserve the indexing of the atoms.</p></li>
<li><p><strong>surface</strong> (<em>str</em><em>, </em><em>default None</em>) – The surface type (crystal structure + Miller indices).
Only required if the structure is a periodic surface slab.</p></li>
<li><p><strong>allow_6fold</strong> (<em>bool</em><em>, </em><em>default False</em>) – Whether to allow the adsorption on 6-fold subsurf sites
underneath fcc hollow sites.</p></li>
<li><p><strong>site_preference</strong> (<em>str</em><em>, </em><em>defualt None</em>) – The site type that has higher priority to attach adsorbates.</p></li>
<li><p><strong>surface_preference</strong> (<em>str</em><em>, </em><em>default None</em>) – The surface type that has higher priority to attach adsorbates.
Please only use this for nanoparticles.</p></li>
<li><p><strong>tilt_angle</strong> (<em>float</em><em>, </em><em>default 0.</em>) – Tilt the adsorbate with an angle (in degress) relative to the
surface normal.</p></li>
<li><p><strong>num_muts</strong> (<em>int</em><em>, </em><em>default 1</em>) – The number of times to perform this operation.</p></li>
<li><p><strong>dmax</strong> (<em>float</em><em>, </em><em>default 2.5</em>) – The maximum bond length (in Angstrom) between the site and the
bonding atom  that should be considered as an adsorbate.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.adsorbate_operators.AddAdsorbate.get_new_individual">
<code class="sig-name descname">get_new_individual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parents</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#AddAdsorbate.get_new_individual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.AddAdsorbate.get_new_individual" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the new individual as an atoms object.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.adsorbate_operators.RemoveAdsorbate">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.adsorbate_operators.</code><code class="sig-name descname">RemoveAdsorbate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">adsorbate_species</span></em>, <em class="sig-param"><span class="n">adsorption_sites</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">surface</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allow_6fold</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">site_preference</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">surface_preference</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_muts</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">dmax</span><span class="o">=</span><span class="default_value">2.5</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#RemoveAdsorbate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.RemoveAdsorbate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#acat.ga.adsorbate_operators.AdsorbateOperator" title="acat.ga.adsorbate_operators.AdsorbateOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">acat.ga.adsorbate_operators.AdsorbateOperator</span></code></a></p>
<p>This operator removes an adsorbate from the surface. It works
exactly (but doing the opposite) as the AddAdsorbate operator.</p>
<p>The operator is generalized for both periodic and non-periodic systems
(distinguished by atoms.pbc).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adsorbate_species</strong> (<em>str</em><em> or </em><em>list of strs</em>) – One or a list of adsorbate species to be removed from the surface.</p></li>
<li><p><strong>adsorption_sites</strong> (<em>acat.adsorption_sites.ClusterAdsorptionSites object</em><em>         or </em><em>acat.adsorption_sites.SlabAdsorptionSites object</em><em>, </em><em>default None</em>) – Provide the built-in adsorption sites class to accelerate the
genetic algorithm. Make sure all the operators used with this
operator preserve the indexing of the atoms.</p></li>
<li><p><strong>surface</strong> (<em>str</em><em>, </em><em>default None</em>) – The surface type (crystal structure + Miller indices).
Only required if the structure is a periodic surface slab.</p></li>
<li><p><strong>allow_6fold</strong> (<em>bool</em><em>, </em><em>default False</em>) – Whether to allow the adsorption on 6-fold subsurf sites underneath
fcc hollow sites.</p></li>
<li><p><strong>site_preference</strong> (<em>str</em><em>, </em><em>defualt None</em>) – The site type that has higher priority to attach adsorbates.</p></li>
<li><p><strong>surface_preference</strong> (<em>str</em><em>, </em><em>default None</em>) – The surface type that has higher priority to attach adsorbates.
Please only use this for nanoparticles.</p></li>
<li><p><strong>tilt_angle</strong> (<em>float</em><em>, </em><em>default 0.</em>) – Tilt the adsorbate with an angle (in degress) relative to the
surface normal.</p></li>
<li><p><strong>num_muts</strong> (<em>int</em><em>, </em><em>default 1</em>) – The number of times to perform this operation.</p></li>
<li><p><strong>dmax</strong> (<em>float</em><em>, </em><em>default 2.5</em>) – The maximum bond length (in Angstrom) between the site and the
bonding atom  that should be considered as an adsorbate.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.adsorbate_operators.RemoveAdsorbate.get_new_individual">
<code class="sig-name descname">get_new_individual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parents</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#RemoveAdsorbate.get_new_individual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.RemoveAdsorbate.get_new_individual" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns a new individual.
Overwrite in subclass.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.adsorbate_operators.MoveAdsorbate">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.adsorbate_operators.</code><code class="sig-name descname">MoveAdsorbate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">adsorbate_species</span></em>, <em class="sig-param"><span class="n">heights</span><span class="o">=</span><span class="default_value">{'3fold': 1.3, '4fold': 1.3, '5fold': 1.5, '6fold': 0.0, 'bridge': 1.5, 'fcc': 1.3, 'hcp': 1.3, 'longbridge': 1.5, 'ontop': 1.8, 'shortbridge': 1.5}</span></em>, <em class="sig-param"><span class="n">min_adsorbate_distance</span><span class="o">=</span><span class="default_value">2.0</span></em>, <em class="sig-param"><span class="n">adsorption_sites</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">surface</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allow_6fold</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">site_preference_from</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">surface_preference_from</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">site_preference_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">surface_preference_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tilt_angle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_muts</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">dmax</span><span class="o">=</span><span class="default_value">2.5</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#MoveAdsorbate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.MoveAdsorbate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#acat.ga.adsorbate_operators.AdsorbateOperator" title="acat.ga.adsorbate_operators.AdsorbateOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">acat.ga.adsorbate_operators.AdsorbateOperator</span></code></a></p>
<p>This operator removes an adsorbate from the surface and adds it
again to a different site, i.e. effectively moving the adsorbate.</p>
<p>The operator is generalized for both periodic and non-periodic systems
(distinguished by atoms.pbc).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adsorbate_species</strong> (<em>str</em><em> or </em><em>list of strs</em>) – One or a list of adsorbate species to be added to the surface.</p></li>
<li><p><strong>heights</strong> (<em>dict</em><em>, </em><em>default acat.settings.site_heights</em>) – A dictionary that contains the adsorbate height for each site
type. Use the default height settings if the height for a site
type is not specified.</p></li>
<li><p><strong>min_adsorbate_distance</strong> (<em>float</em><em>, </em><em>default 2.</em>) – The radius of the sphere inside which no other adsorbates
should be found.</p></li>
<li><p><strong>adsorption_sites</strong> (<em>acat.adsorption_sites.ClusterAdsorptionSites object</em><em>         or </em><em>acat.adsorption_sites.SlabAdsorptionSites object</em><em>, </em><em>default None</em>) – Provide the built-in adsorption sites class to accelerate the
genetic algorithm. Make sure all the operators used with this
operator preserve the indexing of the atoms.</p></li>
<li><p><strong>surface</strong> (<em>str</em><em>, </em><em>default None</em>) – The surface type (crystal structure + Miller indices).
Only required if the structure is a periodic surface slab.</p></li>
<li><p><strong>allow_6fold</strong> (<em>bool</em><em>, </em><em>default False</em>) – Whether to allow the adsorption on 6-fold subsurf sites
underneath fcc hollow sites.</p></li>
<li><p><strong>site_preference_from</strong> (<em>str</em><em>, </em><em>defualt None</em>) – The site type that has higher priority to detach adsorbates.</p></li>
<li><p><strong>surface_preference_from</strong> (<em>str</em><em>, </em><em>default None</em>) – The surface type that has higher priority to detach adsorbates.
Please only use this for nanoparticles.</p></li>
<li><p><strong>site_preference_to</strong> (<em>str</em><em>, </em><em>defualt None</em>) – The site type that has higher priority to attach adsorbates.</p></li>
<li><p><strong>surface_preference_to</strong> (<em>str</em><em>, </em><em>default None</em>) – The surface type that has higher priority to attach adsorbates.
Please only use this for nanoparticles.</p></li>
<li><p><strong>tilt_angle</strong> (<em>float</em><em>, </em><em>default 0.</em>) – Tilt the adsorbate with an angle (in degress) relative to the
surface normal.</p></li>
<li><p><strong>num_muts</strong> (<em>int</em><em>, </em><em>default 1</em>) – The number of times to perform this operation.</p></li>
<li><p><strong>dmax</strong> (<em>float</em><em>, </em><em>default 2.5</em>) – The maximum bond length (in Angstrom) between the site and the
bonding atom  that should be considered as an adsorbate.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.adsorbate_operators.MoveAdsorbate.get_new_individual">
<code class="sig-name descname">get_new_individual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parents</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#MoveAdsorbate.get_new_individual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.MoveAdsorbate.get_new_individual" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns a new individual.
Overwrite in subclass.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.adsorbate_operators.ReplaceAdsorbate">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.adsorbate_operators.</code><code class="sig-name descname">ReplaceAdsorbate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">adsorbate_species</span></em>, <em class="sig-param"><span class="n">heights</span><span class="o">=</span><span class="default_value">{'3fold': 1.3, '4fold': 1.3, '5fold': 1.5, '6fold': 0.0, 'bridge': 1.5, 'fcc': 1.3, 'hcp': 1.3, 'longbridge': 1.5, 'ontop': 1.8, 'shortbridge': 1.5}</span></em>, <em class="sig-param"><span class="n">min_adsorbate_distance</span><span class="o">=</span><span class="default_value">2.0</span></em>, <em class="sig-param"><span class="n">adsorption_sites</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">surface</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allow_6fold</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">site_preference_from</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">surface_preference_from</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tilt_angle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_muts</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">dmax</span><span class="o">=</span><span class="default_value">2.5</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#ReplaceAdsorbate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.ReplaceAdsorbate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#acat.ga.adsorbate_operators.AdsorbateOperator" title="acat.ga.adsorbate_operators.AdsorbateOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">acat.ga.adsorbate_operators.AdsorbateOperator</span></code></a></p>
<p>This operator removes an adsorbate from the surface and adds another
species to the same site, i.e. effectively replacing the adsorbate.</p>
<p>The operator is generalized for both periodic and non-periodic systems
(distinguished by atoms.pbc).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adsorbate_species</strong> (<em>str</em><em> or </em><em>list of strs</em>) – One or a list of adsorbate species to be added to the surface.</p></li>
<li><p><strong>heights</strong> (<em>dict</em><em>, </em><em>default acat.settings.site_heights</em>) – A dictionary that contains the adsorbate height for each site
type. Use the default height settings if the height for a site
type is not specified.</p></li>
<li><p><strong>min_adsorbate_distance</strong> (<em>float</em><em>, </em><em>default 2.</em>) – The radius of the sphere inside which no other adsorbates
should be found.</p></li>
<li><p><strong>adsorption_sites</strong> (<em>acat.adsorption_sites.ClusterAdsorptionSites object</em><em>         or </em><em>acat.adsorption_sites.SlabAdsorptionSites object</em><em>, </em><em>default None</em>) – Provide the built-in adsorption sites class to accelerate the
genetic algorithm. Make sure all the operators used with this
operator preserve the indexing of the atoms.</p></li>
<li><p><strong>surface</strong> (<em>str</em><em>, </em><em>default None</em>) – The surface type (crystal structure + Miller indices).
Only required if the structure is a periodic surface slab.</p></li>
<li><p><strong>allow_6fold</strong> (<em>bool</em><em>, </em><em>default False</em>) – Whether to allow the adsorption on 6-fold subsurf sites
underneath fcc hollow sites.</p></li>
<li><p><strong>site_preference_from</strong> (<em>str</em><em>, </em><em>defualt None</em>) – The site type that has higher priority to replace adsorbates.</p></li>
<li><p><strong>surface_preference_from</strong> (<em>str</em><em>, </em><em>default None</em>) – The surface type that has higher priority to replace adsorbates.
Please only use this for nanoparticles.</p></li>
<li><p><strong>tilt_angle</strong> (<em>float</em><em>, </em><em>default 0.</em>) – Tilt the adsorbate with an angle (in degress) relative to the
surface normal.</p></li>
<li><p><strong>num_muts</strong> (<em>int</em><em>, </em><em>default 1</em>) – The number of times to perform this operation.</p></li>
<li><p><strong>dmax</strong> (<em>float</em><em>, </em><em>default 2.5</em>) – The maximum bond length (in Angstrom) between the site and the
bonding atom  that should be considered as an adsorbate.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.adsorbate_operators.ReplaceAdsorbate.get_new_individual">
<code class="sig-name descname">get_new_individual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parents</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#ReplaceAdsorbate.get_new_individual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.ReplaceAdsorbate.get_new_individual" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns a new individual.
Overwrite in subclass.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.adsorbate_operators.CutSpliceCrossoverWithAdsorbates">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.adsorbate_operators.</code><code class="sig-name descname">CutSpliceCrossoverWithAdsorbates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">adsorbate_species</span></em>, <em class="sig-param"><span class="n">blmin</span></em>, <em class="sig-param"><span class="n">heights</span><span class="o">=</span><span class="default_value">{'3fold': 1.3, '4fold': 1.3, '5fold': 1.5, '6fold': 0.0, 'bridge': 1.5, 'fcc': 1.3, 'hcp': 1.3, 'longbridge': 1.5, 'ontop': 1.8, 'shortbridge': 1.5}</span></em>, <em class="sig-param"><span class="n">keep_composition</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">fix_coverage</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">min_adsorbate_distance</span><span class="o">=</span><span class="default_value">2.0</span></em>, <em class="sig-param"><span class="n">allow_6fold</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">rotate_vectors</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rotate_angles</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dmax</span><span class="o">=</span><span class="default_value">2.5</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#CutSpliceCrossoverWithAdsorbates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.CutSpliceCrossoverWithAdsorbates" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#acat.ga.adsorbate_operators.AdsorbateOperator" title="acat.ga.adsorbate_operators.AdsorbateOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">acat.ga.adsorbate_operators.AdsorbateOperator</span></code></a></p>
<p>Crossover that cuts two particles with adsorbates through a plane
in space and merges two halfes from different particles together
(only returns one of them). The indexing of the atoms is not
preserved. Please only use this operator if the particle is allowed
to change shape.</p>
<p>It keeps the correct composition by randomly assigning elements in
the new particle. If some of the atoms in the two particle halves
are too close, the halves are moved away from each other perpendicular
to the cutting plane.</p>
<p>The complexity of crossover with adsorbates makes this operator not
robust enough. The adsorption site identification will fail once the
nanoparticle shape becomes too irregular after crossover.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adsorbate_species</strong> (<em>str</em><em> or </em><em>list of strs</em>) – One or a list of adsorbate species to be added to the surface.</p></li>
<li><p><strong>blmin</strong> (<em>dict</em>) – Dictionary of minimum distance between atomic numbers.
e.g. {(28,29): 1.5}</p></li>
<li><p><strong>heights</strong> (<em>dict</em><em>, </em><em>default acat.settings.site_heights</em>) – A dictionary that contains the adsorbate height for each site
type. Use the default height settings if the height for a site
type is not specified.</p></li>
<li><p><strong>keep_composition</strong> (<em>bool</em><em>, </em><em>default True</em>) – Should the composition be the same as in the parents.</p></li>
<li><p><strong>fix_coverage</strong> (<em>bool</em><em>, </em><em>default False</em>) – Should the adsorbate coverage be the same as in the parents.</p></li>
<li><p><strong>min_adsorbate_distance</strong> (<em>float</em><em>, </em><em>default 2.</em>) – The radius of the sphere inside which no other adsorbates
should be found.</p></li>
<li><p><strong>allow_6fold</strong> (<em>bool</em><em>, </em><em>default False</em>) – Whether to allow the adsorption on 6-fold subsurf sites
underneath fcc hollow sites.</p></li>
<li><p><strong>rotate_vectors</strong> (<em>list</em><em>, </em><em>default None</em>) – A list of vectors that the part of the structure that is cut
is able to rotate around, the size of rotation is set in
rotate_angles. Default None meaning no rotation is performed.</p></li>
<li><p><strong>rotate_angles</strong> (<em>list</em><em>, </em><em>default None</em>) – A list of angles that the structure cut can be rotated. The
vector being rotated around is set in rotate_vectors. Default
None meaning no rotation is performed.</p></li>
<li><p><strong>dmax</strong> (<em>float</em><em>, </em><em>default 2.5</em>) – The maximum bond length (in Angstrom) between the site and the
bonding atom  that should be considered as an adsorbate.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.adsorbate_operators.CutSpliceCrossoverWithAdsorbates.get_new_individual">
<code class="sig-name descname">get_new_individual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parents</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#CutSpliceCrossoverWithAdsorbates.get_new_individual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.CutSpliceCrossoverWithAdsorbates.get_new_individual" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns a new individual.
Overwrite in subclass.</p>
</dd></dl>

<dl class="py method">
<dt id="acat.ga.adsorbate_operators.CutSpliceCrossoverWithAdsorbates.get_vectors_below_min_dist">
<code class="sig-name descname">get_vectors_below_min_dist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atoms</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#CutSpliceCrossoverWithAdsorbates.get_vectors_below_min_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.CutSpliceCrossoverWithAdsorbates.get_vectors_below_min_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator function that returns each vector (between atoms)
that is shorter than the minimum distance for those atom types
(set during the initialization in blmin).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.adsorbate_operators.SimpleCutSpliceCrossoverWithAdsorbates">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.adsorbate_operators.</code><code class="sig-name descname">SimpleCutSpliceCrossoverWithAdsorbates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">adsorbate_species</span></em>, <em class="sig-param"><span class="n">heights</span><span class="o">=</span><span class="default_value">{'3fold': 1.3, '4fold': 1.3, '5fold': 1.5, '6fold': 0.0, 'bridge': 1.5, 'fcc': 1.3, 'hcp': 1.3, 'longbridge': 1.5, 'ontop': 1.8, 'shortbridge': 1.5}</span></em>, <em class="sig-param"><span class="n">keep_composition</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">fix_coverage</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">min_adsorbate_distance</span><span class="o">=</span><span class="default_value">2.0</span></em>, <em class="sig-param"><span class="n">adsorption_sites</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allow_6fold</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">dmax</span><span class="o">=</span><span class="default_value">2.5</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#SimpleCutSpliceCrossoverWithAdsorbates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.SimpleCutSpliceCrossoverWithAdsorbates" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#acat.ga.adsorbate_operators.AdsorbateOperator" title="acat.ga.adsorbate_operators.AdsorbateOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">acat.ga.adsorbate_operators.AdsorbateOperator</span></code></a></p>
<p>Crossover that divides two particles through a plane in space and
merges the symbols of two halves from different particles with
adosrbates together (only returns one of them). The indexing of the
atoms is preserved. Please only use this operator with other operators
that also preserves the indexing.</p>
<p>It keeps the correct composition by randomly assigning elements in
the new particle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adsorbate_species</strong> (<em>str</em><em> or </em><em>list of strs</em>) – One or a list of adsorbate species to be added to the surface.</p></li>
<li><p><strong>heights</strong> (<em>dict</em><em>, </em><em>default acat.settings.site_heights</em>) – A dictionary that contains the adsorbate height for each site
type. Use the default height settings if the height for a site
type is not specified.</p></li>
<li><p><strong>keep_composition</strong> (<em>bool</em><em>, </em><em>default True</em>) – Boolean that signifies if the composition should be the same
as in the parents.</p></li>
<li><p><strong>fix_coverage</strong> (<em>bool</em><em>, </em><em>default False</em>) – Should the adsorbate coverage be the same as in the parents.</p></li>
<li><p><strong>min_adsorbate_distance</strong> (<em>float</em><em>, </em><em>default 2.</em>) – The radius of the sphere inside which no other adsorbates
should be found.</p></li>
<li><p><strong>adsorption_sites</strong> (<em>acat.adsorption_sites.ClusterAdsorptionSites object</em><em>         or </em><em>acat.adsorption_sites.SlabAdsorptionSites object</em><em>, </em><em>default None</em>) – Provide the built-in adsorption sites class to accelerate the
genetic algorithm. Make sure all the operators used with this
operator preserve the indexing of the atoms.</p></li>
<li><p><strong>allow_6fold</strong> (<em>bool</em><em>, </em><em>default False</em>) – Whether to allow the adsorption on 6-fold subsurf sites
underneath fcc hollow sites.</p></li>
<li><p><strong>dmax</strong> (<em>float</em><em>, </em><em>default 2.5</em>) – The maximum bond length (in Angstrom) between the site and the
bonding atom  that should be considered as an adsorbate.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.adsorbate_operators.SimpleCutSpliceCrossoverWithAdsorbates.get_new_individual">
<code class="sig-name descname">get_new_individual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parents</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#SimpleCutSpliceCrossoverWithAdsorbates.get_new_individual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.SimpleCutSpliceCrossoverWithAdsorbates.get_new_individual" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns a new individual.
Overwrite in subclass.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="acat.ga.adsorbate_operators.AdsorbateCatalystCrossover">
<code class="sig-prename descclassname">acat.ga.adsorbate_operators.</code><code class="sig-name descname">AdsorbateCatalystCrossover</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">AdsorbateOperator</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_operators.html#AdsorbateCatalystCrossover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_operators.AdsorbateCatalystCrossover" title="Permalink to this definition">¶</a></dt>
<dd><p>Crossover that divides two particles or two slabs by the adsorbate
-catalyst interfaces and exchange all adsorbates (only returns one of
them). The indexing of the atoms is preserved. Please only use this
operator with other operators that also preserves the indexing.</p>
<p>The composition or the coverage is fixed if it is preserved by all
other operators being used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adsorbate_species</strong> (<em>str</em><em> or </em><em>list of strs</em>) – One or a list of adsorbate species to be added to the surface.</p></li>
<li><p><strong>heights</strong> (<em>dict</em><em>, </em><em>default acat.settings.site_heights</em>) – A dictionary that contains the adsorbate height for each site
type. Use the default height settings if the height for a site
type is not specified.</p></li>
<li><p><strong>adsorption_sites</strong> (<em>acat.adsorption_sites.ClusterAdsorptionSites object</em><em>         or </em><em>acat.adsorption_sites.SlabAdsorptionSites object</em><em>, </em><em>default None</em>) – Provide the built-in adsorption sites class to accelerate the
genetic algorithm. Make sure all the operators used with this
operator preserve the indexing of the atoms.</p></li>
<li><p><strong>surface</strong> (<em>str</em><em>, </em><em>default None</em>) – The surface type (crystal structure + Miller indices).
Only required if the structure is a periodic surface slab.</p></li>
<li><p><strong>allow_6fold</strong> (<em>bool</em><em>, </em><em>default False</em>) – Whether to allow the adsorption on 6-fold subsurf sites
underneath fcc hollow sites.</p></li>
<li><p><strong>dmax</strong> (<em>float</em><em>, </em><em>default 2.5</em>) – The maximum bond length (in Angstrom) between the site and the
bonding atom  that should be considered as an adsorbate.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-acat.ga.adsorbate_comparators"></span><p>Comparator objects relevant to particles with adsorbates.</p>
<dl class="py function">
<dt id="acat.ga.adsorbate_comparators.count_ads">
<code class="sig-prename descclassname">acat.ga.adsorbate_comparators.</code><code class="sig-name descname">count_ads</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atoms</span></em>, <em class="sig-param"><span class="n">adsorbate</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_comparators.html#count_ads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_comparators.count_ads" title="Permalink to this definition">¶</a></dt>
<dd><p>Very naive implementation only taking into account
the symbols. atoms and adsorbate should both be supplied
as Atoms objects.</p>
</dd></dl>

<dl class="py class">
<dt id="acat.ga.adsorbate_comparators.AdsorbateCountComparator">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.adsorbate_comparators.</code><code class="sig-name descname">AdsorbateCountComparator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">adsorbate</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_comparators.html#AdsorbateCountComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_comparators.AdsorbateCountComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Compares the number of adsorbates on the particles and
returns True if the numbers are the same, False otherwise.</p>
<p>Parameters:</p>
<p>adsorbate: list or string
a supplied list of adsorbates or a string if only one adsorbate
is possible</p>
<dl class="py method">
<dt id="acat.ga.adsorbate_comparators.AdsorbateCountComparator.looks_like">
<code class="sig-name descname">looks_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a1</span></em>, <em class="sig-param"><span class="n">a2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_comparators.html#AdsorbateCountComparator.looks_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_comparators.AdsorbateCountComparator.looks_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the actual comparison.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.adsorbate_comparators.AdsorptionSitesComparator">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.adsorbate_comparators.</code><code class="sig-name descname">AdsorptionSitesComparator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">min_diff_adsorption_sites</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_comparators.html#AdsorptionSitesComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_comparators.AdsorptionSitesComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Compares the metal atoms in the adsorption sites and returns True
if less than min_diff_adsorption_sites of the sites with adsorbates
consist of different atoms.</p>
<p>Ex:
a1.info[‘data’][‘adsorbates_site_atoms’] =
[(‘Cu’,’Ni’),(‘Cu’,’Ni’),(‘Ni’),(‘Ni’)]</p>
<p>a2.info[‘data’][‘adsorbates_site_atoms’] =
[(‘Cu’,’Ni’),(‘Ni’,’Ni’, ‘Ni’),(‘Ni’),(‘Ni’)]</p>
<p>will have a difference of 2:
(2*(‘Cu’,’Ni’)-1*(‘Cu’,’Ni’)=1, 1*(‘Ni’,’Ni’,’Ni’)=1, 2*(‘Ni’)-2*(‘Ni’)=0)</p>
<dl class="py method">
<dt id="acat.ga.adsorbate_comparators.AdsorptionSitesComparator.looks_like">
<code class="sig-name descname">looks_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a1</span></em>, <em class="sig-param"><span class="n">a2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_comparators.html#AdsorptionSitesComparator.looks_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_comparators.AdsorptionSitesComparator.looks_like" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.adsorbate_comparators.AdsorptionMetalsComparator">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.adsorbate_comparators.</code><code class="sig-name descname">AdsorptionMetalsComparator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">same_adsorption_number</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_comparators.html#AdsorptionMetalsComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_comparators.AdsorptionMetalsComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Compares the number of adsorbate-metal bonds and returns True if the
number for a1 and a2 differs by less than the supplied parameter
<code class="docutils literal notranslate"><span class="pre">same_adsorption_number</span></code></p>
<p>Ex:
a1.info[‘data’][‘adsorbates_bound_to’] = {‘Cu’:1, ‘Ni’:3}
a2.info[‘data’][‘adsorbates_bound_to’] = {‘Cu’:.5, ‘Ni’:3.5}
will have a difference of .5 in both elements:</p>
<dl class="py method">
<dt id="acat.ga.adsorbate_comparators.AdsorptionMetalsComparator.looks_like">
<code class="sig-name descname">looks_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a1</span></em>, <em class="sig-param"><span class="n">a2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_comparators.html#AdsorptionMetalsComparator.looks_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_comparators.AdsorptionMetalsComparator.looks_like" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.adsorbate_comparators.AdsorptionGraphComparator">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.adsorbate_comparators.</code><code class="sig-name descname">AdsorptionGraphComparator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">adsorption_sites</span></em>, <em class="sig-param"><span class="n">composition_effect</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">subsurf_effect</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">dmax</span><span class="o">=</span><span class="default_value">2.5</span></em>, <em class="sig-param"><span class="n">fragmentation</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_comparators.html#AdsorptionGraphComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_comparators.AdsorptionGraphComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Compares the graph of adsorbate overlayer + surface atoms and
returns True if they are isomorphic with node matches. Before
checking graph isomorphism, a cheap label match is used to reject
graphs that are impossible to be isomorphic.</p>
<p>The graphs can be quite costly to obtain every time a graph is
required (and disk intensive if saved), thus it makes sense to
get the graph along with e.g. the potential energy and save it in
atoms.info[‘data’][‘graph’].</p>
<p>Parameters:</p>
<dl class="simple">
<dt>adsorption_sites<span class="classifier">acat.adsorption_sites.ClusterAdsorptionSites object         or acat.adsorption_sites.SlabAdsorptionSites object</span></dt><dd><p>Provide the acat built-in adsorption sites class to accelerate the
pattern generation. Make sure all the structures have the same
atom indexing.</p>
</dd>
<dt>composition_effect<span class="classifier">bool, default True</span></dt><dd><p>Whether to consider sites with different elemental compositions as
different sites. It is recommended to set composition_effet=False
for monometallics.</p>
</dd>
<dt>subsurf_effect<span class="classifier">bool, default False</span></dt><dd><p>Whether to take subsurface atoms into consideration when checking
uniqueness. Could be important for surfaces like fcc100.</p>
</dd>
<dt>dmax<span class="classifier">float, default 2.5</span></dt><dd><p>The maximum bond length (in Angstrom) between the site and the
bonding atom  that should be considered as an adsorbate.</p>
</dd>
<dt>fragmentation<span class="classifier">bool, default True</span></dt><dd><p>Whether to cut multidentate species into fragments. This ensures
that multidentate species with different orientations are
considered as different overlayer patterns.</p>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.adsorbate_comparators.AdsorptionGraphComparator.looks_like">
<code class="sig-name descname">looks_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a1</span></em>, <em class="sig-param"><span class="n">a2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/adsorbate_comparators.html#AdsorptionGraphComparator.looks_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.adsorbate_comparators.AdsorptionGraphComparator.looks_like" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<p><strong>Example1</strong></p>
<p>All the adsorbate operators and comparators can be easily used with other operators and comparators. <code class="docutils literal notranslate"><span class="pre">AddAdsorbate</span></code>, <code class="docutils literal notranslate"><span class="pre">RemoveAdsorbate</span></code>, <code class="docutils literal notranslate"><span class="pre">MoveAdsorbate</span></code>, <code class="docutils literal notranslate"><span class="pre">ReplaceAdsorbate</span></code> and <code class="docutils literal notranslate"><span class="pre">AdsorbateCatalystCrossover</span></code> operators can be used for both non-periodic nanoparticles and periodic surface slabs. <code class="docutils literal notranslate"><span class="pre">CutSpliceCrossoverWithAdsorbates</span></code> and <code class="docutils literal notranslate"><span class="pre">SimpleCutSpliceCrossoverWithAdsorbates</span></code> operators only work for nanoparticles, and the latter is recommended. To accelerate the GA, provide adsorsption sites and use indexing-preserved operators implemented in ACAT.</p>
<p>As an example we will simultaneously optimize both the adsorbate overlayer pattern and the catalyst chemical ordering of a Ni110Pt37 icosahedral nanoalloy with adsorbate species of H, C, O, OH, CO, CH, CH2 and CH3 using the EMT calculator.</p>
<p>The script for a parallel genetic algorithm looks as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">acat.settings</span> <span class="kn">import</span> <span class="n">adsorbate_elements</span>
<span class="kn">from</span> <span class="nn">acat.adsorption_sites</span> <span class="kn">import</span> <span class="n">ClusterAdsorptionSites</span>
<span class="kn">from</span> <span class="nn">acat.adsorbate_coverage</span> <span class="kn">import</span> <span class="n">ClusterAdsorbateCoverage</span>
<span class="kn">from</span> <span class="nn">acat.build.ordering</span> <span class="kn">import</span> <span class="n">RandomOrderingGenerator</span> <span class="k">as</span> <span class="n">ROG</span>
<span class="kn">from</span> <span class="nn">acat.build.overlayer</span> <span class="kn">import</span> <span class="n">random_coverage_pattern</span>
<span class="kn">from</span> <span class="nn">acat.ga.adsorbate_operators</span> <span class="kn">import</span> <span class="n">AddAdsorbate</span><span class="p">,</span> <span class="n">RemoveAdsorbate</span>
<span class="kn">from</span> <span class="nn">acat.ga.adsorbate_operators</span> <span class="kn">import</span> <span class="n">MoveAdsorbate</span><span class="p">,</span> <span class="n">ReplaceAdsorbate</span>
<span class="kn">from</span> <span class="nn">acat.ga.adsorbate_operators</span> <span class="kn">import</span> <span class="n">SimpleCutSpliceCrossoverWithAdsorbates</span>
<span class="c1"># Import particle_mutations from acat instead of ase to get the indexing-preserved version</span>
<span class="kn">from</span> <span class="nn">acat.ga.particle_mutations</span> <span class="kn">import</span> <span class="n">RandomPermutation</span><span class="p">,</span> <span class="n">COM2surfPermutation</span>
<span class="kn">from</span> <span class="nn">acat.ga.particle_mutations</span> <span class="kn">import</span> <span class="n">Rich2poorPermutation</span><span class="p">,</span> <span class="n">Poor2richPermutation</span>
<span class="kn">from</span> <span class="nn">acat.ga.adsorbate_comparators</span> <span class="kn">import</span> <span class="n">AdsorptionSitesComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.particle_comparator</span> <span class="kn">import</span> <span class="n">NNMatComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.standard_comparators</span> <span class="kn">import</span> <span class="n">SequentialComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.offspring_creator</span> <span class="kn">import</span> <span class="n">OperationSelector</span>
<span class="kn">from</span> <span class="nn">ase.ga.population</span> <span class="kn">import</span> <span class="n">Population</span><span class="p">,</span> <span class="n">RankFitnessPopulation</span>
<span class="kn">from</span> <span class="nn">ase.ga.convergence</span> <span class="kn">import</span> <span class="n">GenerationRepetitionConvergence</span>
<span class="kn">from</span> <span class="nn">ase.ga.utilities</span> <span class="kn">import</span> <span class="n">closest_distances_generator</span><span class="p">,</span> <span class="n">get_nnmat</span>
<span class="kn">from</span> <span class="nn">ase.ga.data</span> <span class="kn">import</span> <span class="n">DataConnection</span><span class="p">,</span> <span class="n">PrepareDB</span>
<span class="kn">from</span> <span class="nn">ase.io</span> <span class="kn">import</span> <span class="n">read</span><span class="p">,</span> <span class="n">write</span>
<span class="kn">from</span> <span class="nn">ase.cluster</span> <span class="kn">import</span> <span class="n">Icosahedron</span>
<span class="kn">from</span> <span class="nn">ase.calculators.emt</span> <span class="kn">import</span> <span class="n">EMT</span>
<span class="kn">from</span> <span class="nn">ase.optimize</span> <span class="kn">import</span> <span class="n">BFGS</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">choices</span><span class="p">,</span> <span class="n">uniform</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Define population</span>
<span class="c1"># Recommend to choose a number that is a multiple of the number of cpu</span>
<span class="n">pop_size</span> <span class="o">=</span> <span class="mi">50</span>

<span class="c1"># Generate 50 icosahedral Ni110Pt37 nanoparticles with random orderings</span>
<span class="n">particle</span> <span class="o">=</span> <span class="n">Icosahedron</span><span class="p">(</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="n">noshells</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">particle</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">vacuum</span><span class="o">=</span><span class="mf">5.</span><span class="p">)</span>
<span class="n">rog</span> <span class="o">=</span> <span class="n">ROG</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">],</span>
          <span class="n">composition</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Ni&#39;</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">},</span>
          <span class="n">trajectory</span><span class="o">=</span><span class="s1">&#39;starting_generation.traj&#39;</span><span class="p">)</span>
<span class="n">rog</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">num_gen</span><span class="o">=</span><span class="n">pop_size</span><span class="p">)</span>

<span class="c1"># Generate random coverage on each nanoparticle</span>
<span class="n">species</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">,</span> <span class="s1">&#39;CO&#39;</span><span class="p">,</span> <span class="s1">&#39;CH&#39;</span><span class="p">,</span> <span class="s1">&#39;CH2&#39;</span><span class="p">,</span> <span class="s1">&#39;CH3&#39;</span><span class="p">]</span>
<span class="n">images</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="s1">&#39;starting_generation.traj&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="n">patterns</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
    <span class="n">dmin</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">)</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">random_coverage_pattern</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">adsorbate_species</span><span class="o">=</span><span class="n">species</span><span class="p">,</span>
                                      <span class="n">min_adsorbate_distance</span><span class="o">=</span><span class="n">dmin</span><span class="p">)</span>
    <span class="n">patterns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

<span class="c1"># Get the adsorption sites. Composition does not matter in GA</span>
<span class="n">sas</span> <span class="o">=</span> <span class="n">ClusterAdsorptionSites</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="n">composition_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Instantiate the db</span>
<span class="n">db_name</span> <span class="o">=</span> <span class="s1">&#39;ridge_Ni110Pt37_ads.db&#39;</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">PrepareDB</span><span class="p">(</span><span class="n">db_name</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">particle</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">)</span>

<span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
    <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add_unrelaxed_candidate</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>

<span class="c1"># Connect to the db</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">DataConnection</span><span class="p">(</span><span class="n">db_name</span><span class="p">)</span>

<span class="c1"># Define operators</span>
<span class="n">soclist</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
           <span class="p">[</span><span class="n">Rich2poorPermutation</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">],</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">Poor2richPermutation</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">],</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">RandomPermutation</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">],</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">AddAdsorbate</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">adsorption_sites</span><span class="o">=</span><span class="n">sas</span><span class="p">,</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">RemoveAdsorbate</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">adsorption_sites</span><span class="o">=</span><span class="n">sas</span><span class="p">,</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">MoveAdsorbate</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">adsorption_sites</span><span class="o">=</span><span class="n">sas</span><span class="p">,</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">ReplaceAdsorbate</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">adsorption_sites</span><span class="o">=</span><span class="n">sas</span><span class="p">,</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">SimpleCutSpliceCrossoverWithAdsorbates</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">keep_composition</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                   <span class="n">adsorption_sites</span><span class="o">=</span><span class="n">sas</span><span class="p">),])</span>
<span class="n">op_selector</span> <span class="o">=</span> <span class="n">OperationSelector</span><span class="p">(</span><span class="o">*</span><span class="n">soclist</span><span class="p">)</span>

<span class="c1"># Define comparators</span>
<span class="n">comp</span> <span class="o">=</span> <span class="n">SequentialComparator</span><span class="p">([</span><span class="n">AdsorptionSitesComparator</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
                             <span class="n">NNMatComparator</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">])],</span>
                            <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">get_ads</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of adsorbate names and corresponding indices.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="s1">&#39;adsorbates&#39;</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]:</span>
        <span class="n">adsorbates</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;adsorbates&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cac</span> <span class="o">=</span> <span class="n">ClusterAdsorbateCoverage</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">adsorbates</span> <span class="o">=</span> <span class="n">cac</span><span class="o">.</span><span class="n">get_adsorbates</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">adsorbates</span>

<span class="k">def</span> <span class="nf">vf</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the descriptor that distinguishes candidates in the</span>
<span class="sd">    niched population.&quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">get_ads</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span>

<span class="c1"># Give fittest candidates at different coverages equal fitness</span>
<span class="n">pop</span> <span class="o">=</span> <span class="n">RankFitnessPopulation</span><span class="p">(</span><span class="n">data_connection</span><span class="o">=</span><span class="n">db</span><span class="p">,</span>
                            <span class="n">population_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span>
                            <span class="n">comparator</span><span class="o">=</span><span class="n">comp</span><span class="p">,</span>
                            <span class="n">variable_function</span><span class="o">=</span><span class="n">vf</span><span class="p">,</span>
                            <span class="n">exp_function</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">logfile</span><span class="o">=</span><span class="s1">&#39;log.txt&#39;</span><span class="p">)</span>

<span class="c1"># Normal fitness ranking regardless of coverage</span>
<span class="c1">#pop = Population(data_connection=db,</span>
<span class="c1">#                 population_size=pop_size,</span>
<span class="c1">#                 comparator=comp,</span>
<span class="c1">#                 logfile=&#39;log.txt&#39;)</span>

<span class="c1"># Set convergence criteria</span>
<span class="n">cc</span> <span class="o">=</span> <span class="n">GenerationRepetitionConvergence</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1"># Calculate chemical potentials</span>
<span class="n">chem_pots</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;CH4&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mf">24.039</span><span class="p">,</span> <span class="s1">&#39;H2O&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mf">14.169</span><span class="p">,</span> <span class="s1">&#39;H2&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mf">6.989</span><span class="p">}</span>

<span class="c1"># Define the relax function</span>
<span class="k">def</span> <span class="nf">relax</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">single_point</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">vacuum</span><span class="o">=</span><span class="mf">5.</span><span class="p">)</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">calc</span> <span class="o">=</span> <span class="n">EMT</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">single_point</span><span class="p">:</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="n">BFGS</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">opt</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fmax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Add delay to avoid stack overflow (only for testing)</span>

    <span class="n">Epot</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_potential_energy</span><span class="p">()</span>
    <span class="n">num_H</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">])</span>
    <span class="n">num_C</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
    <span class="n">num_O</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">])</span>
    <span class="n">mutot</span> <span class="o">=</span> <span class="n">num_C</span> <span class="o">*</span> <span class="n">chem_pots</span><span class="p">[</span><span class="s1">&#39;CH4&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">num_O</span> <span class="o">*</span> <span class="n">chem_pots</span><span class="p">[</span><span class="s1">&#39;H2O&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span>
            <span class="n">num_H</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">num_C</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_O</span><span class="p">)</span> <span class="o">*</span> <span class="n">chem_pots</span><span class="p">[</span><span class="s1">&#39;H2&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Epot</span> <span class="o">-</span> <span class="n">mutot</span>

    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;key_value_pairs&#39;</span><span class="p">][</span><span class="s1">&#39;raw_score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">f</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;key_value_pairs&#39;</span><span class="p">][</span><span class="s1">&#39;potential_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Epot</span>

    <span class="c1"># Parallelize nnmat calculations to accelerate NNMatComparator</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;nnmat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_nnmat</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atoms</span>

<span class="c1"># Relax starting generation</span>
<span class="k">def</span> <span class="nf">relax_an_unrelaxed_candidate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">nncomp</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_chemical_formula</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relaxing &#39;</span> <span class="o">+</span> <span class="n">nncomp</span><span class="p">)</span>
    <span class="n">relax</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">single_point</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Single point only for testing</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add_relaxed_step</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

<span class="c1"># Create a multiprocessing Pool</span>
<span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
<span class="c1"># Perform relaxations in parallel. Especially</span>
<span class="c1"># useful when running GA on large nanoparticles</span>
<span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">relax_an_unrelaxed_candidate</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">get_all_unrelaxed_candidates</span><span class="p">())</span>
<span class="n">pop</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

<span class="c1"># Number of generations</span>
<span class="n">num_gens</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1"># Below is the iterative part of the algorithm</span>
<span class="n">gen_num</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get_generation_number</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_gens</span><span class="p">):</span>
    <span class="c1"># Check if converged</span>
    <span class="k">if</span> <span class="n">cc</span><span class="o">.</span><span class="n">converged</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Converged&#39;</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating and evaluating generation </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gen_num</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">procreation</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="c1"># Select an operator and use it</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">op_selector</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span>
        <span class="c1"># Select parents for a new candidate</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">get_two_candidates</span><span class="p">()</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
        <span class="c1"># Pure or bare nanoparticles are not considered</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">numbers</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">offspring</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">get_new_individual</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="c1"># An operator could return None if an offspring cannot be formed</span>
        <span class="c1"># by the chosen parents</span>
        <span class="k">if</span> <span class="n">offspring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">nncomp</span> <span class="o">=</span> <span class="n">offspring</span><span class="o">.</span><span class="n">get_chemical_formula</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relaxing &#39;</span> <span class="o">+</span> <span class="n">nncomp</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">offspring</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">offspring</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">relax</span><span class="p">(</span><span class="n">offspring</span><span class="p">,</span> <span class="n">single_point</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Single point only for testing</span>
        <span class="n">db</span><span class="o">.</span><span class="n">add_relaxed_candidate</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span>

    <span class="c1"># Create a multiprocessing Pool</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
    <span class="c1"># Perform procreations in parallel. Especially useful when</span>
    <span class="c1"># using adsorbate operators which requires site identification</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">procreation</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">pop_size</span><span class="p">))</span>

    <span class="c1"># update the population to allow new candidates to enter</span>
    <span class="n">pop</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Example2</strong></p>
<p>If we want to study the same system but fix the adsorbate coverage to be exactly 20 adsorbates, we should only use <code class="docutils literal notranslate"><span class="pre">MoveAdsorbate</span></code>, <code class="docutils literal notranslate"><span class="pre">ReplaceAdsorbate</span></code> and <code class="docutils literal notranslate"><span class="pre">SimpleCutSpliceCrossoverWithAdsorbates</span></code> operators with same particle operators. Remember to set fix_coverage to True in <code class="docutils literal notranslate"><span class="pre">SimpleCutSpliceCrossoverWithAdsorbates</span></code>.</p>
<p>The script for a fixed-coverage parallel genetic algorithm now looks as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">acat.settings</span> <span class="kn">import</span> <span class="n">adsorbate_elements</span>
<span class="kn">from</span> <span class="nn">acat.adsorption_sites</span> <span class="kn">import</span> <span class="n">ClusterAdsorptionSites</span>
<span class="kn">from</span> <span class="nn">acat.adsorbate_coverage</span> <span class="kn">import</span> <span class="n">ClusterAdsorbateCoverage</span>
<span class="kn">from</span> <span class="nn">acat.build.ordering</span> <span class="kn">import</span> <span class="n">RandomOrderingGenerator</span> <span class="k">as</span> <span class="n">ROG</span>
<span class="kn">from</span> <span class="nn">acat.build.overlayer</span> <span class="kn">import</span> <span class="n">StochasticPatternGenerator</span> <span class="k">as</span> <span class="n">SPG</span>
<span class="kn">from</span> <span class="nn">acat.ga.adsorbate_operators</span> <span class="kn">import</span> <span class="n">AddAdsorbate</span><span class="p">,</span> <span class="n">RemoveAdsorbate</span>
<span class="kn">from</span> <span class="nn">acat.ga.adsorbate_operators</span> <span class="kn">import</span> <span class="n">MoveAdsorbate</span><span class="p">,</span> <span class="n">ReplaceAdsorbate</span>
<span class="kn">from</span> <span class="nn">acat.ga.adsorbate_operators</span> <span class="kn">import</span> <span class="n">SimpleCutSpliceCrossoverWithAdsorbates</span>
<span class="c1"># Import particle_mutations from acat instead of ase to get the indexing-preserved version</span>
<span class="kn">from</span> <span class="nn">acat.ga.particle_mutations</span> <span class="kn">import</span> <span class="n">RandomPermutation</span><span class="p">,</span> <span class="n">COM2surfPermutation</span>
<span class="kn">from</span> <span class="nn">acat.ga.particle_mutations</span> <span class="kn">import</span> <span class="n">Rich2poorPermutation</span><span class="p">,</span> <span class="n">Poor2richPermutation</span>
<span class="kn">from</span> <span class="nn">acat.ga.adsorbate_comparators</span> <span class="kn">import</span> <span class="n">AdsorptionSitesComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.particle_comparator</span> <span class="kn">import</span> <span class="n">NNMatComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.standard_comparators</span> <span class="kn">import</span> <span class="n">SequentialComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.offspring_creator</span> <span class="kn">import</span> <span class="n">OperationSelector</span>
<span class="kn">from</span> <span class="nn">ase.ga.population</span> <span class="kn">import</span> <span class="n">Population</span><span class="p">,</span> <span class="n">RankFitnessPopulation</span>
<span class="kn">from</span> <span class="nn">ase.ga.convergence</span> <span class="kn">import</span> <span class="n">GenerationRepetitionConvergence</span>
<span class="kn">from</span> <span class="nn">ase.ga.utilities</span> <span class="kn">import</span> <span class="n">closest_distances_generator</span><span class="p">,</span> <span class="n">get_nnmat</span>
<span class="kn">from</span> <span class="nn">ase.ga.data</span> <span class="kn">import</span> <span class="n">DataConnection</span><span class="p">,</span> <span class="n">PrepareDB</span>
<span class="kn">from</span> <span class="nn">ase.io</span> <span class="kn">import</span> <span class="n">read</span><span class="p">,</span> <span class="n">write</span>
<span class="kn">from</span> <span class="nn">ase.cluster</span> <span class="kn">import</span> <span class="n">Icosahedron</span>
<span class="kn">from</span> <span class="nn">ase.calculators.emt</span> <span class="kn">import</span> <span class="n">EMT</span>
<span class="kn">from</span> <span class="nn">ase.optimize</span> <span class="kn">import</span> <span class="n">BFGS</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">choices</span><span class="p">,</span> <span class="n">uniform</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Define population</span>
<span class="c1"># Recommand to choose a number that is a multiple of the number of cpu</span>
<span class="n">pop_size</span> <span class="o">=</span> <span class="mi">50</span>

<span class="c1"># Generate 50 icosahedral Ni110Pt37 nanoparticles with random orderings</span>
<span class="n">particle</span> <span class="o">=</span> <span class="n">Icosahedron</span><span class="p">(</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="n">noshells</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">particle</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">vacuum</span><span class="o">=</span><span class="mf">5.</span><span class="p">)</span>
<span class="n">rog</span> <span class="o">=</span> <span class="n">ROG</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">],</span>
          <span class="n">composition</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Ni&#39;</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">},</span>
          <span class="n">trajectory</span><span class="o">=</span><span class="s1">&#39;starting_generation.traj&#39;</span><span class="p">)</span>
<span class="n">rog</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">num_gen</span><span class="o">=</span><span class="n">pop_size</span><span class="p">)</span>

<span class="c1"># Generate random coverage patterns of 20 adsorbates on nanoparticles</span>
<span class="n">species</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">,</span> <span class="s1">&#39;CO&#39;</span><span class="p">,</span> <span class="s1">&#39;CH&#39;</span><span class="p">,</span> <span class="s1">&#39;CH2&#39;</span><span class="p">,</span> <span class="s1">&#39;CH3&#39;</span><span class="p">]</span>
<span class="n">images</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="s1">&#39;starting_generation.traj&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="n">num_ads</span> <span class="o">=</span> <span class="mi">20</span> <span class="c1"># Number of adsorbates, fix at this coverage throughout GA</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ads</span><span class="p">):</span> <span class="c1"># This will take quite some time</span>
    <span class="n">spg</span> <span class="o">=</span> <span class="n">SPG</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">adsorbate_species</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CO&#39;</span><span class="p">,</span><span class="s1">&#39;OH&#39;</span><span class="p">,</span><span class="s1">&#39;N&#39;</span><span class="p">],</span>
              <span class="n">min_adsorbate_distance</span><span class="o">=</span><span class="mf">3.</span><span class="p">,</span>
              <span class="n">composition_effect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">spg</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">num_gen</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">images</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="s1">&#39;patterns.traj&#39;</span><span class="p">)</span>
<span class="n">patterns</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="s1">&#39;patterns.traj&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>

<span class="c1"># Get the adsorption sites. Composition does not matter in GA</span>
<span class="n">sas</span> <span class="o">=</span> <span class="n">ClusterAdsorptionSites</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="n">composition_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Instantiate the db</span>
<span class="n">db_name</span> <span class="o">=</span> <span class="s1">&#39;ridge_Ni110Pt37_ads.db&#39;</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">PrepareDB</span><span class="p">(</span><span class="n">db_name</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">particle</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">)</span>

<span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
    <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add_unrelaxed_candidate</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>

<span class="c1"># Connect to the db</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">DataConnection</span><span class="p">(</span><span class="n">db_name</span><span class="p">)</span>

<span class="c1"># Define operators</span>
<span class="n">soclist</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
           <span class="p">[</span><span class="n">Rich2poorPermutation</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">],</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">Poor2richPermutation</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">],</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">RandomPermutation</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">],</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">MoveAdsorbate</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">adsorption_sites</span><span class="o">=</span><span class="n">sas</span><span class="p">,</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">ReplaceAdsorbate</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">adsorption_sites</span><span class="o">=</span><span class="n">sas</span><span class="p">,</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span>
            <span class="n">SimpleCutSpliceCrossoverWithAdsorbates</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">keep_composition</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                   <span class="n">fix_coverage</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                   <span class="n">adsorption_sites</span><span class="o">=</span><span class="n">sas</span><span class="p">),])</span>
<span class="n">op_selector</span> <span class="o">=</span> <span class="n">OperationSelector</span><span class="p">(</span><span class="o">*</span><span class="n">soclist</span><span class="p">)</span>

<span class="c1"># Define comparators</span>
<span class="n">comp</span> <span class="o">=</span> <span class="n">SequentialComparator</span><span class="p">([</span><span class="n">AdsorptionSitesComparator</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
                             <span class="n">NNMatComparator</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">])],</span>
                            <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">get_ads</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of adsorbate names and corresponding indices.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="s1">&#39;adsorbates&#39;</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]:</span>
        <span class="n">adsorbates</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;adsorbates&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cac</span> <span class="o">=</span> <span class="n">ClusterAdsorbateCoverage</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">adsorbates</span> <span class="o">=</span> <span class="n">cac</span><span class="o">.</span><span class="n">get_adsorbates</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">adsorbates</span>

<span class="k">def</span> <span class="nf">vf</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the descriptor that distinguishes candidates in the</span>
<span class="sd">    niched population.&quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">get_ads</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span>

<span class="c1"># Give fittest candidates at different coverages equal fitness</span>
<span class="n">pop</span> <span class="o">=</span> <span class="n">RankFitnessPopulation</span><span class="p">(</span><span class="n">data_connection</span><span class="o">=</span><span class="n">db</span><span class="p">,</span>
                            <span class="n">population_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span>
                            <span class="n">comparator</span><span class="o">=</span><span class="n">comp</span><span class="p">,</span>
                            <span class="n">variable_function</span><span class="o">=</span><span class="n">vf</span><span class="p">,</span>
                            <span class="n">exp_function</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">logfile</span><span class="o">=</span><span class="s1">&#39;log.txt&#39;</span><span class="p">)</span>

<span class="c1"># Normal fitness ranking regardless of coverage</span>
<span class="c1">#pop = Population(data_connection=db,</span>
<span class="c1">#                 population_size=pop_size,</span>
<span class="c1">#                 comparator=comp,</span>
<span class="c1">#                 logfile=&#39;log.txt&#39;)</span>

<span class="c1"># Set convergence criteria</span>
<span class="n">cc</span> <span class="o">=</span> <span class="n">GenerationRepetitionConvergence</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1"># Calculate chemical potentials</span>
<span class="n">chem_pots</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;CH4&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mf">24.039</span><span class="p">,</span> <span class="s1">&#39;H2O&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mf">14.169</span><span class="p">,</span> <span class="s1">&#39;H2&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mf">6.989</span><span class="p">}</span>

<span class="c1"># Define the relax function</span>
<span class="k">def</span> <span class="nf">relax</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">single_point</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">vacuum</span><span class="o">=</span><span class="mf">5.</span><span class="p">)</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">calc</span> <span class="o">=</span> <span class="n">EMT</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">single_point</span><span class="p">:</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="n">BFGS</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">opt</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fmax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Add delay to avoid stack overflow (just for testing)</span>

    <span class="n">Epot</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_potential_energy</span><span class="p">()</span>
    <span class="n">num_H</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">])</span>
    <span class="n">num_C</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
    <span class="n">num_O</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">])</span>
    <span class="n">mutot</span> <span class="o">=</span> <span class="n">num_C</span> <span class="o">*</span> <span class="n">chem_pots</span><span class="p">[</span><span class="s1">&#39;CH4&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">num_O</span> <span class="o">*</span> <span class="n">chem_pots</span><span class="p">[</span><span class="s1">&#39;H2O&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span>
            <span class="n">num_H</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">num_C</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_O</span><span class="p">)</span> <span class="o">*</span> <span class="n">chem_pots</span><span class="p">[</span><span class="s1">&#39;H2&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Epot</span> <span class="o">-</span> <span class="n">mutot</span>

    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;key_value_pairs&#39;</span><span class="p">][</span><span class="s1">&#39;raw_score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">f</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;key_value_pairs&#39;</span><span class="p">][</span><span class="s1">&#39;potential_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Epot</span>

    <span class="c1"># Parallelize nnmat calculations to accelerate NNMatComparator</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;nnmat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_nnmat</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atoms</span>

<span class="c1"># Relax starting generation</span>
<span class="k">def</span> <span class="nf">relax_an_unrelaxed_candidate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">nncomp</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_chemical_formula</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relaxing &#39;</span> <span class="o">+</span> <span class="n">nncomp</span><span class="p">)</span>
    <span class="n">relax</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">single_point</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Single point only for testing</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add_relaxed_step</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

<span class="c1"># Create a multiprocessing Pool</span>
<span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
<span class="c1"># Perform relaxations in parallel. Especially</span>
<span class="c1"># useful when running GA on large nanoparticles</span>
<span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">relax_an_unrelaxed_candidate</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">get_all_unrelaxed_candidates</span><span class="p">())</span>
<span class="n">pop</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

<span class="c1"># Number of generations</span>
<span class="n">num_gens</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1"># Below is the iterative part of the algorithm</span>
<span class="n">gen_num</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get_generation_number</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_gens</span><span class="p">):</span>
    <span class="c1"># Check if converged</span>
    <span class="k">if</span> <span class="n">cc</span><span class="o">.</span><span class="n">converged</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Converged&#39;</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating and evaluating generation </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gen_num</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">procreation</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="c1"># Select an operator and use it</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">op_selector</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span>
        <span class="c1"># Select parents for a new candidate</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">get_two_candidates</span><span class="p">()</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
        <span class="c1"># Pure or bare nanoparticles are not considered</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">numbers</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">offspring</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">get_new_individual</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="c1"># An operator could return None if an offspring cannot be formed</span>
        <span class="c1"># by the chosen parents</span>
        <span class="k">if</span> <span class="n">offspring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">nncomp</span> <span class="o">=</span> <span class="n">offspring</span><span class="o">.</span><span class="n">get_chemical_formula</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relaxing &#39;</span> <span class="o">+</span> <span class="n">nncomp</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">offspring</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">offspring</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">relax</span><span class="p">(</span><span class="n">offspring</span><span class="p">,</span> <span class="n">single_point</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Single point only for testing</span>
        <span class="n">db</span><span class="o">.</span><span class="n">add_relaxed_candidate</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span>

    <span class="c1"># Create a multiprocessing Pool</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
    <span class="c1"># Perform procreations in parallel. Especially useful when</span>
    <span class="c1"># using adsorbate operators which requires site identification</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">procreation</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">pop_size</span><span class="p">))</span>

    <span class="c1"># update the population to allow new candidates to enter</span>
    <span class="n">pop</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="module-acat.ga.group_operators">
<span id="symmetry-constrained-genetic-algorithm-for-nanoalloys"></span><h2>Symmetry-constrained genetic algorithm for nanoalloys<a class="headerlink" href="#module-acat.ga.group_operators" title="Permalink to this headline">¶</a></h2>
<p>Procreation operators meant to be used in symmetry-constrained
genetic algorithm (SCGA).</p>
<dl class="py class">
<dt id="acat.ga.group_operators.Mutation">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.group_operators.</code><code class="sig-name descname">Mutation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_muts</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_operators.html#Mutation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_operators.Mutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ase.ga.offspring_creator.OffspringCreator</span></code></p>
<p>Base class for all particle mutation type operators.
Do not call this class directly.</p>
</dd></dl>

<dl class="py class">
<dt id="acat.ga.group_operators.GroupSubstitute">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.group_operators.</code><code class="sig-name descname">GroupSubstitute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">elements</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_muts</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_operators.html#GroupSubstitute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_operators.GroupSubstitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#acat.ga.group_operators.Mutation" title="acat.ga.group_operators.Mutation"><code class="xref py py-class docutils literal notranslate"><span class="pre">acat.ga.group_operators.Mutation</span></code></a></p>
<p>Substitute all the atoms in a group with a different element.
The elemental composition cannot be fixed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>groups</strong> (<em>list of lists</em>) – The atom indices in each user-divided group. Can be obtained
by <cite>acat.build.ordering.SymmetricClusterOrderingGenerator</cite>
or <cite>acat.build.ordering.OrderedSlabOrderingGenerator</cite>.</p></li>
<li><p><strong>elements</strong> (<em>list of strs</em><em>, </em><em>default None</em>) – Only take into account the elements specified in this list.
Default is to take all elements into account.</p></li>
<li><p><strong>num_muts</strong> (<em>int</em><em>, </em><em>default 1</em>) – The number of times to perform this operation.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.group_operators.GroupSubstitute.substitute">
<code class="sig-name descname">substitute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atoms</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_operators.html#GroupSubstitute.substitute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_operators.GroupSubstitute.substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the actual substitution</p>
</dd></dl>

<dl class="py method">
<dt id="acat.ga.group_operators.GroupSubstitute.get_new_individual">
<code class="sig-name descname">get_new_individual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parents</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_operators.html#GroupSubstitute.get_new_individual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_operators.GroupSubstitute.get_new_individual" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns a new individual.
Overwrite in subclass.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.group_operators.GroupPermutation">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.group_operators.</code><code class="sig-name descname">GroupPermutation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">elements</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keep_composition</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">num_muts</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_operators.html#GroupPermutation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_operators.GroupPermutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#acat.ga.group_operators.Mutation" title="acat.ga.group_operators.Mutation"><code class="xref py py-class docutils literal notranslate"><span class="pre">acat.ga.group_operators.Mutation</span></code></a></p>
<p>Permutes the elements in two random groups. The elemental
composition can be fixed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>groups</strong> (<em>list of lists</em>) – The atom indices in each user-divided group. Can be obtained
by <cite>acat.build.ordering.SymmetricClusterOrderingGenerator</cite>
or <cite>acat.build.ordering.OrderedSlabOrderingGenerator</cite>.</p></li>
<li><p><strong>elements</strong> (<em>list of strs</em><em>, </em><em>default None</em>) – Only take into account the elements specified in this list.
Default is to take all elements into account.</p></li>
<li><p><strong>keep_composition</strong> (<em>bool</em><em>, </em><em>defulat False</em>) – Whether the elemental composition should be the same as in
the parents.</p></li>
<li><p><strong>num_muts</strong> (<em>int</em><em>, </em><em>default 1</em>) – The number of times to perform this operation.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.group_operators.GroupPermutation.get_new_individual">
<code class="sig-name descname">get_new_individual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parents</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_operators.html#GroupPermutation.get_new_individual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_operators.GroupPermutation.get_new_individual" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns a new individual.
Overwrite in subclass.</p>
</dd></dl>

<dl class="py method">
<dt id="acat.ga.group_operators.GroupPermutation.mutate">
<em class="property">classmethod </em><code class="sig-name descname">mutate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atoms</span></em>, <em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">elements</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keep_composition</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_operators.html#GroupPermutation.mutate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_operators.GroupPermutation.mutate" title="Permalink to this definition">¶</a></dt>
<dd><p>Do the actual permutation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.group_operators.Crossover">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.group_operators.</code><code class="sig-name descname">Crossover</code><a class="reference internal" href="_modules/acat/ga/group_operators.html#Crossover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_operators.Crossover" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ase.ga.offspring_creator.OffspringCreator</span></code></p>
<p>Base class for all particle crossovers.
Do not call this class directly.</p>
</dd></dl>

<dl class="py class">
<dt id="acat.ga.group_operators.GroupCrossover">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.group_operators.</code><code class="sig-name descname">GroupCrossover</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">elements</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keep_composition</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_operators.html#GroupCrossover"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_operators.GroupCrossover" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#acat.ga.group_operators.Crossover" title="acat.ga.group_operators.Crossover"><code class="xref py py-class docutils literal notranslate"><span class="pre">acat.ga.group_operators.Crossover</span></code></a></p>
<p>Merge the elemental distributions in two half groups from
different structures together. The elemental composition can be
fixed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>groups</strong> (<em>list of lists</em>) – The atom indices in each user-divided group. Can be obtained
by <cite>acat.build.ordering.SymmetricClusterOrderingGenerator</cite>
or <cite>acat.build.ordering.OrderedSlabOrderingGenerator</cite>.</p></li>
<li><p><strong>elements</strong> (<em>list of strs</em><em>, </em><em>default None</em>) – Only take into account the elements specified in this list.
Default is to take all elements into account.</p></li>
<li><p><strong>keep_composition</strong> (<em>bool</em><em>, </em><em>defulat False</em>) – Whether the elemental composition should be the same as in
the parents.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.group_operators.GroupCrossover.get_new_individual">
<code class="sig-name descname">get_new_individual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parents</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_operators.html#GroupCrossover.get_new_individual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_operators.GroupCrossover.get_new_individual" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns a new individual.
Overwrite in subclass.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-acat.ga.group_comparators"></span><p>Comparators meant to be used in symmetry-constrained genetic
algorithm (SCGA).</p>
<dl class="py class">
<dt id="acat.ga.group_comparators.GroupSizeComparator">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.group_comparators.</code><code class="sig-name descname">GroupSizeComparator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">elements</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_comparators.html#GroupSizeComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_comparators.GroupSizeComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>For each given element, compares the sorted sizes of the
user-divided groups that have the given element. Returns True
if the sizes are the same, False otherwise. Self-symmetry is
considered for particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>groups</strong> (<em>list of lists</em>) – The atom indices in each user-divided group. Can be obtained
by <cite>acat.build.ordering.SymmetricClusterOrderingGenerator</cite>
or <cite>acat.build.ordering.OrderedSlabOrderingGenerator</cite>.</p></li>
<li><p><strong>elements</strong> (<em>list of strs</em><em>, </em><em>default None</em>) – Only take into account the elements specified in this list.
Default is to take all elements into account.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.group_comparators.GroupSizeComparator.looks_like">
<code class="sig-name descname">looks_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a1</span></em>, <em class="sig-param"><span class="n">a2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_comparators.html#GroupSizeComparator.looks_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_comparators.GroupSizeComparator.looks_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if structure a1 or a2 are similar or not.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="acat.ga.group_comparators.GroupCompositionComparator">
<em class="property">class </em><code class="sig-prename descclassname">acat.ga.group_comparators.</code><code class="sig-name descname">GroupCompositionComparator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">elements</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_comparators.html#GroupCompositionComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_comparators.GroupCompositionComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Compares the elemental compositions of all user-divided groups.
Returns True if the numbers are the same, False otherwise.
Self-symmetry is not considered for particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>groups</strong> (<em>list of lists</em>) – The atom indices in each user-divided group. Can be obtained
by <cite>acat.build.ordering.SymmetricClusterOrderingGenerator</cite>
or <cite>acat.build.ordering.OrderedSlabOrderingGenerator</cite>.</p></li>
<li><p><strong>elements</strong> (<em>list of strs</em><em>, </em><em>default None</em>) – Only take into account the elements specified in this list.
Default is to take all elements into account.</p></li>
<li><p><strong>tol</strong> (<em>int</em><em>, </em><em>default 0</em>) – The maximum number of groups with different elements that two
structures are still considered to be look alike.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="acat.ga.group_comparators.GroupCompositionComparator.looks_like">
<code class="sig-name descname">looks_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a1</span></em>, <em class="sig-param"><span class="n">a2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/acat/ga/group_comparators.html#GroupCompositionComparator.looks_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#acat.ga.group_comparators.GroupCompositionComparator.looks_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if structure a1 or a2 are similar or not.</p>
</dd></dl>

</dd></dl>

<p><strong>Example1</strong></p>
<p>All the group operators and comparators can be easily used with other indexing-preserved operators and comparators. All operators can be used for both non-periodic nanoparticles and periodic surface slabs.</p>
<p>As an example we will find the convex hull of ternary NixPtyAu405-x-y truncated octahedral nanoalloys using the ASAP EMT calculator. <strong>Note that we must first align the symmetry axis of interest to the z direction.</strong> Here we want to study the 3-fold mirror circular symmetry around the C3 axis of the particle.</p>
<p>The script for a parallel symmetry-constrained genetic algorithm (SCGA) looks as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">acat.build.ordering</span> <span class="kn">import</span> <span class="n">SymmetricClusterOrderingGenerator</span> <span class="k">as</span> <span class="n">SCOG</span>
<span class="kn">from</span> <span class="nn">acat.ga.group_operators</span> <span class="kn">import</span> <span class="n">GroupSubstitute</span>
<span class="kn">from</span> <span class="nn">acat.ga.group_operators</span> <span class="kn">import</span> <span class="n">GroupPermutation</span>
<span class="kn">from</span> <span class="nn">acat.ga.group_operators</span> <span class="kn">import</span> <span class="n">GroupCrossover</span>
<span class="kn">from</span> <span class="nn">acat.ga.group_comparators</span> <span class="kn">import</span> <span class="n">GroupSizeComparator</span>
<span class="kn">from</span> <span class="nn">acat.ga.group_comparators</span> <span class="kn">import</span> <span class="n">GroupCompositionComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.particle_comparator</span> <span class="kn">import</span> <span class="n">NNMatComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.standard_comparators</span> <span class="kn">import</span> <span class="n">SequentialComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.offspring_creator</span> <span class="kn">import</span> <span class="n">OperationSelector</span>
<span class="kn">from</span> <span class="nn">ase.ga.population</span> <span class="kn">import</span> <span class="n">Population</span><span class="p">,</span> <span class="n">RankFitnessPopulation</span>
<span class="kn">from</span> <span class="nn">ase.ga.convergence</span> <span class="kn">import</span> <span class="n">GenerationRepetitionConvergence</span>
<span class="kn">from</span> <span class="nn">ase.ga.data</span> <span class="kn">import</span> <span class="n">DataConnection</span><span class="p">,</span> <span class="n">PrepareDB</span>
<span class="kn">from</span> <span class="nn">ase.ga.utilities</span> <span class="kn">import</span> <span class="n">get_nnmat</span>
<span class="kn">from</span> <span class="nn">ase.io</span> <span class="kn">import</span> <span class="n">read</span><span class="p">,</span> <span class="n">write</span>
<span class="kn">from</span> <span class="nn">ase.cluster</span> <span class="kn">import</span> <span class="n">Octahedron</span>
<span class="kn">from</span> <span class="nn">ase.optimize</span> <span class="kn">import</span> <span class="n">BFGS</span>
<span class="kn">from</span> <span class="nn">asap3</span> <span class="kn">import</span> <span class="n">EMT</span> <span class="k">as</span> <span class="n">asapEMT</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Define population.</span>
<span class="c1"># Recommend to choose a number that is a multiple of the number of cpu</span>
<span class="n">pop_size</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># Build and rotate the particle so that C3 axis is aligned to z direction</span>
<span class="n">particle</span> <span class="o">=</span> <span class="n">Octahedron</span><span class="p">(</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">particle</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">particle</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="mf">35.29</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">particle</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">vacuum</span><span class="o">=</span><span class="mf">5.</span><span class="p">)</span>

<span class="c1"># Generate 100 truncated ocatahedral NixPtyAu405-x-y nanoalloys with</span>
<span class="c1"># mirror circular symmetry. Get the groups at the same time.</span>
<span class="n">scog</span> <span class="o">=</span> <span class="n">SCOG</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">],</span>
            <span class="n">symmetry</span><span class="o">=</span><span class="s1">&#39;mirror_circular&#39;</span><span class="p">,</span>
            <span class="n">trajectory</span><span class="o">=</span><span class="s1">&#39;starting_generation.traj&#39;</span><span class="p">)</span>
<span class="n">scog</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">max_gen</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;stochastic&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">scog</span><span class="o">.</span><span class="n">get_groups</span><span class="p">()</span>
<span class="n">images</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="s1">&#39;starting_generation.traj&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>

<span class="c1"># Instantiate the db</span>
<span class="n">db_name</span> <span class="o">=</span> <span class="s1">&#39;ridge_mirror_circular_NiPtAu_TO405_C3.db&#39;</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">PrepareDB</span><span class="p">(</span><span class="n">db_name</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">particle</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">)</span>

<span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
    <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add_unrelaxed_candidate</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>

<span class="c1"># Connect to the db</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">DataConnection</span><span class="p">(</span><span class="n">db_name</span><span class="p">)</span>

<span class="c1"># Define operators</span>
<span class="n">soclist</span> <span class="o">=</span> <span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
           <span class="p">[</span><span class="n">GroupSubstitute</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">],</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
            <span class="n">GroupPermutation</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">],</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">GroupCrossover</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">]),])</span>
<span class="n">op_selector</span> <span class="o">=</span> <span class="n">OperationSelector</span><span class="p">(</span><span class="o">*</span><span class="n">soclist</span><span class="p">)</span>

<span class="c1"># Define comparators</span>
<span class="n">comp</span> <span class="o">=</span> <span class="n">SequentialComparator</span><span class="p">([</span><span class="n">GroupSizeComparator</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">]),</span>
                             <span class="n">NNMatComparator</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">])],</span>
                            <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">vf</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the descriptor that distinguishes candidates in the</span>
<span class="sd">    niched population.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_chemical_formula</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">)</span>

<span class="c1"># Give fittest candidates at different compositions equal fitness.</span>
<span class="c1"># Use this to find global minima at each composition</span>
<span class="n">pop</span> <span class="o">=</span> <span class="n">RankFitnessPopulation</span><span class="p">(</span><span class="n">data_connection</span><span class="o">=</span><span class="n">db</span><span class="p">,</span>
                            <span class="n">population_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span>
                            <span class="n">comparator</span><span class="o">=</span><span class="n">comp</span><span class="p">,</span>
                            <span class="n">variable_function</span><span class="o">=</span><span class="n">vf</span><span class="p">,</span>
                            <span class="n">exp_function</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">logfile</span><span class="o">=</span><span class="s1">&#39;log.txt&#39;</span><span class="p">)</span>

<span class="c1"># Normal fitness ranking irrespective of coverage.</span>
<span class="c1"># Use this to find global minimum irrespective of composition</span>
<span class="c1">#pop = Population(data_connection=db,</span>
<span class="c1">#                 population_size=pop_size,</span>
<span class="c1">#                 comparator=comp,</span>
<span class="c1">#                 logfile=&#39;log.txt&#39;)</span>

<span class="c1"># Set convergence criteria</span>
<span class="n">cc</span> <span class="o">=</span> <span class="n">GenerationRepetitionConvergence</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1"># Calculate the relaxed energies for pure Ni405, Pt405 and Au405</span>
<span class="n">pure_pots</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Ni&#39;</span><span class="p">:</span> <span class="mf">147.532</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">:</span>  <span class="mf">86.892</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">:</span> <span class="mf">63.566</span><span class="p">}</span>

<span class="c1"># Define the relax function</span>
<span class="k">def</span> <span class="nf">relax</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">single_point</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">vacuum</span><span class="o">=</span><span class="mf">5.</span><span class="p">)</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">calc</span> <span class="o">=</span> <span class="n">asapEMT</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">single_point</span><span class="p">:</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="n">BFGS</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">opt</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fmax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">Epot</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_potential_energy</span><span class="p">()</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;key_value_pairs&#39;</span><span class="p">][</span><span class="s1">&#39;potential_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Epot</span>

    <span class="c1"># There is a known issue of asapEMT in GA. You can either detach</span>
    <span class="c1"># the calculator or re-assign to a SinglePointCalculator</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">calc</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Calculate mixing energy</span>
    <span class="n">syms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">syms</span><span class="p">):</span>
        <span class="n">Epot</span> <span class="o">-=</span> <span class="p">(</span><span class="n">pure_pots</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span> <span class="o">*</span> <span class="n">syms</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;key_value_pairs&#39;</span><span class="p">][</span><span class="s1">&#39;raw_score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Epot</span>

    <span class="c1"># Parallelize nnmat calculations to accelerate NNMatComparator</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;nnmat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_nnmat</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atoms</span>

<span class="c1"># Relax starting generation</span>
<span class="k">def</span> <span class="nf">relax_an_unrelaxed_candidate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">nncomp</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_chemical_formula</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relaxing &#39;</span> <span class="o">+</span> <span class="n">nncomp</span><span class="p">)</span>
    <span class="n">relax</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add_relaxed_step</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

<span class="c1"># Create a multiprocessing Pool</span>
<span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
<span class="c1"># Perform relaxations in parallel. Especially</span>
<span class="c1"># useful when running GA on large nanoparticles</span>
<span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">relax_an_unrelaxed_candidate</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">get_all_unrelaxed_candidates</span><span class="p">())</span>
<span class="n">pop</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

<span class="c1"># Number of generations</span>
<span class="n">num_gens</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1"># Below is the iterative part of the algorithm</span>
<span class="n">gen_num</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get_generation_number</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_gens</span><span class="p">):</span>
    <span class="c1"># Check if converged</span>
    <span class="k">if</span> <span class="n">cc</span><span class="o">.</span><span class="n">converged</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Converged&#39;</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating and evaluating generation </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gen_num</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>

    <span class="c1"># Performing procreations in parallel</span>
    <span class="k">def</span> <span class="nf">procreation</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="c1"># Select an operator and use it</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">op_selector</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span>
        <span class="c1"># Select parents for a new candidate</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">get_two_candidates</span><span class="p">()</span>
        <span class="c1"># Pure and binary candidates are not considered</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">numbers</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
        <span class="n">offspring</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">get_new_individual</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="c1"># An operator could return None if an offspring cannot be formed</span>
        <span class="c1"># by the chosen parents</span>
        <span class="k">if</span> <span class="n">offspring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">nncomp</span> <span class="o">=</span> <span class="n">offspring</span><span class="o">.</span><span class="n">get_chemical_formula</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relaxing &#39;</span> <span class="o">+</span> <span class="n">nncomp</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">offspring</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">offspring</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">relax</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span>
        <span class="n">db</span><span class="o">.</span><span class="n">add_relaxed_candidate</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span>

    <span class="c1"># Create a multiprocessing Pool</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
    <span class="c1"># Perform procreations in parallel. Especially</span>
    <span class="c1"># useful when running GA on large nanoparticles</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">procreation</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">pop_size</span><span class="p">))</span>

    <span class="c1"># update the population to allow new candidates to enter</span>
    <span class="n">pop</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Example2</strong></p>
<p>If we want to study the same system but target 3 compositions: Ni0.5Pt0.25Au0.25, Ni0.25Pt0.5Au0.25 and Ni0.25Pt0.25Au0.5, we should not use <code class="docutils literal notranslate"><span class="pre">GroupSubstitute</span></code> operator and set keep_composition to True in <code class="docutils literal notranslate"><span class="pre">GroupPermutation</span></code> and <code class="docutils literal notranslate"><span class="pre">GroupCrossover</span></code> operators. The tolerance of the intitial compositions can be controlled by the eps parameter in <code class="docutils literal notranslate"><span class="pre">SymmetricClusterOrderingGenerator.run</span></code>.</p>
<p>The script for a fixed-composition parallel genetic algorithm now looks as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">acat.build.ordering</span> <span class="kn">import</span> <span class="n">SymmetricClusterOrderingGenerator</span> <span class="k">as</span> <span class="n">SCOG</span>
<span class="kn">from</span> <span class="nn">acat.ga.group_operators</span> <span class="kn">import</span> <span class="n">GroupSubstitute</span>
<span class="kn">from</span> <span class="nn">acat.ga.group_operators</span> <span class="kn">import</span> <span class="n">GroupPermutation</span>
<span class="kn">from</span> <span class="nn">acat.ga.group_operators</span> <span class="kn">import</span> <span class="n">GroupCrossover</span>
<span class="kn">from</span> <span class="nn">acat.ga.group_comparators</span> <span class="kn">import</span> <span class="n">GroupSizeComparator</span>
<span class="kn">from</span> <span class="nn">acat.ga.group_comparators</span> <span class="kn">import</span> <span class="n">GroupCompositionComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.particle_comparator</span> <span class="kn">import</span> <span class="n">NNMatComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.standard_comparators</span> <span class="kn">import</span> <span class="n">SequentialComparator</span>
<span class="kn">from</span> <span class="nn">ase.ga.offspring_creator</span> <span class="kn">import</span> <span class="n">OperationSelector</span>
<span class="kn">from</span> <span class="nn">ase.ga.population</span> <span class="kn">import</span> <span class="n">Population</span><span class="p">,</span> <span class="n">RankFitnessPopulation</span>
<span class="kn">from</span> <span class="nn">ase.ga.convergence</span> <span class="kn">import</span> <span class="n">GenerationRepetitionConvergence</span>
<span class="kn">from</span> <span class="nn">ase.ga.data</span> <span class="kn">import</span> <span class="n">DataConnection</span><span class="p">,</span> <span class="n">PrepareDB</span>
<span class="kn">from</span> <span class="nn">ase.ga.utilities</span> <span class="kn">import</span> <span class="n">get_nnmat</span>
<span class="kn">from</span> <span class="nn">ase.io</span> <span class="kn">import</span> <span class="n">read</span><span class="p">,</span> <span class="n">write</span>
<span class="kn">from</span> <span class="nn">ase.cluster</span> <span class="kn">import</span> <span class="n">Octahedron</span>
<span class="kn">from</span> <span class="nn">ase.optimize</span> <span class="kn">import</span> <span class="n">BFGS</span>
<span class="kn">from</span> <span class="nn">asap3</span> <span class="kn">import</span> <span class="n">EMT</span> <span class="k">as</span> <span class="n">asapEMT</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Define population.</span>
<span class="c1"># Recommend to choose a number that is a multiple of the number of cpu</span>
<span class="n">pop_size</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># Build and rotate the particle so that C3 axis is aligned to z direction</span>
<span class="n">particle</span> <span class="o">=</span> <span class="n">Octahedron</span><span class="p">(</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">particle</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">particle</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="mf">35.29</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">particle</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">vacuum</span><span class="o">=</span><span class="mf">5.</span><span class="p">)</span>

<span class="c1"># Generate 100 truncated ocatahedral NixPtyAu405-x-y nanoalloys with</span>
<span class="c1"># mirror circular symmetry and concentrations of {x=0.5, y=0.25},</span>
<span class="c1"># {x=0.25, y=0.5} and {x=y=0.25}. The concentrations are allowed to</span>
<span class="c1"># vary by a range of 2*eps=0.1. Get the groups at the same time.</span>
<span class="n">scog1</span> <span class="o">=</span> <span class="n">SCOG</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">],</span>
             <span class="n">symmetry</span><span class="o">=</span><span class="s1">&#39;mirror_circular&#39;</span><span class="p">,</span>
             <span class="n">cutoff</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
             <span class="n">secondary_symmetry</span><span class="o">=</span><span class="s1">&#39;chemical&#39;</span><span class="p">,</span>
             <span class="n">secondary_cutoff</span><span class="o">=</span><span class="mf">.1</span><span class="p">,</span>
             <span class="n">composition</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Ni&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">},</span>
             <span class="n">trajectory</span><span class="o">=</span><span class="s1">&#39;starting_generation.traj&#39;</span><span class="p">)</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">scog1</span><span class="o">.</span><span class="n">get_groups</span><span class="p">()</span>
<span class="n">scog1</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">max_gen</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;stochastic&#39;</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">scog2</span> <span class="o">=</span> <span class="n">SCOG</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">],</span>
             <span class="n">symmetry</span><span class="o">=</span><span class="s1">&#39;mirror_circular&#39;</span><span class="p">,</span>
             <span class="n">cutoff</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
             <span class="n">secondary_symmetry</span><span class="o">=</span><span class="s1">&#39;chemical&#39;</span><span class="p">,</span>
             <span class="n">secondary_cutoff</span><span class="o">=</span><span class="mf">.1</span><span class="p">,</span>
             <span class="n">composition</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Ni&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">},</span>
             <span class="n">trajectory</span><span class="o">=</span><span class="s1">&#39;starting_generation.traj&#39;</span><span class="p">,</span>
             <span class="n">append_trajectory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">scog2</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">max_gen</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;stochastic&#39;</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">scog3</span> <span class="o">=</span> <span class="n">SCOG</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">],</span>
             <span class="n">symmetry</span><span class="o">=</span><span class="s1">&#39;mirror_circular&#39;</span><span class="p">,</span>
             <span class="n">cutoff</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
             <span class="n">secondary_symmetry</span><span class="o">=</span><span class="s1">&#39;chemical&#39;</span><span class="p">,</span>
             <span class="n">secondary_cutoff</span><span class="o">=</span><span class="mf">.1</span><span class="p">,</span>
             <span class="n">composition</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Ni&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">},</span>
             <span class="n">trajectory</span><span class="o">=</span><span class="s1">&#39;starting_generation.traj&#39;</span><span class="p">,</span>
             <span class="n">append_trajectory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">scog3</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">max_gen</span><span class="o">=</span><span class="mi">34</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;stochastic&#39;</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">images</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="s1">&#39;starting_generation.traj&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>

<span class="c1"># Instantiate the db</span>
<span class="n">db_name</span> <span class="o">=</span> <span class="s1">&#39;ridge_mirror_circular_NiPtAu_TO405_C3.db&#39;</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">PrepareDB</span><span class="p">(</span><span class="n">db_name</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">particle</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">)</span>

<span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
    <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add_unrelaxed_candidate</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>

<span class="c1"># Connect to the db</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">DataConnection</span><span class="p">(</span><span class="n">db_name</span><span class="p">)</span>

<span class="c1"># Define operators, now set keep_composition=True</span>
<span class="c1"># GroupSubstitute cannot keep the composition so it&#39;s not used</span>
<span class="n">soclist</span> <span class="o">=</span> <span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
           <span class="p">[</span><span class="n">GroupPermutation</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">],</span>
                             <span class="n">keep_composition</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_muts</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">GroupCrossover</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">],</span>
                           <span class="n">keep_composition</span><span class="o">=</span><span class="kc">True</span><span class="p">),])</span>
<span class="n">op_selector</span> <span class="o">=</span> <span class="n">OperationSelector</span><span class="p">(</span><span class="o">*</span><span class="n">soclist</span><span class="p">)</span>

<span class="c1"># Define comparators</span>
<span class="n">comp</span> <span class="o">=</span> <span class="n">SequentialComparator</span><span class="p">([</span><span class="n">GroupSizeComparator</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">]),</span>
                             <span class="n">NNMatComparator</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">])],</span>
                            <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">vf</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the descriptor that distinguishes candidates in the</span>
<span class="sd">    niched population.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_chemical_formula</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">)</span>

<span class="c1"># Give fittest candidates at different compositions equal fitness.</span>
<span class="c1"># Use this to find global minima at each composition</span>
<span class="n">pop</span> <span class="o">=</span> <span class="n">RankFitnessPopulation</span><span class="p">(</span><span class="n">data_connection</span><span class="o">=</span><span class="n">db</span><span class="p">,</span>
                            <span class="n">population_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span>
                            <span class="n">comparator</span><span class="o">=</span><span class="n">comp</span><span class="p">,</span>
                            <span class="n">variable_function</span><span class="o">=</span><span class="n">vf</span><span class="p">,</span>
                            <span class="n">exp_function</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">logfile</span><span class="o">=</span><span class="s1">&#39;log.txt&#39;</span><span class="p">)</span>

<span class="c1"># Normal fitness ranking irrespective of coverage.</span>
<span class="c1"># Use this to find global minimum irrespective of composition</span>
<span class="c1">#pop = Population(data_connection=db,</span>
<span class="c1">#                 population_size=pop_size,</span>
<span class="c1">#                 comparator=comp,</span>
<span class="c1">#                 logfile=&#39;log.txt&#39;)</span>

<span class="c1"># Set convergence criteria</span>
<span class="n">cc</span> <span class="o">=</span> <span class="n">GenerationRepetitionConvergence</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1"># Calculate the relaxed energies for pure Ni405, Pt405 and Au405</span>
<span class="n">pure_pots</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Ni&#39;</span><span class="p">:</span> <span class="mf">147.532</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">:</span>  <span class="mf">86.892</span><span class="p">,</span> <span class="s1">&#39;Au&#39;</span><span class="p">:</span> <span class="mf">63.566</span><span class="p">}</span>

<span class="c1"># Define the relax function</span>
<span class="k">def</span> <span class="nf">relax</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">single_point</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">vacuum</span><span class="o">=</span><span class="mf">5.</span><span class="p">)</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">calc</span> <span class="o">=</span> <span class="n">asapEMT</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">single_point</span><span class="p">:</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="n">BFGS</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">opt</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fmax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">Epot</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_potential_energy</span><span class="p">()</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;key_value_pairs&#39;</span><span class="p">][</span><span class="s1">&#39;potential_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Epot</span>

    <span class="c1"># There is a known issue of asapEMT in GA. You can either detach</span>
    <span class="c1"># the calculator or re-assign to a SinglePointCalculator</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">calc</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Calculate mixing energy</span>
    <span class="n">syms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">syms</span><span class="p">):</span>
        <span class="n">Epot</span> <span class="o">-=</span> <span class="p">(</span><span class="n">pure_pots</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span> <span class="o">*</span> <span class="n">syms</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;key_value_pairs&#39;</span><span class="p">][</span><span class="s1">&#39;raw_score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Epot</span>

    <span class="c1"># Parallelize nnmat calculations to accelerate NNMatComparator</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;nnmat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_nnmat</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atoms</span>

<span class="c1"># Relax starting generation</span>
<span class="k">def</span> <span class="nf">relax_an_unrelaxed_candidate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">nncomp</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_chemical_formula</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relaxing &#39;</span> <span class="o">+</span> <span class="n">nncomp</span><span class="p">)</span>
    <span class="n">relax</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add_relaxed_step</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

<span class="c1"># Create a multiprocessing Pool</span>
<span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
<span class="c1"># Perform relaxations in parallel. Especially</span>
<span class="c1"># useful when running GA on large nanoparticles</span>
<span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">relax_an_unrelaxed_candidate</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">get_all_unrelaxed_candidates</span><span class="p">())</span>
<span class="n">pop</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

<span class="c1"># Number of generations</span>
<span class="n">num_gens</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1"># Below is the iterative part of the algorithm</span>
<span class="n">gen_num</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get_generation_number</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_gens</span><span class="p">):</span>
    <span class="c1"># Check if converged</span>
    <span class="k">if</span> <span class="n">cc</span><span class="o">.</span><span class="n">converged</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Converged&#39;</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating and evaluating generation </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gen_num</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span>

    <span class="c1"># Performing procreations in parallel</span>
    <span class="k">def</span> <span class="nf">procreation</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="c1"># Select an operator and use it</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">op_selector</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span>
        <span class="c1"># Select parents for a new candidate</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">get_two_candidates</span><span class="p">()</span>
        <span class="c1"># Pure and binary candidates are not considered</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">numbers</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">]</span>
        <span class="n">offspring</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">get_new_individual</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="c1"># An operator could return None if an offspring cannot be formed</span>
        <span class="c1"># by the chosen parents</span>
        <span class="k">if</span> <span class="n">offspring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">nncomp</span> <span class="o">=</span> <span class="n">offspring</span><span class="o">.</span><span class="n">get_chemical_formula</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relaxing &#39;</span> <span class="o">+</span> <span class="n">nncomp</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">offspring</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">offspring</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">relax</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span>
        <span class="n">db</span><span class="o">.</span><span class="n">add_relaxed_candidate</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span>

    <span class="c1"># Create a multiprocessing Pool</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
    <span class="c1"># Perform procreations in parallel. Especially</span>
    <span class="c1"># useful when running GA on large nanoparticles</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">procreation</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">pop_size</span><span class="p">))</span>

    <span class="c1"># update the population to allow new candidates to enter</span>
    <span class="n">pop</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="utilities.html" class="btn btn-neutral float-right" title="Other utilities" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="build.html" class="btn btn-neutral float-left" title="Building things" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Shuang Han.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>