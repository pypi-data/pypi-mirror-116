__all__ = [
    'AssignmentsObserver',
    'BaseObserver',
    'PoolStatusObserver',
]
from datetime import timedelta
from toloka.client import TolokaClient
from toloka.client.pool import Pool
from toloka.streaming.event import AssignmentEvent
from typing import (
    Awaitable,
    Callable,
    Dict,
    List,
    Optional,
    TypeVar,
    Union
)


class BaseObserver:
    def __init__(self) -> None:
        """Method generated by attrs for class BaseObserver.
        """
        ...

    def run(self, period: timedelta = ...) -> None:
        """For standalone usage (out of a Pipeline).
        """
        ...

    def should_resume(self) -> bool: ...


class AssignmentsObserver(BasePoolObserver):
    """Observer for the pool's assignment events.
    For usage with Pipeline.

    Attributes:
        toloka_client: TolokaClient instance or async wrapper around it.
        pool_id: Pool ID.

    Allow to register callbacks using the following methods:
        * on_created
        * on_submitted
        * on_accepted
        * on_rejected
        * on_skipped
        * on_expired

    Corresponding assignment events will be passed to the triggered callbacks.

    Examples:
        Send submitted assignments for verification.

        >>> def handle_submitted(evets: List[AssignmentEvent]) -> None:
        >>>     verification_tasks = [create_veridication_task(item.assignment) for item in evets]
        >>>     toloka_client.create_tasks(verification_tasks, open_pool=True)
        >>>
        >>> observer = AssignmentsObserver(toloka_client, pool_id='123')
        >>> observer.on_submitted(handle_submitted)
        ...
    """

    def __init__(
        self,
        toloka_client: TypeVar('T', bound=None),
        pool_id: str
    ) -> None:
        """Method generated by attrs for class AssignmentsObserver.
        """
        ...

    def on_accepted(self, callback: Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]) -> Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]: ...

    def on_any_event(self, callback: Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]) -> Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]: ...

    def on_created(self, callback: Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]) -> Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]: ...

    def on_expired(self, callback: Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]) -> Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]: ...

    def on_rejected(self, callback: Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]) -> Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]: ...

    def on_skipped(self, callback: Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]) -> Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]: ...

    def on_submitted(self, callback: Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]) -> Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]: ...

    def register_callback(
        self,
        callback: Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]],
        event_type: Union[AssignmentEvent.Type, str]
    ) -> Union[Callable[List[AssignmentEvent], None], Callable[List[AssignmentEvent], Awaitable[None]]]:
        """Register given callable for given event type.
        Callback will be called multiple times if it has been registered for multiple event types.

        Args:
            callback: Sync or async callable that pass List[AssignmentEvent] of desired event type.
            event_type: Selected event type.

        Returns:
            The same callable passed as callback.
        """
        ...

    toloka_client: Union[TolokaClient, ...]
    pool_id: str
    _callbacks: Dict[AssignmentEvent.Type, _CursorAndCallbacks]


class PoolStatusObserver(BasePoolObserver):
    """Observer for pool status change.
    For usage with Pipeline.

    Attributes:
        toloka_client: TolokaClient instance or async wrapper around it.
        pool_id: Pool ID.

    Allow to register callbacks using the following methods:
        * on_open
        * on_closed
        * on_archieved
        * on_locked
        * on_status_change

    The Pool object will be passed to the triggered callbacks.

    Examples:
        Bind to the pool's close to make some aggregations.

        >>> def call_this_on_close(pool: Pool) -> None:
        >>>     assignments = client.get_assignments_df(pool_id=pool.id, status=['APPROVED'])
        >>>     do_some_aggregation(assignments)
        >>>
        >>> observer = PoolStatusObserver(toloka_client, pool_id='123')
        >>> observer.on_close(call_this_on_close)
        ...

        Call something at any status change.

        >>> observer.on_status_change(lambda pool: ...)
        ...
    """

    def __init__(
        self,
        toloka_client: TypeVar('T', bound=None),
        pool_id: str
    ) -> None:
        """Method generated by attrs for class PoolStatusObserver.
        """
        ...

    def on_archieved(self, callback: Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]]) -> Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]]: ...

    def on_closed(self, callback: Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]]) -> Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]]: ...

    def on_locked(self, callback: Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]]) -> Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]]: ...

    def on_open(self, callback: Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]]) -> Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]]: ...

    def on_status_change(self, callback: Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]]) -> Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]]: ...

    def register_callback(
        self,
        callback: Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]],
        changed_to: Union[Pool.Status, str]
    ) -> Union[Callable[Pool, None], Callable[Pool, Awaitable[None]]]:
        """Register given callable for pool status change to given value.

        Args:
            callback: Sync or async callable that pass Pool object.
            changed_to: Pool status value to register for.

        Returns:
            The same callable passed as callback.
        """
        ...

    toloka_client: Union[TolokaClient, ...]
    pool_id: str
    _callbacks: Dict[Pool.Status, List[Callable[Pool, Awaitable[None]]]]
    _previous_status: Optional[Pool.Status]
