# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['garoupa',
 'garoupa.algebra',
 'garoupa.algebra.abs',
 'garoupa.algebra.cyclic',
 'garoupa.algebra.dihedral',
 'garoupa.algebra.matrix',
 'garoupa.algebra.product',
 'garoupa.algebra.symmetric']

package_data = \
{'': ['*']}

install_requires = \
['blake3>=0.1.8,<0.2.0', 'colored>=1.4.2,<2.0.0', 'wheel>=0.36.2,<0.37.0']

extras_require = \
{'full': ['progress>=1.5,<2.0', 'pathos>=0.2.7,<0.3.0', 'numpy>=1.20.1,<2.0.0']}

setup_kwargs = {
    'name': 'garoupa',
    'version': '2.210810.11',
    'description': 'Predictable identifiers, cryptographic hash, abstract algebra and operators',
    'long_description': '![test](https://github.com/davips/garoupa/workflows/test/badge.svg)\n[![codecov](https://codecov.io/gh/davips/garoupa/branch/main/graph/badge.svg)](https://codecov.io/gh/davips/garoupa)\n\n# garoupa\n<p>\n<a title="fir0002  flagstaffotos [at] gmail.com Canon 20D + Tamron 28-75mm f/2.8, GFDL 1.2 &lt;http://www.gnu.org/licenses/old-licenses/fdl-1.2.html&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Malabar_grouper_melb_aquarium.jpg"><img width="120" alt="Malabar grouper melb aquarium" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a7/Malabar_grouper_melb_aquarium.jpg/256px-Malabar_grouper_melb_aquarium.jpg"></a>\n</p>\n\nGaroupa is a package containing some groups from abstract algebra and a flexible operable hash, briefly explained in the presentation (ongoing work):\n\n[![image](https://user-images.githubusercontent.com/3620506/114261273-11641e80-99b0-11eb-9fd8-929826e169a2.png)](https://docs.google.com/presentation/d/e/2PACX-1vSCTHD6FeLET6lKgexiqJQ6c4viu0F_60kjoDe0x2mm8RqdhkWOiRA4QN3Zr-QLCq9CsPs_qkAAgxso/embed?start=false&loop=false&delayms=3000)\n\n\nScreenshot of usage in an interactive session:\n\n<p>\n<a href="https://github.com/davips/garoupa/blob/main/examples/frontimg.png">\n<img src="https://raw.githubusercontent.com/davips/garoupa/main/examples/frontimg.png" alt="Colored base-62 representation" width="400" height="230">\n</a>\n</p>\n\n\n\n[PyPI package](https://pypi.org/project/garoupa)\n\n[Latest version](https://github.com/davips/garoupa)\n\nGaroupa hosts also some niceties for group theory experimentation.\n\n## Python installation\n### from package\n```bash\n# Set up a virtualenv. \npython3 -m venv venv\nsource venv/bin/activate\n\n# Install from PyPI\npip install garoupa\n```\n\n### from source\n```bash\ngit clone https://github.com/davips/garoupa\ncd garoupa\npoetry install\n```\n\n### Examples\n**Basic operations**\n<details>\n<p>\n\n```python3\nfrom garoupa import Hash\n\n# Hashes can be multiplied.\nfrom garoupa.hash import identity\n\na = Hash(blob=b"Some large binary content...")\nb = Hash(blob=b"Some other binary content. Might be, e.g., an action or another large content.")\nc = a * b\nprint(f"{a} * {b} = {c}")\n"""\n1WCCD1p4Msmn2hvbiaHOPcYw8qQnGMai5zFZE68xr2kymjdnq6CEysKx7AUZGDqK * hKM..E0QdH-mVMNUpqWbPw56-IEDesW1UHyA7k8BYF5JYIli-c-fSuQagYp.mCNz = jFnCCFpU-8kJY2h3HBB-CjTgm.LJZerGkOUT09EENs.7F75nK8w91lPl9gOIWe62\n"""\n```\n\n```python3\nprint(~b)\n# Multiplication can be reverted by the inverse hash. Zero is the identity hash.\nprint(f"{b} * {~b} = {b * ~b} = 0")\n"""\nKhf00n.bNZZF6fe7CB8.0UaG6rgeXrGfUVwMDON29e8yuXoZzq6ZCVfWEoBk6KDc\nhKM..E0QdH-mVMNUpqWbPw56-IEDesW1UHyA7k8BYF5JYIli-c-fSuQagYp.mCNz * Khf00n.bNZZF6fe7CB8.0UaG6rgeXrGfUVwMDON29e8yuXoZzq6ZCVfWEoBk6KDc = 0000000000000000000000000000000000000000000000000000000000000000 = 0\n"""\n```\n\n```python3\n\nprint(f"{b} * {identity} = {b * identity} = b")\n"""\nhKM..E0QdH-mVMNUpqWbPw56-IEDesW1UHyA7k8BYF5JYIli-c-fSuQagYp.mCNz * 0000000000000000000000000000000000000000000000000000000000000000 = hKM..E0QdH-mVMNUpqWbPw56-IEDesW1UHyA7k8BYF5JYIli-c-fSuQagYp.mCNz = b\n"""\n```\n\n```python3\n\nprint(f"{c} * {~b} = {c * ~b} = {a} = a")\n"""\njFnCCFpU-8kJY2h3HBB-CjTgm.LJZerGkOUT09EENs.7F75nK8w91lPl9gOIWe62 * Khf00n.bNZZF6fe7CB8.0UaG6rgeXrGfUVwMDON29e8yuXoZzq6ZCVfWEoBk6KDc = 1WCCD1p4Msmn2hvbiaHOPcYw8qQnGMai5zFZE68xr2kymjdnq6CEysKx7AUZGDqK = 1WCCD1p4Msmn2hvbiaHOPcYw8qQnGMai5zFZE68xr2kymjdnq6CEysKx7AUZGDqK = a\n"""\n```\n\n```python3\n\nprint(f"{~a} * {c} = {~a * c} = {b} = b")\n"""\n-5ppo-CXfdBEZKwQJRno1iP6a0I1pTGJLUOa5yvjIjEYAfE3FQ8gNQAxzmT4O6P- * jFnCCFpU-8kJY2h3HBB-CjTgm.LJZerGkOUT09EENs.7F75nK8w91lPl9gOIWe62 = hKM..E0QdH-mVMNUpqWbPw56-IEDesW1UHyA7k8BYF5JYIli-c-fSuQagYp.mCNz = hKM..E0QdH-mVMNUpqWbPw56-IEDesW1UHyA7k8BYF5JYIli-c-fSuQagYp.mCNz = b\n"""\n```\n\n```python3\n\n# Division is shorthand for reversion.\nprint(f"{c} / {b} = {c / b} = a")\n"""\njFnCCFpU-8kJY2h3HBB-CjTgm.LJZerGkOUT09EENs.7F75nK8w91lPl9gOIWe62 / hKM..E0QdH-mVMNUpqWbPw56-IEDesW1UHyA7k8BYF5JYIli-c-fSuQagYp.mCNz = 1WCCD1p4Msmn2hvbiaHOPcYw8qQnGMai5zFZE68xr2kymjdnq6CEysKx7AUZGDqK = a\n"""\n```\n\n```python3\n\n# Hash multiplication is not expected to be commutative.\nprint(f"{a * b} != {b * a}")\n"""\njFnCCFpU-8kJY2h3HBB-CjTgm.LJZerGkOUT09EENs.7F75nK8w91lPl9gOIWe62 != jFnCCFpU-8kJY2h3HBB-CsB9NaEYXZlsV3Pmu.WFL2pQpx6gvFcTN-gR54d5f0K2\n"""\n```\n\n```python3\n\n# Hash multiplication is associative.\nprint(f"{a * (b * c)} = {(a * b) * c}")\n"""\nDiLddiPNYgBrU4y7nbb-mm73.unoKH6Ux.AktmuBlx6q51QMs6sjNOGj4Cgvxojn = DiLddiPNYgBrU4y7nbb-mm73.unoKH6Ux.AktmuBlx6q51QMs6sjNOGj4Cgvxojn\n"""\n```\n\n```python3\n\n\n```\n\n\n</p>\n</details>\n\n**Abstract algebra module**\n<details>\n<p>\n\n```python3\nfrom itertools import islice\nfrom math import factorial\n\nfrom garoupa.algebra.cyclic import Z\nfrom garoupa.algebra.dihedral import D\nfrom garoupa.algebra.symmetric import Perm\nfrom garoupa.algebra.symmetric import S\n\n# Direct product between:\n#   symmetric group S4;\n#   cyclic group Z5; and,\n#   dihedral group D4.\nG = S(4) * Z(5) * D(4)\nprint(G)\n"""\nS4×Z5×D4\n"""\n```\n\n```python3\n\n# Operating over 5 sampled pairs.\nfor a, b in islice(zip(G, G), 0, 5):\n    print(a, "*", b, "=", a * b, sep="\\t")\n"""\n«[2, 1, 0, 3], 1, dr6»\t*\t«[1, 3, 0, 2], 2, dr4»\t=\t«[1, 3, 2, 0], 3, dr2»\n«[3, 0, 1, 2], 3, dr5»\t*\t«[1, 0, 2, 3], 3, ds1»\t=\t«[0, 3, 1, 2], 1, ds2»\n«[1, 3, 0, 2], 0, dr1»\t*\t«[0, 2, 1, 3], 0, ds3»\t=\t«[1, 0, 3, 2], 0, ds0»\n«[2, 0, 3, 1], 0, ds2»\t*\t«[1, 0, 3, 2], 0, ds3»\t=\t«[0, 2, 1, 3], 0, dr3»\n«[1, 2, 0, 3], 0, ds2»\t*\t«[2, 0, 1, 3], 3, dr0»\t=\t«[0, 1, 2, 3], 3, ds2»\n"""\n```\n\n```python3\n\n# Operator ~ is another way of sampling.\nG = S(12)\nprint(~G)\n"""\n[2, 6, 4, 7, 11, 5, 10, 3, 8, 0, 1, 9]\n"""\n```\n\n```python3\n\n# Manual element creation.\nlast_perm_i = factorial(12) - 1\na = Perm(i=last_perm_i, n=12)\nprint("Last element of S35:", a)\n"""\nLast element of S35: [11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n"""\n```\n\n```python3\n\n# Inverse element. Group S4.\na = Perm(i=21, n=4)\nb = Perm(i=17, n=4)\nprint(a, "*", ~a, "=", (a * ~a).i, "=", a * ~a, "= identity")\n"""\n[1, 3, 2, 0] * [3, 0, 2, 1] = 0 = [0, 1, 2, 3] = identity\n"""\n```\n\n```python3\n\nprint(a, "*", b, "=", a * b)\n"""\n[1, 3, 2, 0] * [1, 2, 3, 0] = [3, 2, 0, 1]\n"""\n```\n\n```python3\n\nprint(a, "*", b, "*", ~b, "=", a * b * ~b, "= a")\n"""\n[1, 3, 2, 0] * [1, 2, 3, 0] * [3, 0, 1, 2] = [1, 3, 2, 0] = a\n"""\n```\n\n\n</p>\n</details>\n\n**Commutativity degree of groups**\n<details>\n<p>\n\n```python3\n\nfrom garoupa.algebra.cyclic import Z\nfrom garoupa.algebra.dihedral import D\nfrom garoupa.algebra.matrix.m import M\n\n\ndef traverse(G):\n    i, count = G.order, G.order\n    for idx, a in enumerate(G.sorted()):\n        for b in list(G.sorted())[idx + 1:]:\n            if a * b == b * a:\n                count += 2\n            i += 2\n    print(f"|{G}| = ".rjust(20, \' \'),\n          f"{G.order}:".ljust(10, \' \'),\n          f"{count}/{i}:".rjust(15, \' \'), f"  {G.bits} bits",\n          f"\\t{100 * count / i} %", sep="")\n\n\n# Dihedral\ntraverse(D(8))\n"""\n             |D8| = 16:              112/256:  4.0 bits\t43.75 %\n"""\n```\n\n```python3\ntraverse(D(8) ^ 2)\n"""\n          |D8×D8| = 256:         12544/65536:  8.0 bits\t19.140625 %\n"""\n```\n\n```python3\n\n# Z4!\ntraverse(Z(4) * Z(3) * Z(2))\n"""\n       |Z4×Z3×Z2| = 24:              576/576:  4.584962500721157 bits\t100.0 %\n"""\n```\n\n```python3\n\n# M 3x3 %4\ntraverse(M(3, 4))\n\n# Large groups (sampling is needed).\nGs = [D(8) ^ 3, D(8) ^ 4, D(8) ^ 5]\nfor G in Gs:\n    i, count = 0, 0\n    for a, b in zip(G, G):\n        if a * b == b * a:\n            count += 1\n        if i >= 10_000:\n            break\n        i += 1\n    print(f"|{G}| = ".rjust(20, \' \'),\n          f"{G.order}:".ljust(10, \' \'),\n          f"{count}/{i}:".rjust(15, \' \'), f"  {G.bits} bits",\n          f"\\t~{100 * count / i} %", sep="")\n"""\n           |M3%4| = 64:            2560/4096:  6.0 bits\t62.5 %\n       |D8×D8×D8| = 4096:          870/10000:  12.0 bits\t~8.7 %\n    |D8×D8×D8×D8| = 65536:         380/10000:  16.0 bits\t~3.8 %\n |D8×D8×D8×D8×D8| = 1048576:       132/10000:  20.0 bits\t~1.32 %\n"""\n```\n\n\n</p>\n</details>\n\n**Detect identity after many repetitions**\n<details>\n<p>\n\n```python3\n\nimport operator\nfrom datetime import datetime\nfrom functools import reduce\nfrom math import log, inf\nfrom sys import argv\n\nfrom garoupa.algebra.dihedral import D\nfrom garoupa.algebra.symmetric import S\n\nexample = len(argv) == 1 or (not argv[1].isdecimal() and argv[1][0] not in ["p", "s", "d"])\n\nprimes = [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107,\n          109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229,\n          233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359,\n          367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,\n          499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641,\n          643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787,\n          797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\n          947, 953, 967, 971, 977, 983, 991, 997, 1009]\n\nif example:\n    limit, sample = 30, 100\n    lst = []  # See *.\n    for n in primes[:5]:\n        lst.append(D(n, seed=n))\n    G = reduce(operator.mul, lst)\nelse:\n    limit, sample = int(argv[2]), int(argv[3]) if len(argv) > 2 else 1_000_000_000_000\n    if argv[1] == "s25d":\n        G = S(25) * reduce(operator.mul, [D(n) for n in primes[:9]])\n    elif argv[1] == "s57":\n        G = S(57)\n    elif argv[1] == "p384":\n        G = reduce(operator.mul, [D(n) for n in primes[:51]])\n    elif argv[1] == "p64":\n        G = reduce(operator.mul, [D(n) for n in primes[:12]])\n    elif argv[1] == "p96":\n        G = reduce(operator.mul, [D(n) for n in primes[:16]])\n    elif argv[1] == "p128":\n        G = reduce(operator.mul, [D(n) for n in primes[:21]])\n    elif argv[1] == "p256":\n        G = reduce(operator.mul, [D(n) for n in primes[:37]])\n    elif argv[1] == "64":\n        G = reduce(operator.mul, [D(n) for n in range(5, 31, 2)])\n    elif argv[1] == "96":\n        G = reduce(operator.mul, [D(n) for n in range(5, 41, 2)])\n    elif argv[1] == "128":\n        G = reduce(operator.mul, [D(n) for n in range(5, 51, 2)])\n    else:\n        G = reduce(operator.mul, [D(n) for n in range(5, 86, 2)])\n\nprint(f"{G.bits} bits   Pc: {G.comm_degree}  order: {G.order} {G}", flush=True)\nprint("--------------------------------------------------------------", flush=True)\nfor hist in G.sampled_orders(sample=sample, limit=limit):\n    tot = sum(hist.values())\n    bad = 0  # See *.\n    for k, v in hist.items():\n        if k[0] <= limit:\n            bad += v\n    print(hist, flush=True)\n    hist = hist.copy()\n    if (inf, inf) in hist:\n        del hist[(inf, inf)]\n    hist = {int((k[0] + k[1]) / 2): v for k, v in hist.items()}\n    print(f"\\nbits: {log(G.order, 2):.2f}  Pc: {G.comm_degree or -1:.2e}   a^<{limit}=0: {bad}/{tot} = {bad / tot:.2e}",\n          G, G._pi_core(hist), datetime.now().strftime("%d/%m/%Y %H:%M:%S"), flush=True)\n# * -> [Explicit FOR due to autogeneration of README through eval]\n"""\n21.376617194973697 bits   Pc: 0.004113533525298232  order: 2722720 D5×D7×D11×D13×D17\n--------------------------------------------------------------\n{(-1, 10): 9, (9, 20): 7, (19, 30): 9, (inf, inf): 75}\n\nbits: 21.38  Pc: 4.11e-03   a^<30=0: 25/100 = 2.50e-01 D5×D7×D11×D13×D17 0.125 11/08/2021 23:47:43\n"""\n```\n\n\n</p>\n</details>\n\n**Tendence of commutativity on Mn**\n<details>\n<p>\n\n```python3\nfrom itertools import chain\n\nfrom garoupa.algebra.matrix.m import M\nfrom garoupa.algebra.matrix.m8bit import M8bit\n\n\ndef traverse(G):\n    i, count = G.order, G.order\n    for idx, a in enumerate(G.sorted()):\n        for b in list(G.sorted())[idx + 1:]:\n            if a * b == b * a:\n                count += 2\n            i += 2\n    print(f"|{G}| = ".rjust(20, \' \'),\n          f"{G.order}:".ljust(10, \' \'),\n          f"{count}/{i}:".rjust(15, \' \'), f"  {G.bits} bits",\n          f"\\t{100 * count / i} %", sep="")\n\n\nM1_4 = map(M, range(1, 5))\nfor G in chain(M1_4, [M8bit(), M(5)]):\n    traverse(G)\n# ...\nfor G in map(M, range(6, 11)):\n    i, count = 0, 0\n    for a, b in zip(G, G):\n        if a * b == b * a:\n            count += 1\n        i += 1\n        if i >= 1_000_000:\n            break\n    print(f"|{G}| = ".rjust(20, \' \'),\n          f"{G.order}:".ljust(10, \' \'),\n          f"{count}/{i}:".rjust(15, \' \'), f"  {G.bits} bits",\n          f"\\t~{100 * count / i} %", sep="")\n\n"""\n|M1| = 1:                        1/1:  0 bits\t100.0 %\n|M2| = 2:                        4/4:  1 bits\t100.0 %\n|M3| = 8:                      40/64:  3 bits\t62.5 %\n|M4| = 64:                 1024/4096:  6 bits\t25.0 %\n|M8bit| = 256:              14848/65536:  8 bits\t22.65625 %\n|M5| = 1024:           62464/1048576:  10 bits\t5.95703125 %\n|M6| = 32768:              286/32768:  15 bits\t0.872802734375 %\n|M7| = 2097152:          683/1000000:  21 bits\t0.0683 %\n|M8| = 268435456:         30/1000000:  28 bits\t0.003 %\n|M9| = 68719476736:        1/1000000:  36 bits\t0.0001 %\n|M10| = 35184372088832:     0/1000000:  45 bits\t0.0 %\n"""\n```\n</p>\n</details>\n\n**Groups benefit from methods from module \'hash\'**\n<details>\n<p>\n\n```python3\nfrom garoupa.algebra.matrix import M\nm = ~M(23)\nprint(repr(m.hash))\n```\n<a href="https://github.com/davips/garoupa/blob/main/examples/7KDd8TiA3S11QTkUid2wy87DQIeGQ35vB1bsP5Y6DjZ.png">\n<img src="https://raw.githubusercontent.com/davips/garoupa/main/examples/7KDd8TiA3S11QTkUid2wy87DQIeGQ35vB1bsP5Y6DjZ.png" alt="Colored base-62 representation" width="380" height="18">\n</a>\n</p>\n</details>\n\n\n\n### Features\n* [x] Create noncommutative identifiers from binary content\n* [ ] Create commutative identifiers from binary content\n  * [ ] Create elements from H\n  * [ ] Create elements from H\n\n\n### Performance\nSee package [hosh](https://pypi.org/project/hosh) for faster, native (compiled) hash operations.\nHowever, only future major version `1.*.*` or higher of hosh will be compatible with garoupa hashes.\n',
    'author': 'davips',
    'author_email': 'dpsabc@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
