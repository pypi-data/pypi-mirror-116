'''
# Terraform CDK datadog Provider ~> 3.0

This repo builds and publishes the Terraform datadog Provider bindings for [cdktf](https://cdk.tf).

Current build targets are:

* npm
* Pypi
* Nuget
* Maven

## Docs

Find auto-generated docs for this provider here: [./API.md](./API.md)

## Versioning

This project is explicitly not tracking the Terraform datadog Provider version 1:1. In fact, it always tracks `latest` of `~> 3.0` with every release. If there scenarios where you explicitly have to pin your provider version, you can do so by generating the [provider constructs manually](https://cdk.tf/imports).

These are the upstream dependencies:

* [Terraform CDK](https://cdk.tf)
* [Terraform datadog Provider](https://github.com/terraform-providers/terraform-provider-datadog)
* [Terraform Engine](https://terraform.io)

If there are breaking changes (backward incompatible) in any of the above, the major version of this project will be bumped. While the Terraform Engine and the Terraform datadog Provider are relatively stable, the Terraform CDK is in an early stage. Therefore, it's likely that there will be breaking changes.

## Features / Issues / Bugs

Please report bugs and issues to the [terraform cdk](https://cdk.tf) project:

* [Create bug report](https://cdk.tf/bug)
* [Create feature request](https://cdk.tf/feature)

## Contributing

## projen

This is mostly based on [projen](https://github.com/eladb/projen), which takes care of generating the entire repository.

## cdktf-provider-project based on projen

There's a custom [project builder](https://github.com/terraform-cdk-providers/cdktf-provider-project) which encapsulate the common settings for all `cdktf` providers.

## provider version

The provider version can be adjusted in [./.projenrc.js](./.projenrc.js).
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from ._jsii import *

import cdktf
import constructs


class Dashboard(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.Dashboard",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html datadog_dashboard}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        layout_type: builtins.str,
        title: builtins.str,
        widget: typing.Sequence["DashboardWidget"],
        dashboard_lists: typing.Optional[typing.Sequence[jsii.Number]] = None,
        description: typing.Optional[builtins.str] = None,
        is_read_only: typing.Optional[builtins.bool] = None,
        notify_list: typing.Optional[typing.Sequence[builtins.str]] = None,
        reflow_type: typing.Optional[builtins.str] = None,
        restricted_roles: typing.Optional[typing.Sequence[builtins.str]] = None,
        template_variable: typing.Optional[typing.Sequence["DashboardTemplateVariable"]] = None,
        template_variable_preset: typing.Optional[typing.Sequence["DashboardTemplateVariablePreset"]] = None,
        url: typing.Optional[builtins.str] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html datadog_dashboard} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param layout_type: The layout type of the dashboard. Valid values are ``ordered``, ``free``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#layout_type Dashboard#layout_type}
        :param title: The title of the dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param widget: widget block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#widget Dashboard#widget}
        :param dashboard_lists: The list of dashboard lists this dashboard belongs to. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#dashboard_lists Dashboard#dashboard_lists}
        :param description: The description of the dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#description Dashboard#description}
        :param is_read_only: Whether this dashboard is read-only. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_read_only Dashboard#is_read_only}
        :param notify_list: The list of handles of users to notify when changes are made to this dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#notify_list Dashboard#notify_list}
        :param reflow_type: The reflow type of a new dashboard layout. Set this only when layout type is ``ordered``. If set to ``fixed``, the dashboard expects all widgets to have a layout, and if it's set to ``auto``, widgets should not have layouts. Valid values are ``auto``, ``fixed``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#reflow_type Dashboard#reflow_type}
        :param restricted_roles: Role UUIDs corresponding to users authorized to edit the dashboard. **This feature is currently in beta.**. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#restricted_roles Dashboard#restricted_roles}
        :param template_variable: template_variable block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#template_variable Dashboard#template_variable}
        :param template_variable_preset: template_variable_preset block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#template_variable_preset Dashboard#template_variable_preset}
        :param url: The URL of the dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url Dashboard#url}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DashboardConfig(
            layout_type=layout_type,
            title=title,
            widget=widget,
            dashboard_lists=dashboard_lists,
            description=description,
            is_read_only=is_read_only,
            notify_list=notify_list,
            reflow_type=reflow_type,
            restricted_roles=restricted_roles,
            template_variable=template_variable,
            template_variable_preset=template_variable_preset,
            url=url,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(Dashboard, self, [scope, id, config])

    @jsii.member(jsii_name="resetDashboardLists")
    def reset_dashboard_lists(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDashboardLists", []))

    @jsii.member(jsii_name="resetDescription")
    def reset_description(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDescription", []))

    @jsii.member(jsii_name="resetIsReadOnly")
    def reset_is_read_only(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIsReadOnly", []))

    @jsii.member(jsii_name="resetNotifyList")
    def reset_notify_list(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNotifyList", []))

    @jsii.member(jsii_name="resetReflowType")
    def reset_reflow_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReflowType", []))

    @jsii.member(jsii_name="resetRestrictedRoles")
    def reset_restricted_roles(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRestrictedRoles", []))

    @jsii.member(jsii_name="resetTemplateVariable")
    def reset_template_variable(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTemplateVariable", []))

    @jsii.member(jsii_name="resetTemplateVariablePreset")
    def reset_template_variable_preset(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTemplateVariablePreset", []))

    @jsii.member(jsii_name="resetUrl")
    def reset_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUrl", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dashboardListsRemoved")
    def dashboard_lists_removed(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.get(self, "dashboardListsRemoved"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="layoutTypeInput")
    def layout_type_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "layoutTypeInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="titleInput")
    def title_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "titleInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="widgetInput")
    def widget_input(self) -> typing.List["DashboardWidget"]:
        return typing.cast(typing.List["DashboardWidget"], jsii.get(self, "widgetInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dashboardListsInput")
    def dashboard_lists_input(self) -> typing.Optional[typing.List[jsii.Number]]:
        return typing.cast(typing.Optional[typing.List[jsii.Number]], jsii.get(self, "dashboardListsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="descriptionInput")
    def description_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "descriptionInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="isReadOnlyInput")
    def is_read_only_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "isReadOnlyInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="notifyListInput")
    def notify_list_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "notifyListInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="reflowTypeInput")
    def reflow_type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "reflowTypeInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="restrictedRolesInput")
    def restricted_roles_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "restrictedRolesInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="templateVariableInput")
    def template_variable_input(
        self,
    ) -> typing.Optional[typing.List["DashboardTemplateVariable"]]:
        return typing.cast(typing.Optional[typing.List["DashboardTemplateVariable"]], jsii.get(self, "templateVariableInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="templateVariablePresetInput")
    def template_variable_preset_input(
        self,
    ) -> typing.Optional[typing.List["DashboardTemplateVariablePreset"]]:
        return typing.cast(typing.Optional[typing.List["DashboardTemplateVariablePreset"]], jsii.get(self, "templateVariablePresetInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="urlInput")
    def url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "urlInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dashboardLists")
    def dashboard_lists(self) -> typing.List[jsii.Number]:
        return typing.cast(typing.List[jsii.Number], jsii.get(self, "dashboardLists"))

    @dashboard_lists.setter
    def dashboard_lists(self, value: typing.List[jsii.Number]) -> None:
        jsii.set(self, "dashboardLists", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "description"))

    @description.setter
    def description(self, value: builtins.str) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="isReadOnly")
    def is_read_only(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "isReadOnly"))

    @is_read_only.setter
    def is_read_only(self, value: builtins.bool) -> None:
        jsii.set(self, "isReadOnly", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="layoutType")
    def layout_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "layoutType"))

    @layout_type.setter
    def layout_type(self, value: builtins.str) -> None:
        jsii.set(self, "layoutType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="notifyList")
    def notify_list(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "notifyList"))

    @notify_list.setter
    def notify_list(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "notifyList", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="reflowType")
    def reflow_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "reflowType"))

    @reflow_type.setter
    def reflow_type(self, value: builtins.str) -> None:
        jsii.set(self, "reflowType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="restrictedRoles")
    def restricted_roles(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "restrictedRoles"))

    @restricted_roles.setter
    def restricted_roles(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "restrictedRoles", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="templateVariable")
    def template_variable(self) -> typing.List["DashboardTemplateVariable"]:
        return typing.cast(typing.List["DashboardTemplateVariable"], jsii.get(self, "templateVariable"))

    @template_variable.setter
    def template_variable(
        self,
        value: typing.List["DashboardTemplateVariable"],
    ) -> None:
        jsii.set(self, "templateVariable", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="templateVariablePreset")
    def template_variable_preset(
        self,
    ) -> typing.List["DashboardTemplateVariablePreset"]:
        return typing.cast(typing.List["DashboardTemplateVariablePreset"], jsii.get(self, "templateVariablePreset"))

    @template_variable_preset.setter
    def template_variable_preset(
        self,
        value: typing.List["DashboardTemplateVariablePreset"],
    ) -> None:
        jsii.set(self, "templateVariablePreset", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @title.setter
    def title(self, value: builtins.str) -> None:
        jsii.set(self, "title", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="url")
    def url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "url"))

    @url.setter
    def url(self, value: builtins.str) -> None:
        jsii.set(self, "url", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="widget")
    def widget(self) -> typing.List["DashboardWidget"]:
        return typing.cast(typing.List["DashboardWidget"], jsii.get(self, "widget"))

    @widget.setter
    def widget(self, value: typing.List["DashboardWidget"]) -> None:
        jsii.set(self, "widget", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "layout_type": "layoutType",
        "title": "title",
        "widget": "widget",
        "dashboard_lists": "dashboardLists",
        "description": "description",
        "is_read_only": "isReadOnly",
        "notify_list": "notifyList",
        "reflow_type": "reflowType",
        "restricted_roles": "restrictedRoles",
        "template_variable": "templateVariable",
        "template_variable_preset": "templateVariablePreset",
        "url": "url",
    },
)
class DashboardConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        layout_type: builtins.str,
        title: builtins.str,
        widget: typing.Sequence["DashboardWidget"],
        dashboard_lists: typing.Optional[typing.Sequence[jsii.Number]] = None,
        description: typing.Optional[builtins.str] = None,
        is_read_only: typing.Optional[builtins.bool] = None,
        notify_list: typing.Optional[typing.Sequence[builtins.str]] = None,
        reflow_type: typing.Optional[builtins.str] = None,
        restricted_roles: typing.Optional[typing.Sequence[builtins.str]] = None,
        template_variable: typing.Optional[typing.Sequence["DashboardTemplateVariable"]] = None,
        template_variable_preset: typing.Optional[typing.Sequence["DashboardTemplateVariablePreset"]] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param layout_type: The layout type of the dashboard. Valid values are ``ordered``, ``free``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#layout_type Dashboard#layout_type}
        :param title: The title of the dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param widget: widget block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#widget Dashboard#widget}
        :param dashboard_lists: The list of dashboard lists this dashboard belongs to. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#dashboard_lists Dashboard#dashboard_lists}
        :param description: The description of the dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#description Dashboard#description}
        :param is_read_only: Whether this dashboard is read-only. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_read_only Dashboard#is_read_only}
        :param notify_list: The list of handles of users to notify when changes are made to this dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#notify_list Dashboard#notify_list}
        :param reflow_type: The reflow type of a new dashboard layout. Set this only when layout type is ``ordered``. If set to ``fixed``, the dashboard expects all widgets to have a layout, and if it's set to ``auto``, widgets should not have layouts. Valid values are ``auto``, ``fixed``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#reflow_type Dashboard#reflow_type}
        :param restricted_roles: Role UUIDs corresponding to users authorized to edit the dashboard. **This feature is currently in beta.**. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#restricted_roles Dashboard#restricted_roles}
        :param template_variable: template_variable block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#template_variable Dashboard#template_variable}
        :param template_variable_preset: template_variable_preset block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#template_variable_preset Dashboard#template_variable_preset}
        :param url: The URL of the dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url Dashboard#url}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "layout_type": layout_type,
            "title": title,
            "widget": widget,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if dashboard_lists is not None:
            self._values["dashboard_lists"] = dashboard_lists
        if description is not None:
            self._values["description"] = description
        if is_read_only is not None:
            self._values["is_read_only"] = is_read_only
        if notify_list is not None:
            self._values["notify_list"] = notify_list
        if reflow_type is not None:
            self._values["reflow_type"] = reflow_type
        if restricted_roles is not None:
            self._values["restricted_roles"] = restricted_roles
        if template_variable is not None:
            self._values["template_variable"] = template_variable
        if template_variable_preset is not None:
            self._values["template_variable_preset"] = template_variable_preset
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def layout_type(self) -> builtins.str:
        '''The layout type of the dashboard. Valid values are ``ordered``, ``free``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#layout_type Dashboard#layout_type}
        '''
        result = self._values.get("layout_type")
        assert result is not None, "Required property 'layout_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def title(self) -> builtins.str:
        '''The title of the dashboard.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        assert result is not None, "Required property 'title' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def widget(self) -> typing.List["DashboardWidget"]:
        '''widget block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#widget Dashboard#widget}
        '''
        result = self._values.get("widget")
        assert result is not None, "Required property 'widget' is missing"
        return typing.cast(typing.List["DashboardWidget"], result)

    @builtins.property
    def dashboard_lists(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''The list of dashboard lists this dashboard belongs to.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#dashboard_lists Dashboard#dashboard_lists}
        '''
        result = self._values.get("dashboard_lists")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the dashboard.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#description Dashboard#description}
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_read_only(self) -> typing.Optional[builtins.bool]:
        '''Whether this dashboard is read-only.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_read_only Dashboard#is_read_only}
        '''
        result = self._values.get("is_read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def notify_list(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of handles of users to notify when changes are made to this dashboard.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#notify_list Dashboard#notify_list}
        '''
        result = self._values.get("notify_list")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def reflow_type(self) -> typing.Optional[builtins.str]:
        '''The reflow type of a new dashboard layout.

        Set this only when layout type is ``ordered``. If set to ``fixed``, the dashboard expects all widgets to have a layout, and if it's set to ``auto``, widgets should not have layouts. Valid values are ``auto``, ``fixed``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#reflow_type Dashboard#reflow_type}
        '''
        result = self._values.get("reflow_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def restricted_roles(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Role UUIDs corresponding to users authorized to edit the dashboard. **This feature is currently in beta.**.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#restricted_roles Dashboard#restricted_roles}
        '''
        result = self._values.get("restricted_roles")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def template_variable(
        self,
    ) -> typing.Optional[typing.List["DashboardTemplateVariable"]]:
        '''template_variable block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#template_variable Dashboard#template_variable}
        '''
        result = self._values.get("template_variable")
        return typing.cast(typing.Optional[typing.List["DashboardTemplateVariable"]], result)

    @builtins.property
    def template_variable_preset(
        self,
    ) -> typing.Optional[typing.List["DashboardTemplateVariablePreset"]]:
        '''template_variable_preset block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#template_variable_preset Dashboard#template_variable_preset}
        '''
        result = self._values.get("template_variable_preset")
        return typing.cast(typing.Optional[typing.List["DashboardTemplateVariablePreset"]], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''The URL of the dashboard.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url Dashboard#url}
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DashboardJson(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DashboardJson",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_json.html datadog_dashboard_json}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        dashboard: builtins.str,
        dashboard_lists: typing.Optional[typing.Sequence[jsii.Number]] = None,
        url: typing.Optional[builtins.str] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_json.html datadog_dashboard_json} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param dashboard: The JSON formatted definition of the Dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_json.html#dashboard DashboardJson#dashboard}
        :param dashboard_lists: The list of dashboard lists this dashboard belongs to. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_json.html#dashboard_lists DashboardJson#dashboard_lists}
        :param url: The URL of the dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_json.html#url DashboardJson#url}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DashboardJsonConfig(
            dashboard=dashboard,
            dashboard_lists=dashboard_lists,
            url=url,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(DashboardJson, self, [scope, id, config])

    @jsii.member(jsii_name="resetDashboardLists")
    def reset_dashboard_lists(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDashboardLists", []))

    @jsii.member(jsii_name="resetUrl")
    def reset_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUrl", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dashboardInput")
    def dashboard_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dashboardInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dashboardListsRemoved")
    def dashboard_lists_removed(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.get(self, "dashboardListsRemoved"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dashboardListsInput")
    def dashboard_lists_input(self) -> typing.Optional[typing.List[jsii.Number]]:
        return typing.cast(typing.Optional[typing.List[jsii.Number]], jsii.get(self, "dashboardListsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="urlInput")
    def url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "urlInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dashboard")
    def dashboard(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dashboard"))

    @dashboard.setter
    def dashboard(self, value: builtins.str) -> None:
        jsii.set(self, "dashboard", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dashboardLists")
    def dashboard_lists(self) -> typing.List[jsii.Number]:
        return typing.cast(typing.List[jsii.Number], jsii.get(self, "dashboardLists"))

    @dashboard_lists.setter
    def dashboard_lists(self, value: typing.List[jsii.Number]) -> None:
        jsii.set(self, "dashboardLists", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="url")
    def url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "url"))

    @url.setter
    def url(self, value: builtins.str) -> None:
        jsii.set(self, "url", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardJsonConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "dashboard": "dashboard",
        "dashboard_lists": "dashboardLists",
        "url": "url",
    },
)
class DashboardJsonConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        dashboard: builtins.str,
        dashboard_lists: typing.Optional[typing.Sequence[jsii.Number]] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param dashboard: The JSON formatted definition of the Dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_json.html#dashboard DashboardJson#dashboard}
        :param dashboard_lists: The list of dashboard lists this dashboard belongs to. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_json.html#dashboard_lists DashboardJson#dashboard_lists}
        :param url: The URL of the dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_json.html#url DashboardJson#url}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "dashboard": dashboard,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if dashboard_lists is not None:
            self._values["dashboard_lists"] = dashboard_lists
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def dashboard(self) -> builtins.str:
        '''The JSON formatted definition of the Dashboard.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_json.html#dashboard DashboardJson#dashboard}
        '''
        result = self._values.get("dashboard")
        assert result is not None, "Required property 'dashboard' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def dashboard_lists(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''The list of dashboard lists this dashboard belongs to.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_json.html#dashboard_lists DashboardJson#dashboard_lists}
        '''
        result = self._values.get("dashboard_lists")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''The URL of the dashboard.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_json.html#url DashboardJson#url}
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardJsonConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DashboardList(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DashboardList",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html datadog_dashboard_list}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        name: builtins.str,
        dash_item: typing.Optional[typing.Sequence["DashboardListDashItem"]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html datadog_dashboard_list} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param name: The name of the Dashboard List. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html#name DashboardList#name}
        :param dash_item: dash_item block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html#dash_item DashboardList#dash_item}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DashboardListConfig(
            name=name,
            dash_item=dash_item,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(DashboardList, self, [scope, id, config])

    @jsii.member(jsii_name="resetDashItem")
    def reset_dash_item(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDashItem", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dashItemInput")
    def dash_item_input(self) -> typing.Optional[typing.List["DashboardListDashItem"]]:
        return typing.cast(typing.Optional[typing.List["DashboardListDashItem"]], jsii.get(self, "dashItemInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dashItem")
    def dash_item(self) -> typing.List["DashboardListDashItem"]:
        return typing.cast(typing.List["DashboardListDashItem"], jsii.get(self, "dashItem"))

    @dash_item.setter
    def dash_item(self, value: typing.List["DashboardListDashItem"]) -> None:
        jsii.set(self, "dashItem", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardListConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "name": "name",
        "dash_item": "dashItem",
    },
)
class DashboardListConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        name: builtins.str,
        dash_item: typing.Optional[typing.Sequence["DashboardListDashItem"]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param name: The name of the Dashboard List. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html#name DashboardList#name}
        :param dash_item: dash_item block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html#dash_item DashboardList#dash_item}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if dash_item is not None:
            self._values["dash_item"] = dash_item

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the Dashboard List.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html#name DashboardList#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def dash_item(self) -> typing.Optional[typing.List["DashboardListDashItem"]]:
        '''dash_item block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html#dash_item DashboardList#dash_item}
        '''
        result = self._values.get("dash_item")
        return typing.cast(typing.Optional[typing.List["DashboardListDashItem"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardListConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardListDashItem",
    jsii_struct_bases=[],
    name_mapping={"dash_id": "dashId", "type": "type"},
)
class DashboardListDashItem:
    def __init__(self, *, dash_id: builtins.str, type: builtins.str) -> None:
        '''
        :param dash_id: The ID of the dashboard to add. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html#dash_id DashboardList#dash_id}
        :param type: The type of this dashboard. Valid values are ``custom_timeboard``, ``custom_screenboard``, ``integration_screenboard``, ``integration_timeboard``, ``host_timeboard``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html#type DashboardList#type}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "dash_id": dash_id,
            "type": type,
        }

    @builtins.property
    def dash_id(self) -> builtins.str:
        '''The ID of the dashboard to add.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html#dash_id DashboardList#dash_id}
        '''
        result = self._values.get("dash_id")
        assert result is not None, "Required property 'dash_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''The type of this dashboard. Valid values are ``custom_timeboard``, ``custom_screenboard``, ``integration_screenboard``, ``integration_timeboard``, ``host_timeboard``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard_list.html#type DashboardList#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardListDashItem(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardTemplateVariable",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "default": "default", "prefix": "prefix"},
)
class DashboardTemplateVariable:
    def __init__(
        self,
        *,
        name: builtins.str,
        default: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: The name of the variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param default: The default value for the template variable on dashboard load. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#default Dashboard#default}
        :param prefix: The tag prefix associated with the variable. Only tags with this prefix will appear in the variable dropdown. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#prefix Dashboard#prefix}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if default is not None:
            self._values["default"] = default
        if prefix is not None:
            self._values["prefix"] = prefix

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def default(self) -> typing.Optional[builtins.str]:
        '''The default value for the template variable on dashboard load.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#default Dashboard#default}
        '''
        result = self._values.get("default")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        '''The tag prefix associated with the variable. Only tags with this prefix will appear in the variable dropdown.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#prefix Dashboard#prefix}
        '''
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardTemplateVariable(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardTemplateVariablePreset",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "template_variable": "templateVariable"},
)
class DashboardTemplateVariablePreset:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        template_variable: typing.Optional[typing.Sequence["DashboardTemplateVariablePresetTemplateVariable"]] = None,
    ) -> None:
        '''
        :param name: The name of the preset. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param template_variable: template_variable block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#template_variable Dashboard#template_variable}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if template_variable is not None:
            self._values["template_variable"] = template_variable

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the preset.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def template_variable(
        self,
    ) -> typing.Optional[typing.List["DashboardTemplateVariablePresetTemplateVariable"]]:
        '''template_variable block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#template_variable Dashboard#template_variable}
        '''
        result = self._values.get("template_variable")
        return typing.cast(typing.Optional[typing.List["DashboardTemplateVariablePresetTemplateVariable"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardTemplateVariablePreset(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardTemplateVariablePresetTemplateVariable",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class DashboardTemplateVariablePresetTemplateVariable:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: The name of the template variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param value: The value that should be assumed by the template variable in this preset. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the template variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''The value that should be assumed by the template variable in this preset.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardTemplateVariablePresetTemplateVariable(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidget",
    jsii_struct_bases=[],
    name_mapping={
        "alert_graph_definition": "alertGraphDefinition",
        "alert_value_definition": "alertValueDefinition",
        "change_definition": "changeDefinition",
        "check_status_definition": "checkStatusDefinition",
        "distribution_definition": "distributionDefinition",
        "event_stream_definition": "eventStreamDefinition",
        "event_timeline_definition": "eventTimelineDefinition",
        "free_text_definition": "freeTextDefinition",
        "geomap_definition": "geomapDefinition",
        "group_definition": "groupDefinition",
        "heatmap_definition": "heatmapDefinition",
        "hostmap_definition": "hostmapDefinition",
        "iframe_definition": "iframeDefinition",
        "image_definition": "imageDefinition",
        "log_stream_definition": "logStreamDefinition",
        "manage_status_definition": "manageStatusDefinition",
        "note_definition": "noteDefinition",
        "query_table_definition": "queryTableDefinition",
        "query_value_definition": "queryValueDefinition",
        "scatterplot_definition": "scatterplotDefinition",
        "service_level_objective_definition": "serviceLevelObjectiveDefinition",
        "servicemap_definition": "servicemapDefinition",
        "timeseries_definition": "timeseriesDefinition",
        "toplist_definition": "toplistDefinition",
        "trace_service_definition": "traceServiceDefinition",
        "widget_layout": "widgetLayout",
    },
)
class DashboardWidget:
    def __init__(
        self,
        *,
        alert_graph_definition: typing.Optional[typing.Sequence["DashboardWidgetAlertGraphDefinition"]] = None,
        alert_value_definition: typing.Optional[typing.Sequence["DashboardWidgetAlertValueDefinition"]] = None,
        change_definition: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinition"]] = None,
        check_status_definition: typing.Optional[typing.Sequence["DashboardWidgetCheckStatusDefinition"]] = None,
        distribution_definition: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinition"]] = None,
        event_stream_definition: typing.Optional[typing.Sequence["DashboardWidgetEventStreamDefinition"]] = None,
        event_timeline_definition: typing.Optional[typing.Sequence["DashboardWidgetEventTimelineDefinition"]] = None,
        free_text_definition: typing.Optional[typing.Sequence["DashboardWidgetFreeTextDefinition"]] = None,
        geomap_definition: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinition"]] = None,
        group_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinition"]] = None,
        heatmap_definition: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinition"]] = None,
        hostmap_definition: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinition"]] = None,
        iframe_definition: typing.Optional[typing.Sequence["DashboardWidgetIframeDefinition"]] = None,
        image_definition: typing.Optional[typing.Sequence["DashboardWidgetImageDefinition"]] = None,
        log_stream_definition: typing.Optional[typing.Sequence["DashboardWidgetLogStreamDefinition"]] = None,
        manage_status_definition: typing.Optional[typing.Sequence["DashboardWidgetManageStatusDefinition"]] = None,
        note_definition: typing.Optional[typing.Sequence["DashboardWidgetNoteDefinition"]] = None,
        query_table_definition: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinition"]] = None,
        query_value_definition: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinition"]] = None,
        scatterplot_definition: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinition"]] = None,
        service_level_objective_definition: typing.Optional[typing.Sequence["DashboardWidgetServiceLevelObjectiveDefinition"]] = None,
        servicemap_definition: typing.Optional[typing.Sequence["DashboardWidgetServicemapDefinition"]] = None,
        timeseries_definition: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinition"]] = None,
        toplist_definition: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinition"]] = None,
        trace_service_definition: typing.Optional[typing.Sequence["DashboardWidgetTraceServiceDefinition"]] = None,
        widget_layout: typing.Optional[typing.Sequence["DashboardWidgetWidgetLayout"]] = None,
    ) -> None:
        '''
        :param alert_graph_definition: alert_graph_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_graph_definition Dashboard#alert_graph_definition}
        :param alert_value_definition: alert_value_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_value_definition Dashboard#alert_value_definition}
        :param change_definition: change_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#change_definition Dashboard#change_definition}
        :param check_status_definition: check_status_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#check_status_definition Dashboard#check_status_definition}
        :param distribution_definition: distribution_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#distribution_definition Dashboard#distribution_definition}
        :param event_stream_definition: event_stream_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_stream_definition Dashboard#event_stream_definition}
        :param event_timeline_definition: event_timeline_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_timeline_definition Dashboard#event_timeline_definition}
        :param free_text_definition: free_text_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#free_text_definition Dashboard#free_text_definition}
        :param geomap_definition: geomap_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#geomap_definition Dashboard#geomap_definition}
        :param group_definition: group_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_definition Dashboard#group_definition}
        :param heatmap_definition: heatmap_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#heatmap_definition Dashboard#heatmap_definition}
        :param hostmap_definition: hostmap_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hostmap_definition Dashboard#hostmap_definition}
        :param iframe_definition: iframe_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#iframe_definition Dashboard#iframe_definition}
        :param image_definition: image_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_definition Dashboard#image_definition}
        :param log_stream_definition: log_stream_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_stream_definition Dashboard#log_stream_definition}
        :param manage_status_definition: manage_status_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#manage_status_definition Dashboard#manage_status_definition}
        :param note_definition: note_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#note_definition Dashboard#note_definition}
        :param query_table_definition: query_table_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query_table_definition Dashboard#query_table_definition}
        :param query_value_definition: query_value_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query_value_definition Dashboard#query_value_definition}
        :param scatterplot_definition: scatterplot_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scatterplot_definition Dashboard#scatterplot_definition}
        :param service_level_objective_definition: service_level_objective_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service_level_objective_definition Dashboard#service_level_objective_definition}
        :param servicemap_definition: servicemap_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#servicemap_definition Dashboard#servicemap_definition}
        :param timeseries_definition: timeseries_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeseries_definition Dashboard#timeseries_definition}
        :param toplist_definition: toplist_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#toplist_definition Dashboard#toplist_definition}
        :param trace_service_definition: trace_service_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#trace_service_definition Dashboard#trace_service_definition}
        :param widget_layout: widget_layout block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#widget_layout Dashboard#widget_layout}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if alert_graph_definition is not None:
            self._values["alert_graph_definition"] = alert_graph_definition
        if alert_value_definition is not None:
            self._values["alert_value_definition"] = alert_value_definition
        if change_definition is not None:
            self._values["change_definition"] = change_definition
        if check_status_definition is not None:
            self._values["check_status_definition"] = check_status_definition
        if distribution_definition is not None:
            self._values["distribution_definition"] = distribution_definition
        if event_stream_definition is not None:
            self._values["event_stream_definition"] = event_stream_definition
        if event_timeline_definition is not None:
            self._values["event_timeline_definition"] = event_timeline_definition
        if free_text_definition is not None:
            self._values["free_text_definition"] = free_text_definition
        if geomap_definition is not None:
            self._values["geomap_definition"] = geomap_definition
        if group_definition is not None:
            self._values["group_definition"] = group_definition
        if heatmap_definition is not None:
            self._values["heatmap_definition"] = heatmap_definition
        if hostmap_definition is not None:
            self._values["hostmap_definition"] = hostmap_definition
        if iframe_definition is not None:
            self._values["iframe_definition"] = iframe_definition
        if image_definition is not None:
            self._values["image_definition"] = image_definition
        if log_stream_definition is not None:
            self._values["log_stream_definition"] = log_stream_definition
        if manage_status_definition is not None:
            self._values["manage_status_definition"] = manage_status_definition
        if note_definition is not None:
            self._values["note_definition"] = note_definition
        if query_table_definition is not None:
            self._values["query_table_definition"] = query_table_definition
        if query_value_definition is not None:
            self._values["query_value_definition"] = query_value_definition
        if scatterplot_definition is not None:
            self._values["scatterplot_definition"] = scatterplot_definition
        if service_level_objective_definition is not None:
            self._values["service_level_objective_definition"] = service_level_objective_definition
        if servicemap_definition is not None:
            self._values["servicemap_definition"] = servicemap_definition
        if timeseries_definition is not None:
            self._values["timeseries_definition"] = timeseries_definition
        if toplist_definition is not None:
            self._values["toplist_definition"] = toplist_definition
        if trace_service_definition is not None:
            self._values["trace_service_definition"] = trace_service_definition
        if widget_layout is not None:
            self._values["widget_layout"] = widget_layout

    @builtins.property
    def alert_graph_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetAlertGraphDefinition"]]:
        '''alert_graph_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_graph_definition Dashboard#alert_graph_definition}
        '''
        result = self._values.get("alert_graph_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetAlertGraphDefinition"]], result)

    @builtins.property
    def alert_value_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetAlertValueDefinition"]]:
        '''alert_value_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_value_definition Dashboard#alert_value_definition}
        '''
        result = self._values.get("alert_value_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetAlertValueDefinition"]], result)

    @builtins.property
    def change_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinition"]]:
        '''change_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#change_definition Dashboard#change_definition}
        '''
        result = self._values.get("change_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinition"]], result)

    @builtins.property
    def check_status_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetCheckStatusDefinition"]]:
        '''check_status_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#check_status_definition Dashboard#check_status_definition}
        '''
        result = self._values.get("check_status_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetCheckStatusDefinition"]], result)

    @builtins.property
    def distribution_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinition"]]:
        '''distribution_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#distribution_definition Dashboard#distribution_definition}
        '''
        result = self._values.get("distribution_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinition"]], result)

    @builtins.property
    def event_stream_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetEventStreamDefinition"]]:
        '''event_stream_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_stream_definition Dashboard#event_stream_definition}
        '''
        result = self._values.get("event_stream_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetEventStreamDefinition"]], result)

    @builtins.property
    def event_timeline_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetEventTimelineDefinition"]]:
        '''event_timeline_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_timeline_definition Dashboard#event_timeline_definition}
        '''
        result = self._values.get("event_timeline_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetEventTimelineDefinition"]], result)

    @builtins.property
    def free_text_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetFreeTextDefinition"]]:
        '''free_text_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#free_text_definition Dashboard#free_text_definition}
        '''
        result = self._values.get("free_text_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetFreeTextDefinition"]], result)

    @builtins.property
    def geomap_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinition"]]:
        '''geomap_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#geomap_definition Dashboard#geomap_definition}
        '''
        result = self._values.get("geomap_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinition"]], result)

    @builtins.property
    def group_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinition"]]:
        '''group_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_definition Dashboard#group_definition}
        '''
        result = self._values.get("group_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinition"]], result)

    @builtins.property
    def heatmap_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinition"]]:
        '''heatmap_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#heatmap_definition Dashboard#heatmap_definition}
        '''
        result = self._values.get("heatmap_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinition"]], result)

    @builtins.property
    def hostmap_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinition"]]:
        '''hostmap_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hostmap_definition Dashboard#hostmap_definition}
        '''
        result = self._values.get("hostmap_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinition"]], result)

    @builtins.property
    def iframe_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetIframeDefinition"]]:
        '''iframe_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#iframe_definition Dashboard#iframe_definition}
        '''
        result = self._values.get("iframe_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetIframeDefinition"]], result)

    @builtins.property
    def image_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetImageDefinition"]]:
        '''image_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_definition Dashboard#image_definition}
        '''
        result = self._values.get("image_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetImageDefinition"]], result)

    @builtins.property
    def log_stream_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetLogStreamDefinition"]]:
        '''log_stream_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_stream_definition Dashboard#log_stream_definition}
        '''
        result = self._values.get("log_stream_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetLogStreamDefinition"]], result)

    @builtins.property
    def manage_status_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetManageStatusDefinition"]]:
        '''manage_status_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#manage_status_definition Dashboard#manage_status_definition}
        '''
        result = self._values.get("manage_status_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetManageStatusDefinition"]], result)

    @builtins.property
    def note_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetNoteDefinition"]]:
        '''note_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#note_definition Dashboard#note_definition}
        '''
        result = self._values.get("note_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetNoteDefinition"]], result)

    @builtins.property
    def query_table_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinition"]]:
        '''query_table_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query_table_definition Dashboard#query_table_definition}
        '''
        result = self._values.get("query_table_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinition"]], result)

    @builtins.property
    def query_value_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinition"]]:
        '''query_value_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query_value_definition Dashboard#query_value_definition}
        '''
        result = self._values.get("query_value_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinition"]], result)

    @builtins.property
    def scatterplot_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinition"]]:
        '''scatterplot_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scatterplot_definition Dashboard#scatterplot_definition}
        '''
        result = self._values.get("scatterplot_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinition"]], result)

    @builtins.property
    def service_level_objective_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetServiceLevelObjectiveDefinition"]]:
        '''service_level_objective_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service_level_objective_definition Dashboard#service_level_objective_definition}
        '''
        result = self._values.get("service_level_objective_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetServiceLevelObjectiveDefinition"]], result)

    @builtins.property
    def servicemap_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetServicemapDefinition"]]:
        '''servicemap_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#servicemap_definition Dashboard#servicemap_definition}
        '''
        result = self._values.get("servicemap_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetServicemapDefinition"]], result)

    @builtins.property
    def timeseries_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinition"]]:
        '''timeseries_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeseries_definition Dashboard#timeseries_definition}
        '''
        result = self._values.get("timeseries_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinition"]], result)

    @builtins.property
    def toplist_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinition"]]:
        '''toplist_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#toplist_definition Dashboard#toplist_definition}
        '''
        result = self._values.get("toplist_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinition"]], result)

    @builtins.property
    def trace_service_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTraceServiceDefinition"]]:
        '''trace_service_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#trace_service_definition Dashboard#trace_service_definition}
        '''
        result = self._values.get("trace_service_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTraceServiceDefinition"]], result)

    @builtins.property
    def widget_layout(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetWidgetLayout"]]:
        '''widget_layout block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#widget_layout Dashboard#widget_layout}
        '''
        result = self._values.get("widget_layout")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetWidgetLayout"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidget(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetAlertGraphDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "alert_id": "alertId",
        "viz_type": "vizType",
        "live_span": "liveSpan",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetAlertGraphDefinition:
    def __init__(
        self,
        *,
        alert_id: builtins.str,
        viz_type: builtins.str,
        live_span: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alert_id: The ID of the monitor used by the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_id Dashboard#alert_id}
        :param viz_type: Type of visualization to use when displaying the widget. Valid values are ``timeseries``, ``toplist``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#viz_type Dashboard#viz_type}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "alert_id": alert_id,
            "viz_type": viz_type,
        }
        if live_span is not None:
            self._values["live_span"] = live_span
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def alert_id(self) -> builtins.str:
        '''The ID of the monitor used by the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_id Dashboard#alert_id}
        '''
        result = self._values.get("alert_id")
        assert result is not None, "Required property 'alert_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def viz_type(self) -> builtins.str:
        '''Type of visualization to use when displaying the widget. Valid values are ``timeseries``, ``toplist``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#viz_type Dashboard#viz_type}
        '''
        result = self._values.get("viz_type")
        assert result is not None, "Required property 'viz_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetAlertGraphDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetAlertValueDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "alert_id": "alertId",
        "precision": "precision",
        "text_align": "textAlign",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
        "unit": "unit",
    },
)
class DashboardWidgetAlertValueDefinition:
    def __init__(
        self,
        *,
        alert_id: builtins.str,
        precision: typing.Optional[jsii.Number] = None,
        text_align: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
        unit: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alert_id: The ID of the monitor used by the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_id Dashboard#alert_id}
        :param precision: The precision to use when displaying the value. Use ``*`` for maximum precision. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#precision Dashboard#precision}
        :param text_align: The alignment of the text in the widget. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        :param unit: The unit for the value displayed in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#unit Dashboard#unit}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "alert_id": alert_id,
        }
        if precision is not None:
            self._values["precision"] = precision
        if text_align is not None:
            self._values["text_align"] = text_align
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size
        if unit is not None:
            self._values["unit"] = unit

    @builtins.property
    def alert_id(self) -> builtins.str:
        '''The ID of the monitor used by the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_id Dashboard#alert_id}
        '''
        result = self._values.get("alert_id")
        assert result is not None, "Required property 'alert_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def precision(self) -> typing.Optional[jsii.Number]:
        '''The precision to use when displaying the value. Use ``*`` for maximum precision.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#precision Dashboard#precision}
        '''
        result = self._values.get("precision")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def text_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the text in the widget. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        '''
        result = self._values.get("text_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def unit(self) -> typing.Optional[builtins.str]:
        '''The unit for the value displayed in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#unit Dashboard#unit}
        '''
        result = self._values.get("unit")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetAlertValueDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "live_span": "liveSpan",
        "request": "request",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetChangeDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionCustomLink"]] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequest"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionCustomLink"]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequest"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetChangeDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "change_type": "changeType",
        "compare_to": "compareTo",
        "increase_good": "increaseGood",
        "log_query": "logQuery",
        "order_by": "orderBy",
        "order_dir": "orderDir",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
        "show_present": "showPresent",
    },
)
class DashboardWidgetChangeDefinitionRequest:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestApmQuery"]] = None,
        change_type: typing.Optional[builtins.str] = None,
        compare_to: typing.Optional[builtins.str] = None,
        increase_good: typing.Optional[builtins.bool] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestLogQuery"]] = None,
        order_by: typing.Optional[builtins.str] = None,
        order_dir: typing.Optional[builtins.str] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestSecurityQuery"]] = None,
        show_present: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param change_type: Whether to show absolute or relative change. Valid values are ``absolute``, ``relative``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#change_type Dashboard#change_type}
        :param compare_to: Choose from when to compare current data to. Valid values are ``hour_before``, ``day_before``, ``week_before``, ``month_before``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compare_to Dashboard#compare_to}
        :param increase_good: Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#increase_good Dashboard#increase_good}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param order_by: What to order by. Valid values are ``change``, ``name``, ``present``, ``past``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order_by Dashboard#order_by}
        :param order_dir: Widget sorting method. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order_dir Dashboard#order_dir}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        :param show_present: If set to ``true``, displays current value. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_present Dashboard#show_present}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if change_type is not None:
            self._values["change_type"] = change_type
        if compare_to is not None:
            self._values["compare_to"] = compare_to
        if increase_good is not None:
            self._values["increase_good"] = increase_good
        if log_query is not None:
            self._values["log_query"] = log_query
        if order_by is not None:
            self._values["order_by"] = order_by
        if order_dir is not None:
            self._values["order_dir"] = order_dir
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query
        if show_present is not None:
            self._values["show_present"] = show_present

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestApmQuery"]], result)

    @builtins.property
    def change_type(self) -> typing.Optional[builtins.str]:
        '''Whether to show absolute or relative change. Valid values are ``absolute``, ``relative``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#change_type Dashboard#change_type}
        '''
        result = self._values.get("change_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def compare_to(self) -> typing.Optional[builtins.str]:
        '''Choose from when to compare current data to. Valid values are ``hour_before``, ``day_before``, ``week_before``, ``month_before``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compare_to Dashboard#compare_to}
        '''
        result = self._values.get("compare_to")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def increase_good(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#increase_good Dashboard#increase_good}
        '''
        result = self._values.get("increase_good")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestLogQuery"]], result)

    @builtins.property
    def order_by(self) -> typing.Optional[builtins.str]:
        '''What to order by. Valid values are ``change``, ``name``, ``present``, ``past``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order_by Dashboard#order_by}
        '''
        result = self._values.get("order_by")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order_dir(self) -> typing.Optional[builtins.str]:
        '''Widget sorting method. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order_dir Dashboard#order_dir}
        '''
        result = self._values.get("order_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestSecurityQuery"]], result)

    @builtins.property
    def show_present(self) -> typing.Optional[builtins.bool]:
        '''If set to ``true``, displays current value.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_present Dashboard#show_present}
        '''
        result = self._values.get("show_present")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetChangeDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetChangeDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetChangeDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetChangeDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetChangeDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetChangeDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetChangeDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetChangeDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetCheckStatusDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "check": "check",
        "grouping": "grouping",
        "group": "group",
        "group_by": "groupBy",
        "live_span": "liveSpan",
        "tags": "tags",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetCheckStatusDefinition:
    def __init__(
        self,
        *,
        check: builtins.str,
        grouping: builtins.str,
        group: typing.Optional[builtins.str] = None,
        group_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        live_span: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param check: The check to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#check Dashboard#check}
        :param grouping: The kind of grouping to use. Valid values are ``check``, ``cluster``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#grouping Dashboard#grouping}
        :param group: The check group to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group Dashboard#group}
        :param group_by: When ``grouping = "cluster"``, indicates a list of tags to use for grouping. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param tags: List of tags to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags Dashboard#tags}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "check": check,
            "grouping": grouping,
        }
        if group is not None:
            self._values["group"] = group
        if group_by is not None:
            self._values["group_by"] = group_by
        if live_span is not None:
            self._values["live_span"] = live_span
        if tags is not None:
            self._values["tags"] = tags
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def check(self) -> builtins.str:
        '''The check to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#check Dashboard#check}
        '''
        result = self._values.get("check")
        assert result is not None, "Required property 'check' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def grouping(self) -> builtins.str:
        '''The kind of grouping to use. Valid values are ``check``, ``cluster``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#grouping Dashboard#grouping}
        '''
        result = self._values.get("grouping")
        assert result is not None, "Required property 'grouping' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group(self) -> typing.Optional[builtins.str]:
        '''The check group to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group Dashboard#group}
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def group_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''When ``grouping = "cluster"``, indicates a list of tags to use for grouping.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of tags to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags Dashboard#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetCheckStatusDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "legend_size": "legendSize",
        "live_span": "liveSpan",
        "request": "request",
        "show_legend": "showLegend",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetDistributionDefinition:
    def __init__(
        self,
        *,
        legend_size: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequest"]] = None,
        show_legend: typing.Optional[builtins.bool] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param legend_size: The size of the legend displayed in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param show_legend: Whether or not to show the legend on this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if legend_size is not None:
            self._values["legend_size"] = legend_size
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if show_legend is not None:
            self._values["show_legend"] = show_legend
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def legend_size(self) -> typing.Optional[builtins.str]:
        '''The size of the legend displayed in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        '''
        result = self._values.get("legend_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequest"]], result)

    @builtins.property
    def show_legend(self) -> typing.Optional[builtins.bool]:
        '''Whether or not to show the legend on this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        '''
        result = self._values.get("show_legend")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
        "style": "style",
    },
)
class DashboardWidgetDistributionDefinitionRequest:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestSecurityQuery"]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestStyle"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query
        if style is not None:
            self._values["style"] = style

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestSecurityQuery"]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestStyle"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetDistributionDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetDistributionDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetDistributionDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetDistributionDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetDistributionDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetDistributionDefinitionRequestStyle",
    jsii_struct_bases=[],
    name_mapping={"palette": "palette"},
)
class DashboardWidgetDistributionDefinitionRequestStyle:
    def __init__(self, *, palette: typing.Optional[builtins.str] = None) -> None:
        '''
        :param palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if palette is not None:
            self._values["palette"] = palette

    @builtins.property
    def palette(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetDistributionDefinitionRequestStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetEventStreamDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "query": "query",
        "event_size": "eventSize",
        "live_span": "liveSpan",
        "tags_execution": "tagsExecution",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetEventStreamDefinition:
    def __init__(
        self,
        *,
        query: builtins.str,
        event_size: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        tags_execution: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param query: The query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param event_size: The size to use to display an event. Valid values are ``s``, ``l``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_size Dashboard#event_size}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param tags_execution: The execution method for multi-value filters. Can be either ``and`` or ``or``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }
        if event_size is not None:
            self._values["event_size"] = event_size
        if live_span is not None:
            self._values["live_span"] = live_span
        if tags_execution is not None:
            self._values["tags_execution"] = tags_execution
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def query(self) -> builtins.str:
        '''The query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def event_size(self) -> typing.Optional[builtins.str]:
        '''The size to use to display an event. Valid values are ``s``, ``l``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_size Dashboard#event_size}
        '''
        result = self._values.get("event_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags_execution(self) -> typing.Optional[builtins.str]:
        '''The execution method for multi-value filters. Can be either ``and`` or ``or``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        result = self._values.get("tags_execution")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetEventStreamDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetEventTimelineDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "query": "query",
        "live_span": "liveSpan",
        "tags_execution": "tagsExecution",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetEventTimelineDefinition:
    def __init__(
        self,
        *,
        query: builtins.str,
        live_span: typing.Optional[builtins.str] = None,
        tags_execution: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param query: The query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param tags_execution: The execution method for multi-value filters. Can be either ``and`` or ``or``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }
        if live_span is not None:
            self._values["live_span"] = live_span
        if tags_execution is not None:
            self._values["tags_execution"] = tags_execution
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def query(self) -> builtins.str:
        '''The query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags_execution(self) -> typing.Optional[builtins.str]:
        '''The execution method for multi-value filters. Can be either ``and`` or ``or``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        result = self._values.get("tags_execution")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetEventTimelineDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetFreeTextDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "text": "text",
        "color": "color",
        "font_size": "fontSize",
        "text_align": "textAlign",
    },
)
class DashboardWidgetFreeTextDefinition:
    def __init__(
        self,
        *,
        text: builtins.str,
        color: typing.Optional[builtins.str] = None,
        font_size: typing.Optional[builtins.str] = None,
        text_align: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param text: The text to display in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text Dashboard#text}
        :param color: The color of the text in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color Dashboard#color}
        :param font_size: The size of the text in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#font_size Dashboard#font_size}
        :param text_align: The alignment of the text in the widget. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "text": text,
        }
        if color is not None:
            self._values["color"] = color
        if font_size is not None:
            self._values["font_size"] = font_size
        if text_align is not None:
            self._values["text_align"] = text_align

    @builtins.property
    def text(self) -> builtins.str:
        '''The text to display in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text Dashboard#text}
        '''
        result = self._values.get("text")
        assert result is not None, "Required property 'text' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def color(self) -> typing.Optional[builtins.str]:
        '''The color of the text in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color Dashboard#color}
        '''
        result = self._values.get("color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def font_size(self) -> typing.Optional[builtins.str]:
        '''The size of the text in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#font_size Dashboard#font_size}
        '''
        result = self._values.get("font_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def text_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the text in the widget. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        '''
        result = self._values.get("text_align")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetFreeTextDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "view": "view",
        "custom_link": "customLink",
        "live_span": "liveSpan",
        "request": "request",
        "style": "style",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGeomapDefinition:
    def __init__(
        self,
        *,
        view: typing.Sequence["DashboardWidgetGeomapDefinitionView"],
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionCustomLink"]] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequest"]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionStyle"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param view: view block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view Dashboard#view}
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "view": view,
        }
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if style is not None:
            self._values["style"] = style
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def view(self) -> typing.List["DashboardWidgetGeomapDefinitionView"]:
        '''view block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view Dashboard#view}
        '''
        result = self._values.get("view")
        assert result is not None, "Required property 'view' is missing"
        return typing.cast(typing.List["DashboardWidgetGeomapDefinitionView"], result)

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionCustomLink"]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequest"]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionStyle"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetGeomapDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "formula": "formula",
        "log_query": "logQuery",
        "q": "q",
        "query": "query",
        "rum_query": "rumQuery",
    },
)
class DashboardWidgetGeomapDefinitionRequest:
    def __init__(
        self,
        *,
        formula: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestFormula"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestLogQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        query: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestQuery"]] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestRumQuery"]] = None,
    ) -> None:
        '''
        :param formula: formula block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if formula is not None:
            self._values["formula"] = formula
        if log_query is not None:
            self._values["log_query"] = log_query
        if q is not None:
            self._values["q"] = q
        if query is not None:
            self._values["query"] = query
        if rum_query is not None:
            self._values["rum_query"] = rum_query

    @builtins.property
    def formula(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestFormula"]]:
        '''formula block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        '''
        result = self._values.get("formula")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestFormula"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestLogQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQuery"]]:
        '''query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQuery"]], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestRumQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestFormula",
    jsii_struct_bases=[],
    name_mapping={
        "formula_expression": "formulaExpression",
        "alias": "alias",
        "limit": "limit",
    },
)
class DashboardWidgetGeomapDefinitionRequestFormula:
    def __init__(
        self,
        *,
        formula_expression: builtins.str,
        alias: typing.Optional[builtins.str] = None,
        limit: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestFormulaLimit"]] = None,
    ) -> None:
        '''
        :param formula_expression: String expression built from queries, formulas and functions. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        :param alias: Expression alias. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param limit: limit block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "formula_expression": formula_expression,
        }
        if alias is not None:
            self._values["alias"] = alias
        if limit is not None:
            self._values["limit"] = limit

    @builtins.property
    def formula_expression(self) -> builtins.str:
        '''String expression built from queries, formulas and functions.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        '''
        result = self._values.get("formula_expression")
        assert result is not None, "Required property 'formula_expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''Expression alias.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestFormulaLimit"]]:
        '''limit block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestFormulaLimit"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestFormula(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestFormulaLimit",
    jsii_struct_bases=[],
    name_mapping={"count": "count", "order": "order"},
)
class DashboardWidgetGeomapDefinitionRequestFormulaLimit:
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: Number of results to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''Number of results to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestFormulaLimit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGeomapDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestQuery",
    jsii_struct_bases=[],
    name_mapping={
        "event_query": "eventQuery",
        "metric_query": "metricQuery",
        "process_query": "processQuery",
    },
)
class DashboardWidgetGeomapDefinitionRequestQuery:
    def __init__(
        self,
        *,
        event_query: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestQueryEventQuery"]] = None,
        metric_query: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestQueryMetricQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestQueryProcessQuery"]] = None,
    ) -> None:
        '''
        :param event_query: event_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        :param metric_query: metric_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if event_query is not None:
            self._values["event_query"] = event_query
        if metric_query is not None:
            self._values["metric_query"] = metric_query
        if process_query is not None:
            self._values["process_query"] = process_query

    @builtins.property
    def event_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryEventQuery"]]:
        '''event_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        '''
        result = self._values.get("event_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryEventQuery"]], result)

    @builtins.property
    def metric_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryMetricQuery"]]:
        '''metric_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        '''
        result = self._values.get("metric_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryMetricQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryProcessQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestQueryEventQuery",
    jsii_struct_bases=[],
    name_mapping={
        "compute": "compute",
        "data_source": "dataSource",
        "name": "name",
        "group_by": "groupBy",
        "indexes": "indexes",
        "search": "search",
    },
)
class DashboardWidgetGeomapDefinitionRequestQueryEventQuery:
    def __init__(
        self,
        *,
        compute: typing.Sequence["DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute"],
        data_source: builtins.str,
        name: builtins.str,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy"]] = None,
        indexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        search: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch"]] = None,
    ) -> None:
        '''
        :param compute: compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        :param data_source: Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param indexes: An array of index names to query in the stream. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        :param search: search block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "compute": compute,
            "data_source": data_source,
            "name": name,
        }
        if group_by is not None:
            self._values["group_by"] = group_by
        if indexes is not None:
            self._values["indexes"] = indexes
        if search is not None:
            self._values["search"] = search

    @builtins.property
    def compute(
        self,
    ) -> typing.List["DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute"]:
        '''compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        '''
        result = self._values.get("compute")
        assert result is not None, "Required property 'compute' is missing"
        return typing.cast(typing.List["DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute"], result)

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy"]], result)

    @builtins.property
    def indexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of index names to query in the stream.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        '''
        result = self._values.get("indexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def search(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch"]]:
        '''search block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        result = self._values.get("search")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestQueryEventQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "interval": "interval",
        "metric": "metric",
    },
)
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        interval: typing.Optional[jsii.Number] = None,
        metric: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param interval: A time interval in milliseconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        :param metric: Measurable attribute to compute. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if interval is not None:
            self._values["interval"] = interval
        if metric is not None:
            self._values["metric"] = metric

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''A time interval in milliseconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Measurable attribute to compute.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort": "sort"},
)
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy:
    def __init__(
        self,
        *,
        facet: builtins.str,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort"]] = None,
    ) -> None:
        '''
        :param facet: Event facet. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Number of groups to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: sort block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "facet": facet,
        }
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort

    @builtins.property
    def facet(self) -> builtins.str:
        '''Event facet.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        assert result is not None, "Required property 'facet' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of groups to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort"]]:
        '''sort block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "metric": "metric", "order": "order"},
)
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        metric: typing.Optional[builtins.str] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param metric: Metric used for sorting group by results. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if metric is not None:
            self._values["metric"] = metric
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric used for sorting group by results.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Events search string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Events search string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestQueryMetricQuery",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "query": "query",
        "aggregator": "aggregator",
        "data_source": "dataSource",
    },
)
class DashboardWidgetGeomapDefinitionRequestQueryMetricQuery:
    def __init__(
        self,
        *,
        name: builtins.str,
        query: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        data_source: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Name of the query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param query: Metrics query definition. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param data_source: Data source for metrics queries. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "query": query,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if data_source is not None:
            self._values["data_source"] = data_source

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''Metrics query definition.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def data_source(self) -> typing.Optional[builtins.str]:
        '''Data source for metrics queries.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestQueryMetricQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestQueryProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "data_source": "dataSource",
        "metric": "metric",
        "name": "name",
        "aggregator": "aggregator",
        "is_normalized_cpu": "isNormalizedCpu",
        "limit": "limit",
        "sort": "sort",
        "tag_filters": "tagFilters",
        "text_filter": "textFilter",
    },
)
class DashboardWidgetGeomapDefinitionRequestQueryProcessQuery:
    def __init__(
        self,
        *,
        data_source: builtins.str,
        metric: builtins.str,
        name: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        is_normalized_cpu: typing.Optional[builtins.bool] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[builtins.str] = None,
        tag_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
        text_filter: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param data_source: Data source for process queries. Valid values are ``process``, ``container``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param metric: Process metric name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param is_normalized_cpu: Whether to normalize the CPU percentages. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        :param limit: Number of hits to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param tag_filters: An array of tags to filter by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        :param text_filter: Text to use as filter. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "data_source": data_source,
            "metric": metric,
            "name": name,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if is_normalized_cpu is not None:
            self._values["is_normalized_cpu"] = is_normalized_cpu
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort
        if tag_filters is not None:
            self._values["tag_filters"] = tag_filters
        if text_filter is not None:
            self._values["text_filter"] = text_filter

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for process queries. Valid values are ``process``, ``container``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> builtins.str:
        '''Process metric name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_normalized_cpu(self) -> typing.Optional[builtins.bool]:
        '''Whether to normalize the CPU percentages.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        '''
        result = self._values.get("is_normalized_cpu")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of hits to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_filters(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of tags to filter by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        '''
        result = self._values.get("tag_filters")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def text_filter(self) -> typing.Optional[builtins.str]:
        '''Text to use as filter.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        result = self._values.get("text_filter")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestQueryProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGeomapDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionStyle",
    jsii_struct_bases=[],
    name_mapping={"palette": "palette", "palette_flip": "paletteFlip"},
)
class DashboardWidgetGeomapDefinitionStyle:
    def __init__(self, *, palette: builtins.str, palette_flip: builtins.bool) -> None:
        '''
        :param palette: The color palette to apply to the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        :param palette_flip: Boolean indicating whether to flip the palette tones. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette_flip Dashboard#palette_flip}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "palette": palette,
            "palette_flip": palette_flip,
        }

    @builtins.property
    def palette(self) -> builtins.str:
        '''The color palette to apply to the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        assert result is not None, "Required property 'palette' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def palette_flip(self) -> builtins.bool:
        '''Boolean indicating whether to flip the palette tones.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette_flip Dashboard#palette_flip}
        '''
        result = self._values.get("palette_flip")
        assert result is not None, "Required property 'palette_flip' is missing"
        return typing.cast(builtins.bool, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGeomapDefinitionView",
    jsii_struct_bases=[],
    name_mapping={"focus": "focus"},
)
class DashboardWidgetGeomapDefinitionView:
    def __init__(self, *, focus: builtins.str) -> None:
        '''
        :param focus: The 2-letter ISO code of a country to focus the map on. Or ``WORLD``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#focus Dashboard#focus}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "focus": focus,
        }

    @builtins.property
    def focus(self) -> builtins.str:
        '''The 2-letter ISO code of a country to focus the map on. Or ``WORLD``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#focus Dashboard#focus}
        '''
        result = self._values.get("focus")
        assert result is not None, "Required property 'focus' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGeomapDefinitionView(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "layout_type": "layoutType",
        "widget": "widget",
        "background_color": "backgroundColor",
        "banner_img": "bannerImg",
        "show_title": "showTitle",
        "title": "title",
    },
)
class DashboardWidgetGroupDefinition:
    def __init__(
        self,
        *,
        layout_type: builtins.str,
        widget: typing.Sequence["DashboardWidgetGroupDefinitionWidget"],
        background_color: typing.Optional[builtins.str] = None,
        banner_img: typing.Optional[builtins.str] = None,
        show_title: typing.Optional[builtins.bool] = None,
        title: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param layout_type: The layout type of the group. Valid values are ``ordered``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#layout_type Dashboard#layout_type}
        :param widget: widget block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#widget Dashboard#widget}
        :param background_color: Background color of the group title. One of ``vivid_blue``, ``vivid_purple``, ``vivid_pink``, ``vivid_orange``, ``vivid_yellow``, ``vivid_green``, ``blue``, ``purple``, ``pink``, ``orange``, ``yellow``, ``green``, ``gray`` or ``white`` Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#background_color Dashboard#background_color}
        :param banner_img: URL of image to display as a banner for the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#banner_img Dashboard#banner_img}
        :param show_title: Whether to show the title or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_title Dashboard#show_title}
        :param title: The title of the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "layout_type": layout_type,
            "widget": widget,
        }
        if background_color is not None:
            self._values["background_color"] = background_color
        if banner_img is not None:
            self._values["banner_img"] = banner_img
        if show_title is not None:
            self._values["show_title"] = show_title
        if title is not None:
            self._values["title"] = title

    @builtins.property
    def layout_type(self) -> builtins.str:
        '''The layout type of the group. Valid values are ``ordered``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#layout_type Dashboard#layout_type}
        '''
        result = self._values.get("layout_type")
        assert result is not None, "Required property 'layout_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def widget(self) -> typing.List["DashboardWidgetGroupDefinitionWidget"]:
        '''widget block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#widget Dashboard#widget}
        '''
        result = self._values.get("widget")
        assert result is not None, "Required property 'widget' is missing"
        return typing.cast(typing.List["DashboardWidgetGroupDefinitionWidget"], result)

    @builtins.property
    def background_color(self) -> typing.Optional[builtins.str]:
        '''Background color of the group title.

        One of ``vivid_blue``, ``vivid_purple``, ``vivid_pink``, ``vivid_orange``, ``vivid_yellow``, ``vivid_green``, ``blue``, ``purple``, ``pink``, ``orange``, ``yellow``, ``green``, ``gray`` or ``white``

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#background_color Dashboard#background_color}
        '''
        result = self._values.get("background_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def banner_img(self) -> typing.Optional[builtins.str]:
        '''URL of image to display as a banner for the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#banner_img Dashboard#banner_img}
        '''
        result = self._values.get("banner_img")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def show_title(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the title or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_title Dashboard#show_title}
        '''
        result = self._values.get("show_title")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidget",
    jsii_struct_bases=[],
    name_mapping={
        "alert_graph_definition": "alertGraphDefinition",
        "alert_value_definition": "alertValueDefinition",
        "change_definition": "changeDefinition",
        "check_status_definition": "checkStatusDefinition",
        "distribution_definition": "distributionDefinition",
        "event_stream_definition": "eventStreamDefinition",
        "event_timeline_definition": "eventTimelineDefinition",
        "free_text_definition": "freeTextDefinition",
        "geomap_definition": "geomapDefinition",
        "heatmap_definition": "heatmapDefinition",
        "hostmap_definition": "hostmapDefinition",
        "iframe_definition": "iframeDefinition",
        "image_definition": "imageDefinition",
        "log_stream_definition": "logStreamDefinition",
        "manage_status_definition": "manageStatusDefinition",
        "note_definition": "noteDefinition",
        "query_table_definition": "queryTableDefinition",
        "query_value_definition": "queryValueDefinition",
        "scatterplot_definition": "scatterplotDefinition",
        "service_level_objective_definition": "serviceLevelObjectiveDefinition",
        "servicemap_definition": "servicemapDefinition",
        "timeseries_definition": "timeseriesDefinition",
        "toplist_definition": "toplistDefinition",
        "trace_service_definition": "traceServiceDefinition",
        "widget_layout": "widgetLayout",
    },
)
class DashboardWidgetGroupDefinitionWidget:
    def __init__(
        self,
        *,
        alert_graph_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition"]] = None,
        alert_value_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetAlertValueDefinition"]] = None,
        change_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinition"]] = None,
        check_status_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition"]] = None,
        distribution_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinition"]] = None,
        event_stream_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetEventStreamDefinition"]] = None,
        event_timeline_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition"]] = None,
        free_text_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetFreeTextDefinition"]] = None,
        geomap_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinition"]] = None,
        heatmap_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinition"]] = None,
        hostmap_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinition"]] = None,
        iframe_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetIframeDefinition"]] = None,
        image_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetImageDefinition"]] = None,
        log_stream_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetLogStreamDefinition"]] = None,
        manage_status_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetManageStatusDefinition"]] = None,
        note_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetNoteDefinition"]] = None,
        query_table_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinition"]] = None,
        query_value_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinition"]] = None,
        scatterplot_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinition"]] = None,
        service_level_objective_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition"]] = None,
        servicemap_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetServicemapDefinition"]] = None,
        timeseries_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition"]] = None,
        toplist_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinition"]] = None,
        trace_service_definition: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition"]] = None,
        widget_layout: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetWidgetLayout"]] = None,
    ) -> None:
        '''
        :param alert_graph_definition: alert_graph_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_graph_definition Dashboard#alert_graph_definition}
        :param alert_value_definition: alert_value_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_value_definition Dashboard#alert_value_definition}
        :param change_definition: change_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#change_definition Dashboard#change_definition}
        :param check_status_definition: check_status_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#check_status_definition Dashboard#check_status_definition}
        :param distribution_definition: distribution_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#distribution_definition Dashboard#distribution_definition}
        :param event_stream_definition: event_stream_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_stream_definition Dashboard#event_stream_definition}
        :param event_timeline_definition: event_timeline_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_timeline_definition Dashboard#event_timeline_definition}
        :param free_text_definition: free_text_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#free_text_definition Dashboard#free_text_definition}
        :param geomap_definition: geomap_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#geomap_definition Dashboard#geomap_definition}
        :param heatmap_definition: heatmap_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#heatmap_definition Dashboard#heatmap_definition}
        :param hostmap_definition: hostmap_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hostmap_definition Dashboard#hostmap_definition}
        :param iframe_definition: iframe_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#iframe_definition Dashboard#iframe_definition}
        :param image_definition: image_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_definition Dashboard#image_definition}
        :param log_stream_definition: log_stream_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_stream_definition Dashboard#log_stream_definition}
        :param manage_status_definition: manage_status_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#manage_status_definition Dashboard#manage_status_definition}
        :param note_definition: note_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#note_definition Dashboard#note_definition}
        :param query_table_definition: query_table_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query_table_definition Dashboard#query_table_definition}
        :param query_value_definition: query_value_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query_value_definition Dashboard#query_value_definition}
        :param scatterplot_definition: scatterplot_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scatterplot_definition Dashboard#scatterplot_definition}
        :param service_level_objective_definition: service_level_objective_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service_level_objective_definition Dashboard#service_level_objective_definition}
        :param servicemap_definition: servicemap_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#servicemap_definition Dashboard#servicemap_definition}
        :param timeseries_definition: timeseries_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeseries_definition Dashboard#timeseries_definition}
        :param toplist_definition: toplist_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#toplist_definition Dashboard#toplist_definition}
        :param trace_service_definition: trace_service_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#trace_service_definition Dashboard#trace_service_definition}
        :param widget_layout: widget_layout block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#widget_layout Dashboard#widget_layout}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if alert_graph_definition is not None:
            self._values["alert_graph_definition"] = alert_graph_definition
        if alert_value_definition is not None:
            self._values["alert_value_definition"] = alert_value_definition
        if change_definition is not None:
            self._values["change_definition"] = change_definition
        if check_status_definition is not None:
            self._values["check_status_definition"] = check_status_definition
        if distribution_definition is not None:
            self._values["distribution_definition"] = distribution_definition
        if event_stream_definition is not None:
            self._values["event_stream_definition"] = event_stream_definition
        if event_timeline_definition is not None:
            self._values["event_timeline_definition"] = event_timeline_definition
        if free_text_definition is not None:
            self._values["free_text_definition"] = free_text_definition
        if geomap_definition is not None:
            self._values["geomap_definition"] = geomap_definition
        if heatmap_definition is not None:
            self._values["heatmap_definition"] = heatmap_definition
        if hostmap_definition is not None:
            self._values["hostmap_definition"] = hostmap_definition
        if iframe_definition is not None:
            self._values["iframe_definition"] = iframe_definition
        if image_definition is not None:
            self._values["image_definition"] = image_definition
        if log_stream_definition is not None:
            self._values["log_stream_definition"] = log_stream_definition
        if manage_status_definition is not None:
            self._values["manage_status_definition"] = manage_status_definition
        if note_definition is not None:
            self._values["note_definition"] = note_definition
        if query_table_definition is not None:
            self._values["query_table_definition"] = query_table_definition
        if query_value_definition is not None:
            self._values["query_value_definition"] = query_value_definition
        if scatterplot_definition is not None:
            self._values["scatterplot_definition"] = scatterplot_definition
        if service_level_objective_definition is not None:
            self._values["service_level_objective_definition"] = service_level_objective_definition
        if servicemap_definition is not None:
            self._values["servicemap_definition"] = servicemap_definition
        if timeseries_definition is not None:
            self._values["timeseries_definition"] = timeseries_definition
        if toplist_definition is not None:
            self._values["toplist_definition"] = toplist_definition
        if trace_service_definition is not None:
            self._values["trace_service_definition"] = trace_service_definition
        if widget_layout is not None:
            self._values["widget_layout"] = widget_layout

    @builtins.property
    def alert_graph_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition"]]:
        '''alert_graph_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_graph_definition Dashboard#alert_graph_definition}
        '''
        result = self._values.get("alert_graph_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition"]], result)

    @builtins.property
    def alert_value_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetAlertValueDefinition"]]:
        '''alert_value_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_value_definition Dashboard#alert_value_definition}
        '''
        result = self._values.get("alert_value_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetAlertValueDefinition"]], result)

    @builtins.property
    def change_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinition"]]:
        '''change_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#change_definition Dashboard#change_definition}
        '''
        result = self._values.get("change_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinition"]], result)

    @builtins.property
    def check_status_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition"]]:
        '''check_status_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#check_status_definition Dashboard#check_status_definition}
        '''
        result = self._values.get("check_status_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition"]], result)

    @builtins.property
    def distribution_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinition"]]:
        '''distribution_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#distribution_definition Dashboard#distribution_definition}
        '''
        result = self._values.get("distribution_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinition"]], result)

    @builtins.property
    def event_stream_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetEventStreamDefinition"]]:
        '''event_stream_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_stream_definition Dashboard#event_stream_definition}
        '''
        result = self._values.get("event_stream_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetEventStreamDefinition"]], result)

    @builtins.property
    def event_timeline_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition"]]:
        '''event_timeline_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_timeline_definition Dashboard#event_timeline_definition}
        '''
        result = self._values.get("event_timeline_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition"]], result)

    @builtins.property
    def free_text_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetFreeTextDefinition"]]:
        '''free_text_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#free_text_definition Dashboard#free_text_definition}
        '''
        result = self._values.get("free_text_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetFreeTextDefinition"]], result)

    @builtins.property
    def geomap_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinition"]]:
        '''geomap_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#geomap_definition Dashboard#geomap_definition}
        '''
        result = self._values.get("geomap_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinition"]], result)

    @builtins.property
    def heatmap_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinition"]]:
        '''heatmap_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#heatmap_definition Dashboard#heatmap_definition}
        '''
        result = self._values.get("heatmap_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinition"]], result)

    @builtins.property
    def hostmap_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinition"]]:
        '''hostmap_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hostmap_definition Dashboard#hostmap_definition}
        '''
        result = self._values.get("hostmap_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinition"]], result)

    @builtins.property
    def iframe_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetIframeDefinition"]]:
        '''iframe_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#iframe_definition Dashboard#iframe_definition}
        '''
        result = self._values.get("iframe_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetIframeDefinition"]], result)

    @builtins.property
    def image_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetImageDefinition"]]:
        '''image_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_definition Dashboard#image_definition}
        '''
        result = self._values.get("image_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetImageDefinition"]], result)

    @builtins.property
    def log_stream_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetLogStreamDefinition"]]:
        '''log_stream_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_stream_definition Dashboard#log_stream_definition}
        '''
        result = self._values.get("log_stream_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetLogStreamDefinition"]], result)

    @builtins.property
    def manage_status_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetManageStatusDefinition"]]:
        '''manage_status_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#manage_status_definition Dashboard#manage_status_definition}
        '''
        result = self._values.get("manage_status_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetManageStatusDefinition"]], result)

    @builtins.property
    def note_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetNoteDefinition"]]:
        '''note_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#note_definition Dashboard#note_definition}
        '''
        result = self._values.get("note_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetNoteDefinition"]], result)

    @builtins.property
    def query_table_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinition"]]:
        '''query_table_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query_table_definition Dashboard#query_table_definition}
        '''
        result = self._values.get("query_table_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinition"]], result)

    @builtins.property
    def query_value_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinition"]]:
        '''query_value_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query_value_definition Dashboard#query_value_definition}
        '''
        result = self._values.get("query_value_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinition"]], result)

    @builtins.property
    def scatterplot_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinition"]]:
        '''scatterplot_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scatterplot_definition Dashboard#scatterplot_definition}
        '''
        result = self._values.get("scatterplot_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinition"]], result)

    @builtins.property
    def service_level_objective_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition"]]:
        '''service_level_objective_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service_level_objective_definition Dashboard#service_level_objective_definition}
        '''
        result = self._values.get("service_level_objective_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition"]], result)

    @builtins.property
    def servicemap_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetServicemapDefinition"]]:
        '''servicemap_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#servicemap_definition Dashboard#servicemap_definition}
        '''
        result = self._values.get("servicemap_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetServicemapDefinition"]], result)

    @builtins.property
    def timeseries_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition"]]:
        '''timeseries_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeseries_definition Dashboard#timeseries_definition}
        '''
        result = self._values.get("timeseries_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition"]], result)

    @builtins.property
    def toplist_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinition"]]:
        '''toplist_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#toplist_definition Dashboard#toplist_definition}
        '''
        result = self._values.get("toplist_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinition"]], result)

    @builtins.property
    def trace_service_definition(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition"]]:
        '''trace_service_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#trace_service_definition Dashboard#trace_service_definition}
        '''
        result = self._values.get("trace_service_definition")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition"]], result)

    @builtins.property
    def widget_layout(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetWidgetLayout"]]:
        '''widget_layout block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#widget_layout Dashboard#widget_layout}
        '''
        result = self._values.get("widget_layout")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetWidgetLayout"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidget(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "alert_id": "alertId",
        "viz_type": "vizType",
        "live_span": "liveSpan",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition:
    def __init__(
        self,
        *,
        alert_id: builtins.str,
        viz_type: builtins.str,
        live_span: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alert_id: The ID of the monitor used by the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_id Dashboard#alert_id}
        :param viz_type: Type of visualization to use when displaying the widget. Valid values are ``timeseries``, ``toplist``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#viz_type Dashboard#viz_type}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "alert_id": alert_id,
            "viz_type": viz_type,
        }
        if live_span is not None:
            self._values["live_span"] = live_span
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def alert_id(self) -> builtins.str:
        '''The ID of the monitor used by the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_id Dashboard#alert_id}
        '''
        result = self._values.get("alert_id")
        assert result is not None, "Required property 'alert_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def viz_type(self) -> builtins.str:
        '''Type of visualization to use when displaying the widget. Valid values are ``timeseries``, ``toplist``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#viz_type Dashboard#viz_type}
        '''
        result = self._values.get("viz_type")
        assert result is not None, "Required property 'viz_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetAlertValueDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "alert_id": "alertId",
        "precision": "precision",
        "text_align": "textAlign",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
        "unit": "unit",
    },
)
class DashboardWidgetGroupDefinitionWidgetAlertValueDefinition:
    def __init__(
        self,
        *,
        alert_id: builtins.str,
        precision: typing.Optional[jsii.Number] = None,
        text_align: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
        unit: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alert_id: The ID of the monitor used by the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_id Dashboard#alert_id}
        :param precision: The precision to use when displaying the value. Use ``*`` for maximum precision. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#precision Dashboard#precision}
        :param text_align: The alignment of the text in the widget. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        :param unit: The unit for the value displayed in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#unit Dashboard#unit}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "alert_id": alert_id,
        }
        if precision is not None:
            self._values["precision"] = precision
        if text_align is not None:
            self._values["text_align"] = text_align
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size
        if unit is not None:
            self._values["unit"] = unit

    @builtins.property
    def alert_id(self) -> builtins.str:
        '''The ID of the monitor used by the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alert_id Dashboard#alert_id}
        '''
        result = self._values.get("alert_id")
        assert result is not None, "Required property 'alert_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def precision(self) -> typing.Optional[jsii.Number]:
        '''The precision to use when displaying the value. Use ``*`` for maximum precision.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#precision Dashboard#precision}
        '''
        result = self._values.get("precision")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def text_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the text in the widget. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        '''
        result = self._values.get("text_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def unit(self) -> typing.Optional[builtins.str]:
        '''The unit for the value displayed in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#unit Dashboard#unit}
        '''
        result = self._values.get("unit")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetAlertValueDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "live_span": "liveSpan",
        "request": "request",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink"]] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink"]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "change_type": "changeType",
        "compare_to": "compareTo",
        "increase_good": "increaseGood",
        "log_query": "logQuery",
        "order_by": "orderBy",
        "order_dir": "orderDir",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
        "show_present": "showPresent",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery"]] = None,
        change_type: typing.Optional[builtins.str] = None,
        compare_to: typing.Optional[builtins.str] = None,
        increase_good: typing.Optional[builtins.bool] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery"]] = None,
        order_by: typing.Optional[builtins.str] = None,
        order_dir: typing.Optional[builtins.str] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery"]] = None,
        show_present: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param change_type: Whether to show absolute or relative change. Valid values are ``absolute``, ``relative``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#change_type Dashboard#change_type}
        :param compare_to: Choose from when to compare current data to. Valid values are ``hour_before``, ``day_before``, ``week_before``, ``month_before``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compare_to Dashboard#compare_to}
        :param increase_good: Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#increase_good Dashboard#increase_good}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param order_by: What to order by. Valid values are ``change``, ``name``, ``present``, ``past``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order_by Dashboard#order_by}
        :param order_dir: Widget sorting method. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order_dir Dashboard#order_dir}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        :param show_present: If set to ``true``, displays current value. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_present Dashboard#show_present}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if change_type is not None:
            self._values["change_type"] = change_type
        if compare_to is not None:
            self._values["compare_to"] = compare_to
        if increase_good is not None:
            self._values["increase_good"] = increase_good
        if log_query is not None:
            self._values["log_query"] = log_query
        if order_by is not None:
            self._values["order_by"] = order_by
        if order_dir is not None:
            self._values["order_dir"] = order_dir
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query
        if show_present is not None:
            self._values["show_present"] = show_present

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery"]], result)

    @builtins.property
    def change_type(self) -> typing.Optional[builtins.str]:
        '''Whether to show absolute or relative change. Valid values are ``absolute``, ``relative``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#change_type Dashboard#change_type}
        '''
        result = self._values.get("change_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def compare_to(self) -> typing.Optional[builtins.str]:
        '''Choose from when to compare current data to. Valid values are ``hour_before``, ``day_before``, ``week_before``, ``month_before``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compare_to Dashboard#compare_to}
        '''
        result = self._values.get("compare_to")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def increase_good(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether an increase in the value is good (thus displayed in green) or not (thus displayed in red).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#increase_good Dashboard#increase_good}
        '''
        result = self._values.get("increase_good")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery"]], result)

    @builtins.property
    def order_by(self) -> typing.Optional[builtins.str]:
        '''What to order by. Valid values are ``change``, ``name``, ``present``, ``past``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order_by Dashboard#order_by}
        '''
        result = self._values.get("order_by")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order_dir(self) -> typing.Optional[builtins.str]:
        '''Widget sorting method. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order_dir Dashboard#order_dir}
        '''
        result = self._values.get("order_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery"]], result)

    @builtins.property
    def show_present(self) -> typing.Optional[builtins.bool]:
        '''If set to ``true``, displays current value.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_present Dashboard#show_present}
        '''
        result = self._values.get("show_present")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "check": "check",
        "grouping": "grouping",
        "group": "group",
        "group_by": "groupBy",
        "live_span": "liveSpan",
        "tags": "tags",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition:
    def __init__(
        self,
        *,
        check: builtins.str,
        grouping: builtins.str,
        group: typing.Optional[builtins.str] = None,
        group_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        live_span: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param check: The check to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#check Dashboard#check}
        :param grouping: The kind of grouping to use. Valid values are ``check``, ``cluster``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#grouping Dashboard#grouping}
        :param group: The check group to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group Dashboard#group}
        :param group_by: When ``grouping = "cluster"``, indicates a list of tags to use for grouping. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param tags: List of tags to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags Dashboard#tags}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "check": check,
            "grouping": grouping,
        }
        if group is not None:
            self._values["group"] = group
        if group_by is not None:
            self._values["group_by"] = group_by
        if live_span is not None:
            self._values["live_span"] = live_span
        if tags is not None:
            self._values["tags"] = tags
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def check(self) -> builtins.str:
        '''The check to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#check Dashboard#check}
        '''
        result = self._values.get("check")
        assert result is not None, "Required property 'check' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def grouping(self) -> builtins.str:
        '''The kind of grouping to use. Valid values are ``check``, ``cluster``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#grouping Dashboard#grouping}
        '''
        result = self._values.get("grouping")
        assert result is not None, "Required property 'grouping' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group(self) -> typing.Optional[builtins.str]:
        '''The check group to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group Dashboard#group}
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def group_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''When ``grouping = "cluster"``, indicates a list of tags to use for grouping.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of tags to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags Dashboard#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "legend_size": "legendSize",
        "live_span": "liveSpan",
        "request": "request",
        "show_legend": "showLegend",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinition:
    def __init__(
        self,
        *,
        legend_size: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest"]] = None,
        show_legend: typing.Optional[builtins.bool] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param legend_size: The size of the legend displayed in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param show_legend: Whether or not to show the legend on this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if legend_size is not None:
            self._values["legend_size"] = legend_size
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if show_legend is not None:
            self._values["show_legend"] = show_legend
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def legend_size(self) -> typing.Optional[builtins.str]:
        '''The size of the legend displayed in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        '''
        result = self._values.get("legend_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest"]], result)

    @builtins.property
    def show_legend(self) -> typing.Optional[builtins.bool]:
        '''Whether or not to show the legend on this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        '''
        result = self._values.get("show_legend")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
        "style": "style",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery"]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query
        if style is not None:
            self._values["style"] = style

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery"]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle",
    jsii_struct_bases=[],
    name_mapping={"palette": "palette"},
)
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle:
    def __init__(self, *, palette: typing.Optional[builtins.str] = None) -> None:
        '''
        :param palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if palette is not None:
            self._values["palette"] = palette

    @builtins.property
    def palette(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetEventStreamDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "query": "query",
        "event_size": "eventSize",
        "live_span": "liveSpan",
        "tags_execution": "tagsExecution",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetEventStreamDefinition:
    def __init__(
        self,
        *,
        query: builtins.str,
        event_size: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        tags_execution: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param query: The query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param event_size: The size to use to display an event. Valid values are ``s``, ``l``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_size Dashboard#event_size}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param tags_execution: The execution method for multi-value filters. Can be either ``and`` or ``or``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }
        if event_size is not None:
            self._values["event_size"] = event_size
        if live_span is not None:
            self._values["live_span"] = live_span
        if tags_execution is not None:
            self._values["tags_execution"] = tags_execution
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def query(self) -> builtins.str:
        '''The query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def event_size(self) -> typing.Optional[builtins.str]:
        '''The size to use to display an event. Valid values are ``s``, ``l``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_size Dashboard#event_size}
        '''
        result = self._values.get("event_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags_execution(self) -> typing.Optional[builtins.str]:
        '''The execution method for multi-value filters. Can be either ``and`` or ``or``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        result = self._values.get("tags_execution")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetEventStreamDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "query": "query",
        "live_span": "liveSpan",
        "tags_execution": "tagsExecution",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition:
    def __init__(
        self,
        *,
        query: builtins.str,
        live_span: typing.Optional[builtins.str] = None,
        tags_execution: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param query: The query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param tags_execution: The execution method for multi-value filters. Can be either ``and`` or ``or``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }
        if live_span is not None:
            self._values["live_span"] = live_span
        if tags_execution is not None:
            self._values["tags_execution"] = tags_execution
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def query(self) -> builtins.str:
        '''The query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags_execution(self) -> typing.Optional[builtins.str]:
        '''The execution method for multi-value filters. Can be either ``and`` or ``or``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        result = self._values.get("tags_execution")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetFreeTextDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "text": "text",
        "color": "color",
        "font_size": "fontSize",
        "text_align": "textAlign",
    },
)
class DashboardWidgetGroupDefinitionWidgetFreeTextDefinition:
    def __init__(
        self,
        *,
        text: builtins.str,
        color: typing.Optional[builtins.str] = None,
        font_size: typing.Optional[builtins.str] = None,
        text_align: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param text: The text to display in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text Dashboard#text}
        :param color: The color of the text in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color Dashboard#color}
        :param font_size: The size of the text in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#font_size Dashboard#font_size}
        :param text_align: The alignment of the text in the widget. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "text": text,
        }
        if color is not None:
            self._values["color"] = color
        if font_size is not None:
            self._values["font_size"] = font_size
        if text_align is not None:
            self._values["text_align"] = text_align

    @builtins.property
    def text(self) -> builtins.str:
        '''The text to display in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text Dashboard#text}
        '''
        result = self._values.get("text")
        assert result is not None, "Required property 'text' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def color(self) -> typing.Optional[builtins.str]:
        '''The color of the text in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color Dashboard#color}
        '''
        result = self._values.get("color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def font_size(self) -> typing.Optional[builtins.str]:
        '''The size of the text in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#font_size Dashboard#font_size}
        '''
        result = self._values.get("font_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def text_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the text in the widget. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        '''
        result = self._values.get("text_align")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetFreeTextDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "view": "view",
        "custom_link": "customLink",
        "live_span": "liveSpan",
        "request": "request",
        "style": "style",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinition:
    def __init__(
        self,
        *,
        view: typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView"],
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink"]] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest"]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param view: view block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view Dashboard#view}
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "view": view,
        }
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if style is not None:
            self._values["style"] = style
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def view(
        self,
    ) -> typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView"]:
        '''view block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view Dashboard#view}
        '''
        result = self._values.get("view")
        assert result is not None, "Required property 'view' is missing"
        return typing.cast(typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView"], result)

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink"]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest"]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "formula": "formula",
        "log_query": "logQuery",
        "q": "q",
        "query": "query",
        "rum_query": "rumQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest:
    def __init__(
        self,
        *,
        formula: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery"]] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery"]] = None,
    ) -> None:
        '''
        :param formula: formula block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if formula is not None:
            self._values["formula"] = formula
        if log_query is not None:
            self._values["log_query"] = log_query
        if q is not None:
            self._values["q"] = q
        if query is not None:
            self._values["query"] = query
        if rum_query is not None:
            self._values["rum_query"] = rum_query

    @builtins.property
    def formula(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula"]]:
        '''formula block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        '''
        result = self._values.get("formula")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery"]]:
        '''query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery"]], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula",
    jsii_struct_bases=[],
    name_mapping={
        "formula_expression": "formulaExpression",
        "alias": "alias",
        "limit": "limit",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula:
    def __init__(
        self,
        *,
        formula_expression: builtins.str,
        alias: typing.Optional[builtins.str] = None,
        limit: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit"]] = None,
    ) -> None:
        '''
        :param formula_expression: String expression built from queries, formulas and functions. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        :param alias: Expression alias. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param limit: limit block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "formula_expression": formula_expression,
        }
        if alias is not None:
            self._values["alias"] = alias
        if limit is not None:
            self._values["limit"] = limit

    @builtins.property
    def formula_expression(self) -> builtins.str:
        '''String expression built from queries, formulas and functions.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        '''
        result = self._values.get("formula_expression")
        assert result is not None, "Required property 'formula_expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''Expression alias.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit"]]:
        '''limit block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit",
    jsii_struct_bases=[],
    name_mapping={"count": "count", "order": "order"},
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit:
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: Number of results to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''Number of results to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery",
    jsii_struct_bases=[],
    name_mapping={
        "event_query": "eventQuery",
        "metric_query": "metricQuery",
        "process_query": "processQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery:
    def __init__(
        self,
        *,
        event_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery"]] = None,
        metric_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery"]] = None,
    ) -> None:
        '''
        :param event_query: event_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        :param metric_query: metric_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if event_query is not None:
            self._values["event_query"] = event_query
        if metric_query is not None:
            self._values["metric_query"] = metric_query
        if process_query is not None:
            self._values["process_query"] = process_query

    @builtins.property
    def event_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery"]]:
        '''event_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        '''
        result = self._values.get("event_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery"]], result)

    @builtins.property
    def metric_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery"]]:
        '''metric_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        '''
        result = self._values.get("metric_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery",
    jsii_struct_bases=[],
    name_mapping={
        "compute": "compute",
        "data_source": "dataSource",
        "name": "name",
        "group_by": "groupBy",
        "indexes": "indexes",
        "search": "search",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery:
    def __init__(
        self,
        *,
        compute: typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute"],
        data_source: builtins.str,
        name: builtins.str,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy"]] = None,
        indexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        search: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch"]] = None,
    ) -> None:
        '''
        :param compute: compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        :param data_source: Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param indexes: An array of index names to query in the stream. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        :param search: search block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "compute": compute,
            "data_source": data_source,
            "name": name,
        }
        if group_by is not None:
            self._values["group_by"] = group_by
        if indexes is not None:
            self._values["indexes"] = indexes
        if search is not None:
            self._values["search"] = search

    @builtins.property
    def compute(
        self,
    ) -> typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute"]:
        '''compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        '''
        result = self._values.get("compute")
        assert result is not None, "Required property 'compute' is missing"
        return typing.cast(typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute"], result)

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy"]], result)

    @builtins.property
    def indexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of index names to query in the stream.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        '''
        result = self._values.get("indexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def search(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch"]]:
        '''search block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        result = self._values.get("search")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "interval": "interval",
        "metric": "metric",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        interval: typing.Optional[jsii.Number] = None,
        metric: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param interval: A time interval in milliseconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        :param metric: Measurable attribute to compute. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if interval is not None:
            self._values["interval"] = interval
        if metric is not None:
            self._values["metric"] = metric

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''A time interval in milliseconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Measurable attribute to compute.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort": "sort"},
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy:
    def __init__(
        self,
        *,
        facet: builtins.str,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort"]] = None,
    ) -> None:
        '''
        :param facet: Event facet. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Number of groups to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: sort block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "facet": facet,
        }
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort

    @builtins.property
    def facet(self) -> builtins.str:
        '''Event facet.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        assert result is not None, "Required property 'facet' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of groups to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort"]]:
        '''sort block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "metric": "metric", "order": "order"},
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        metric: typing.Optional[builtins.str] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param metric: Metric used for sorting group by results. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if metric is not None:
            self._values["metric"] = metric
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric used for sorting group by results.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Events search string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Events search string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "query": "query",
        "aggregator": "aggregator",
        "data_source": "dataSource",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery:
    def __init__(
        self,
        *,
        name: builtins.str,
        query: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        data_source: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Name of the query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param query: Metrics query definition. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param data_source: Data source for metrics queries. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "query": query,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if data_source is not None:
            self._values["data_source"] = data_source

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''Metrics query definition.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def data_source(self) -> typing.Optional[builtins.str]:
        '''Data source for metrics queries.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "data_source": "dataSource",
        "metric": "metric",
        "name": "name",
        "aggregator": "aggregator",
        "is_normalized_cpu": "isNormalizedCpu",
        "limit": "limit",
        "sort": "sort",
        "tag_filters": "tagFilters",
        "text_filter": "textFilter",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery:
    def __init__(
        self,
        *,
        data_source: builtins.str,
        metric: builtins.str,
        name: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        is_normalized_cpu: typing.Optional[builtins.bool] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[builtins.str] = None,
        tag_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
        text_filter: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param data_source: Data source for process queries. Valid values are ``process``, ``container``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param metric: Process metric name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param is_normalized_cpu: Whether to normalize the CPU percentages. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        :param limit: Number of hits to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param tag_filters: An array of tags to filter by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        :param text_filter: Text to use as filter. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "data_source": data_source,
            "metric": metric,
            "name": name,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if is_normalized_cpu is not None:
            self._values["is_normalized_cpu"] = is_normalized_cpu
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort
        if tag_filters is not None:
            self._values["tag_filters"] = tag_filters
        if text_filter is not None:
            self._values["text_filter"] = text_filter

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for process queries. Valid values are ``process``, ``container``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> builtins.str:
        '''Process metric name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_normalized_cpu(self) -> typing.Optional[builtins.bool]:
        '''Whether to normalize the CPU percentages.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        '''
        result = self._values.get("is_normalized_cpu")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of hits to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_filters(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of tags to filter by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        '''
        result = self._values.get("tag_filters")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def text_filter(self) -> typing.Optional[builtins.str]:
        '''Text to use as filter.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        result = self._values.get("text_filter")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle",
    jsii_struct_bases=[],
    name_mapping={"palette": "palette", "palette_flip": "paletteFlip"},
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle:
    def __init__(self, *, palette: builtins.str, palette_flip: builtins.bool) -> None:
        '''
        :param palette: The color palette to apply to the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        :param palette_flip: Boolean indicating whether to flip the palette tones. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette_flip Dashboard#palette_flip}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "palette": palette,
            "palette_flip": palette_flip,
        }

    @builtins.property
    def palette(self) -> builtins.str:
        '''The color palette to apply to the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        assert result is not None, "Required property 'palette' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def palette_flip(self) -> builtins.bool:
        '''Boolean indicating whether to flip the palette tones.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette_flip Dashboard#palette_flip}
        '''
        result = self._values.get("palette_flip")
        assert result is not None, "Required property 'palette_flip' is missing"
        return typing.cast(builtins.bool, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView",
    jsii_struct_bases=[],
    name_mapping={"focus": "focus"},
)
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView:
    def __init__(self, *, focus: builtins.str) -> None:
        '''
        :param focus: The 2-letter ISO code of a country to focus the map on. Or ``WORLD``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#focus Dashboard#focus}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "focus": focus,
        }

    @builtins.property
    def focus(self) -> builtins.str:
        '''The 2-letter ISO code of a country to focus the map on. Or ``WORLD``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#focus Dashboard#focus}
        '''
        result = self._values.get("focus")
        assert result is not None, "Required property 'focus' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "event": "event",
        "legend_size": "legendSize",
        "live_span": "liveSpan",
        "request": "request",
        "show_legend": "showLegend",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
        "yaxis": "yaxis",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink"]] = None,
        event: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent"]] = None,
        legend_size: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest"]] = None,
        show_legend: typing.Optional[builtins.bool] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
        yaxis: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis"]] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param event: event block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event Dashboard#event}
        :param legend_size: The size of the legend displayed in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param show_legend: Whether or not to show the legend on this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        :param yaxis: yaxis block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if event is not None:
            self._values["event"] = event
        if legend_size is not None:
            self._values["legend_size"] = legend_size
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if show_legend is not None:
            self._values["show_legend"] = show_legend
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size
        if yaxis is not None:
            self._values["yaxis"] = yaxis

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink"]], result)

    @builtins.property
    def event(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent"]]:
        '''event block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event Dashboard#event}
        '''
        result = self._values.get("event")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent"]], result)

    @builtins.property
    def legend_size(self) -> typing.Optional[builtins.str]:
        '''The size of the legend displayed in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        '''
        result = self._values.get("legend_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest"]], result)

    @builtins.property
    def show_legend(self) -> typing.Optional[builtins.bool]:
        '''Whether or not to show the legend on this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        '''
        result = self._values.get("show_legend")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def yaxis(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis"]]:
        '''yaxis block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        result = self._values.get("yaxis")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent",
    jsii_struct_bases=[],
    name_mapping={"q": "q", "tags_execution": "tagsExecution"},
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent:
    def __init__(
        self,
        *,
        q: builtins.str,
        tags_execution: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param q: The event query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param tags_execution: The execution method for multi-value filters. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "q": q,
        }
        if tags_execution is not None:
            self._values["tags_execution"] = tags_execution

    @builtins.property
    def q(self) -> builtins.str:
        '''The event query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        assert result is not None, "Required property 'q' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags_execution(self) -> typing.Optional[builtins.str]:
        '''The execution method for multi-value filters.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        result = self._values.get("tags_execution")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
        "style": "style",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery"]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query
        if style is not None:
            self._values["style"] = style

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery"]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle",
    jsii_struct_bases=[],
    name_mapping={"palette": "palette"},
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle:
    def __init__(self, *, palette: typing.Optional[builtins.str] = None) -> None:
        '''
        :param palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if palette is not None:
            self._values["palette"] = palette

    @builtins.property
    def palette(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis",
    jsii_struct_bases=[],
    name_mapping={
        "include_zero": "includeZero",
        "label": "label",
        "max": "max",
        "min": "min",
        "scale": "scale",
    },
)
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis:
    def __init__(
        self,
        *,
        include_zero: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        max: typing.Optional[builtins.str] = None,
        min: typing.Optional[builtins.str] = None,
        scale: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param include_zero: Always include zero or fit the axis to the data range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        :param label: The label of the axis to display on the graph. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param max: Specify the maximum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        :param min: Specify the minimum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        :param scale: Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if include_zero is not None:
            self._values["include_zero"] = include_zero
        if label is not None:
            self._values["label"] = label
        if max is not None:
            self._values["max"] = max
        if min is not None:
            self._values["min"] = min
        if scale is not None:
            self._values["scale"] = scale

    @builtins.property
    def include_zero(self) -> typing.Optional[builtins.bool]:
        '''Always include zero or fit the axis to the data range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        '''
        result = self._values.get("include_zero")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label of the axis to display on the graph.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max(self) -> typing.Optional[builtins.str]:
        '''Specify the maximum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        '''
        result = self._values.get("max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def min(self) -> typing.Optional[builtins.str]:
        '''Specify the minimum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        '''
        result = self._values.get("min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale(self) -> typing.Optional[builtins.str]:
        '''Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        result = self._values.get("scale")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "group": "group",
        "node_type": "nodeType",
        "no_group_hosts": "noGroupHosts",
        "no_metric_hosts": "noMetricHosts",
        "request": "request",
        "scope": "scope",
        "style": "style",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink"]] = None,
        group: typing.Optional[typing.Sequence[builtins.str]] = None,
        node_type: typing.Optional[builtins.str] = None,
        no_group_hosts: typing.Optional[builtins.bool] = None,
        no_metric_hosts: typing.Optional[builtins.bool] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest"]] = None,
        scope: typing.Optional[typing.Sequence[builtins.str]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param group: The list of tags to group nodes by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group Dashboard#group}
        :param node_type: The type of node used. Valid values are ``host``, ``container``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#node_type Dashboard#node_type}
        :param no_group_hosts: Boolean indicating whether to show ungrouped nodes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#no_group_hosts Dashboard#no_group_hosts}
        :param no_metric_hosts: Boolean indicating whether to show nodes with no metrics. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#no_metric_hosts Dashboard#no_metric_hosts}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param scope: The list of tags to filter nodes by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scope Dashboard#scope}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if group is not None:
            self._values["group"] = group
        if node_type is not None:
            self._values["node_type"] = node_type
        if no_group_hosts is not None:
            self._values["no_group_hosts"] = no_group_hosts
        if no_metric_hosts is not None:
            self._values["no_metric_hosts"] = no_metric_hosts
        if request is not None:
            self._values["request"] = request
        if scope is not None:
            self._values["scope"] = scope
        if style is not None:
            self._values["style"] = style
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink"]], result)

    @builtins.property
    def group(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of tags to group nodes by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group Dashboard#group}
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def node_type(self) -> typing.Optional[builtins.str]:
        '''The type of node used. Valid values are ``host``, ``container``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#node_type Dashboard#node_type}
        '''
        result = self._values.get("node_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def no_group_hosts(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to show ungrouped nodes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#no_group_hosts Dashboard#no_group_hosts}
        '''
        result = self._values.get("no_group_hosts")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def no_metric_hosts(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to show nodes with no metrics.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#no_metric_hosts Dashboard#no_metric_hosts}
        '''
        result = self._values.get("no_metric_hosts")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest"]], result)

    @builtins.property
    def scope(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of tags to filter nodes by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scope Dashboard#scope}
        '''
        result = self._values.get("scope")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={"fill": "fill", "size": "size"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest:
    def __init__(
        self,
        *,
        fill: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill"]] = None,
        size: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize"]] = None,
    ) -> None:
        '''
        :param fill: fill block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill Dashboard#fill}
        :param size: size block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#size Dashboard#size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if fill is not None:
            self._values["fill"] = fill
        if size is not None:
            self._values["size"] = size

    @builtins.property
    def fill(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill"]]:
        '''fill block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill Dashboard#fill}
        '''
        result = self._values.get("fill")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill"]], result)

    @builtins.property
    def size(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize"]]:
        '''size block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#size Dashboard#size}
        '''
        result = self._values.get("size")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle",
    jsii_struct_bases=[],
    name_mapping={
        "fill_max": "fillMax",
        "fill_min": "fillMin",
        "palette": "palette",
        "palette_flip": "paletteFlip",
    },
)
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle:
    def __init__(
        self,
        *,
        fill_max: typing.Optional[builtins.str] = None,
        fill_min: typing.Optional[builtins.str] = None,
        palette: typing.Optional[builtins.str] = None,
        palette_flip: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param fill_max: Max value to use to color the map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill_max Dashboard#fill_max}
        :param fill_min: Min value to use to color the map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill_min Dashboard#fill_min}
        :param palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        :param palette_flip: Boolean indicating whether to flip the palette tones. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette_flip Dashboard#palette_flip}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if fill_max is not None:
            self._values["fill_max"] = fill_max
        if fill_min is not None:
            self._values["fill_min"] = fill_min
        if palette is not None:
            self._values["palette"] = palette
        if palette_flip is not None:
            self._values["palette_flip"] = palette_flip

    @builtins.property
    def fill_max(self) -> typing.Optional[builtins.str]:
        '''Max value to use to color the map.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill_max Dashboard#fill_max}
        '''
        result = self._values.get("fill_max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fill_min(self) -> typing.Optional[builtins.str]:
        '''Min value to use to color the map.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill_min Dashboard#fill_min}
        '''
        result = self._values.get("fill_min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def palette(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def palette_flip(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to flip the palette tones.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette_flip Dashboard#palette_flip}
        '''
        result = self._values.get("palette_flip")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetIframeDefinition",
    jsii_struct_bases=[],
    name_mapping={"url": "url"},
)
class DashboardWidgetGroupDefinitionWidgetIframeDefinition:
    def __init__(self, *, url: builtins.str) -> None:
        '''
        :param url: The URL to use as a data source for the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url Dashboard#url}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "url": url,
        }

    @builtins.property
    def url(self) -> builtins.str:
        '''The URL to use as a data source for the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url Dashboard#url}
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetIframeDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetImageDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "url": "url",
        "has_background": "hasBackground",
        "has_border": "hasBorder",
        "horizontal_align": "horizontalAlign",
        "margin": "margin",
        "sizing": "sizing",
        "url_dark_theme": "urlDarkTheme",
        "vertical_align": "verticalAlign",
    },
)
class DashboardWidgetGroupDefinitionWidgetImageDefinition:
    def __init__(
        self,
        *,
        url: builtins.str,
        has_background: typing.Optional[builtins.bool] = None,
        has_border: typing.Optional[builtins.bool] = None,
        horizontal_align: typing.Optional[builtins.str] = None,
        margin: typing.Optional[builtins.str] = None,
        sizing: typing.Optional[builtins.str] = None,
        url_dark_theme: typing.Optional[builtins.str] = None,
        vertical_align: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param url: The URL to use as a data source for the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url Dashboard#url}
        :param has_background: Whether to display a background or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_background Dashboard#has_background}
        :param has_border: Whether to display a border or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_border Dashboard#has_border}
        :param horizontal_align: The horizontal alignment for the widget. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#horizontal_align Dashboard#horizontal_align}
        :param margin: The margins to use around the image. Note: ``small`` and ``large`` values are deprecated. Valid values are ``sm``, ``md``, ``lg``, ``small``, ``large``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#margin Dashboard#margin}
        :param sizing: The preferred method to adapt the dimensions of the image. The values are based on the image ``object-fit`` CSS properties. Note: ``zoom``, ``fit`` and ``center`` values are deprecated. Valid values are ``fill``, ``contain``, ``cover``, ``none``, ``scale-down``, ``zoom``, ``fit``, ``center``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sizing Dashboard#sizing}
        :param url_dark_theme: The URL in dark mode to use as a data source for the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url_dark_theme Dashboard#url_dark_theme}
        :param vertical_align: The vertical alignment for the widget. Valid values are ``center``, ``top``, ``bottom``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#vertical_align Dashboard#vertical_align}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "url": url,
        }
        if has_background is not None:
            self._values["has_background"] = has_background
        if has_border is not None:
            self._values["has_border"] = has_border
        if horizontal_align is not None:
            self._values["horizontal_align"] = horizontal_align
        if margin is not None:
            self._values["margin"] = margin
        if sizing is not None:
            self._values["sizing"] = sizing
        if url_dark_theme is not None:
            self._values["url_dark_theme"] = url_dark_theme
        if vertical_align is not None:
            self._values["vertical_align"] = vertical_align

    @builtins.property
    def url(self) -> builtins.str:
        '''The URL to use as a data source for the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url Dashboard#url}
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def has_background(self) -> typing.Optional[builtins.bool]:
        '''Whether to display a background or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_background Dashboard#has_background}
        '''
        result = self._values.get("has_background")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def has_border(self) -> typing.Optional[builtins.bool]:
        '''Whether to display a border or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_border Dashboard#has_border}
        '''
        result = self._values.get("has_border")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def horizontal_align(self) -> typing.Optional[builtins.str]:
        '''The horizontal alignment for the widget. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#horizontal_align Dashboard#horizontal_align}
        '''
        result = self._values.get("horizontal_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def margin(self) -> typing.Optional[builtins.str]:
        '''The margins to use around the image.

        Note: ``small`` and ``large`` values are deprecated. Valid values are ``sm``, ``md``, ``lg``, ``small``, ``large``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#margin Dashboard#margin}
        '''
        result = self._values.get("margin")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sizing(self) -> typing.Optional[builtins.str]:
        '''The preferred method to adapt the dimensions of the image.

        The values are based on the image ``object-fit`` CSS properties. Note: ``zoom``, ``fit`` and ``center`` values are deprecated. Valid values are ``fill``, ``contain``, ``cover``, ``none``, ``scale-down``, ``zoom``, ``fit``, ``center``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sizing Dashboard#sizing}
        '''
        result = self._values.get("sizing")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url_dark_theme(self) -> typing.Optional[builtins.str]:
        '''The URL in dark mode to use as a data source for the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url_dark_theme Dashboard#url_dark_theme}
        '''
        result = self._values.get("url_dark_theme")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vertical_align(self) -> typing.Optional[builtins.str]:
        '''The vertical alignment for the widget. Valid values are ``center``, ``top``, ``bottom``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#vertical_align Dashboard#vertical_align}
        '''
        result = self._values.get("vertical_align")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetImageDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetLogStreamDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "columns": "columns",
        "indexes": "indexes",
        "live_span": "liveSpan",
        "message_display": "messageDisplay",
        "query": "query",
        "show_date_column": "showDateColumn",
        "show_message_column": "showMessageColumn",
        "sort": "sort",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinition:
    def __init__(
        self,
        *,
        columns: typing.Optional[typing.Sequence[builtins.str]] = None,
        indexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        live_span: typing.Optional[builtins.str] = None,
        message_display: typing.Optional[builtins.str] = None,
        query: typing.Optional[builtins.str] = None,
        show_date_column: typing.Optional[builtins.bool] = None,
        show_message_column: typing.Optional[builtins.bool] = None,
        sort: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param columns: Stringified list of columns to use. Example: ``["column1","column2","column3"]``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#columns Dashboard#columns}
        :param indexes: An array of index names to query in the stream. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param message_display: Amount of log lines to display. Valid values are ``inline``, ``expanded-md``, ``expanded-lg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#message_display Dashboard#message_display}
        :param query: The query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param show_date_column: If the date column should be displayed. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_date_column Dashboard#show_date_column}
        :param show_message_column: If the message column should be displayed. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_message_column Dashboard#show_message_column}
        :param sort: sort block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if columns is not None:
            self._values["columns"] = columns
        if indexes is not None:
            self._values["indexes"] = indexes
        if live_span is not None:
            self._values["live_span"] = live_span
        if message_display is not None:
            self._values["message_display"] = message_display
        if query is not None:
            self._values["query"] = query
        if show_date_column is not None:
            self._values["show_date_column"] = show_date_column
        if show_message_column is not None:
            self._values["show_message_column"] = show_message_column
        if sort is not None:
            self._values["sort"] = sort
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def columns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Stringified list of columns to use. Example: ``["column1","column2","column3"]``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#columns Dashboard#columns}
        '''
        result = self._values.get("columns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def indexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of index names to query in the stream.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        '''
        result = self._values.get("indexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def message_display(self) -> typing.Optional[builtins.str]:
        '''Amount of log lines to display. Valid values are ``inline``, ``expanded-md``, ``expanded-lg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#message_display Dashboard#message_display}
        '''
        result = self._values.get("message_display")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query(self) -> typing.Optional[builtins.str]:
        '''The query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def show_date_column(self) -> typing.Optional[builtins.bool]:
        '''If the date column should be displayed.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_date_column Dashboard#show_date_column}
        '''
        result = self._values.get("show_date_column")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_message_column(self) -> typing.Optional[builtins.bool]:
        '''If the message column should be displayed.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_message_column Dashboard#show_message_column}
        '''
        result = self._values.get("show_message_column")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def sort(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort"]]:
        '''sort block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetLogStreamDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort",
    jsii_struct_bases=[],
    name_mapping={"column": "column", "order": "order"},
)
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort:
    def __init__(self, *, column: builtins.str, order: builtins.str) -> None:
        '''
        :param column: Facet path for the column. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#column Dashboard#column}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "column": column,
            "order": order,
        }

    @builtins.property
    def column(self) -> builtins.str:
        '''Facet path for the column.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#column Dashboard#column}
        '''
        result = self._values.get("column")
        assert result is not None, "Required property 'column' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetManageStatusDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "query": "query",
        "color_preference": "colorPreference",
        "display_format": "displayFormat",
        "hide_zero_counts": "hideZeroCounts",
        "show_last_triggered": "showLastTriggered",
        "sort": "sort",
        "summary_type": "summaryType",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetManageStatusDefinition:
    def __init__(
        self,
        *,
        query: builtins.str,
        color_preference: typing.Optional[builtins.str] = None,
        display_format: typing.Optional[builtins.str] = None,
        hide_zero_counts: typing.Optional[builtins.bool] = None,
        show_last_triggered: typing.Optional[builtins.bool] = None,
        sort: typing.Optional[builtins.str] = None,
        summary_type: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param query: The query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param color_preference: Whether to colorize text or background. Valid values are ``background``, ``text``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color_preference Dashboard#color_preference}
        :param display_format: The display setting to use. Valid values are ``counts``, ``countsAndList``, ``list``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_format Dashboard#display_format}
        :param hide_zero_counts: Boolean indicating whether to hide empty categories. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_zero_counts Dashboard#hide_zero_counts}
        :param show_last_triggered: Boolean indicating whether to show when monitors/groups last triggered. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_last_triggered Dashboard#show_last_triggered}
        :param sort: The method to use to sort monitors. Valid values are ``name``, ``group``, ``status``, ``tags``, ``triggered``, ``group,asc``, ``group,desc``, ``name,asc``, ``name,desc``, ``status,asc``, ``status,desc``, ``tags,asc``, ``tags,desc``, ``triggered,asc``, ``triggered,desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param summary_type: Which summary type should be used. Valid values are ``monitors``, ``groups``, ``combined``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#summary_type Dashboard#summary_type}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }
        if color_preference is not None:
            self._values["color_preference"] = color_preference
        if display_format is not None:
            self._values["display_format"] = display_format
        if hide_zero_counts is not None:
            self._values["hide_zero_counts"] = hide_zero_counts
        if show_last_triggered is not None:
            self._values["show_last_triggered"] = show_last_triggered
        if sort is not None:
            self._values["sort"] = sort
        if summary_type is not None:
            self._values["summary_type"] = summary_type
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def query(self) -> builtins.str:
        '''The query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def color_preference(self) -> typing.Optional[builtins.str]:
        '''Whether to colorize text or background. Valid values are ``background``, ``text``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color_preference Dashboard#color_preference}
        '''
        result = self._values.get("color_preference")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def display_format(self) -> typing.Optional[builtins.str]:
        '''The display setting to use. Valid values are ``counts``, ``countsAndList``, ``list``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_format Dashboard#display_format}
        '''
        result = self._values.get("display_format")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hide_zero_counts(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to hide empty categories.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_zero_counts Dashboard#hide_zero_counts}
        '''
        result = self._values.get("hide_zero_counts")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_last_triggered(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to show when monitors/groups last triggered.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_last_triggered Dashboard#show_last_triggered}
        '''
        result = self._values.get("show_last_triggered")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def sort(self) -> typing.Optional[builtins.str]:
        '''The method to use to sort monitors.

        Valid values are ``name``, ``group``, ``status``, ``tags``, ``triggered``, ``group,asc``, ``group,desc``, ``name,asc``, ``name,desc``, ``status,asc``, ``status,desc``, ``tags,asc``, ``tags,desc``, ``triggered,asc``, ``triggered,desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def summary_type(self) -> typing.Optional[builtins.str]:
        '''Which summary type should be used. Valid values are ``monitors``, ``groups``, ``combined``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#summary_type Dashboard#summary_type}
        '''
        result = self._values.get("summary_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetManageStatusDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetNoteDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "content": "content",
        "background_color": "backgroundColor",
        "font_size": "fontSize",
        "has_padding": "hasPadding",
        "show_tick": "showTick",
        "text_align": "textAlign",
        "tick_edge": "tickEdge",
        "tick_pos": "tickPos",
        "vertical_align": "verticalAlign",
    },
)
class DashboardWidgetGroupDefinitionWidgetNoteDefinition:
    def __init__(
        self,
        *,
        content: builtins.str,
        background_color: typing.Optional[builtins.str] = None,
        font_size: typing.Optional[builtins.str] = None,
        has_padding: typing.Optional[builtins.bool] = None,
        show_tick: typing.Optional[builtins.bool] = None,
        text_align: typing.Optional[builtins.str] = None,
        tick_edge: typing.Optional[builtins.str] = None,
        tick_pos: typing.Optional[builtins.str] = None,
        vertical_align: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param content: Content of the note. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#content Dashboard#content}
        :param background_color: Background color of the note. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#background_color Dashboard#background_color}
        :param font_size: Size of the text. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#font_size Dashboard#font_size}
        :param has_padding: Whether to add padding or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_padding Dashboard#has_padding}
        :param show_tick: Whether to show a tick or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_tick Dashboard#show_tick}
        :param text_align: The alignment of the widget's text. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        :param tick_edge: When ``tick = true``, string indicating on which side of the widget the tick should be displayed. Valid values are ``bottom``, ``left``, ``right``, ``top``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tick_edge Dashboard#tick_edge}
        :param tick_pos: When ``tick = true``, string with a percent sign indicating the position of the tick. Example: use ``tick_pos = "50%"`` for centered alignment. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tick_pos Dashboard#tick_pos}
        :param vertical_align: The vertical alignment for the widget. Valid values are ``center``, ``top``, ``bottom``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#vertical_align Dashboard#vertical_align}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "content": content,
        }
        if background_color is not None:
            self._values["background_color"] = background_color
        if font_size is not None:
            self._values["font_size"] = font_size
        if has_padding is not None:
            self._values["has_padding"] = has_padding
        if show_tick is not None:
            self._values["show_tick"] = show_tick
        if text_align is not None:
            self._values["text_align"] = text_align
        if tick_edge is not None:
            self._values["tick_edge"] = tick_edge
        if tick_pos is not None:
            self._values["tick_pos"] = tick_pos
        if vertical_align is not None:
            self._values["vertical_align"] = vertical_align

    @builtins.property
    def content(self) -> builtins.str:
        '''Content of the note.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#content Dashboard#content}
        '''
        result = self._values.get("content")
        assert result is not None, "Required property 'content' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def background_color(self) -> typing.Optional[builtins.str]:
        '''Background color of the note.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#background_color Dashboard#background_color}
        '''
        result = self._values.get("background_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def font_size(self) -> typing.Optional[builtins.str]:
        '''Size of the text.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#font_size Dashboard#font_size}
        '''
        result = self._values.get("font_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def has_padding(self) -> typing.Optional[builtins.bool]:
        '''Whether to add padding or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_padding Dashboard#has_padding}
        '''
        result = self._values.get("has_padding")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_tick(self) -> typing.Optional[builtins.bool]:
        '''Whether to show a tick or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_tick Dashboard#show_tick}
        '''
        result = self._values.get("show_tick")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def text_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's text. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        '''
        result = self._values.get("text_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tick_edge(self) -> typing.Optional[builtins.str]:
        '''When ``tick = true``, string indicating on which side of the widget the tick should be displayed.

        Valid values are ``bottom``, ``left``, ``right``, ``top``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tick_edge Dashboard#tick_edge}
        '''
        result = self._values.get("tick_edge")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tick_pos(self) -> typing.Optional[builtins.str]:
        '''When ``tick = true``, string with a percent sign indicating the position of the tick.

        Example: use ``tick_pos = "50%"`` for centered alignment.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tick_pos Dashboard#tick_pos}
        '''
        result = self._values.get("tick_pos")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vertical_align(self) -> typing.Optional[builtins.str]:
        '''The vertical alignment for the widget. Valid values are ``center``, ``top``, ``bottom``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#vertical_align Dashboard#vertical_align}
        '''
        result = self._values.get("vertical_align")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetNoteDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "has_search_bar": "hasSearchBar",
        "live_span": "liveSpan",
        "request": "request",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink"]] = None,
        has_search_bar: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param has_search_bar: Controls the display of the search bar. Valid values are ``always``, ``never``, ``auto``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_search_bar Dashboard#has_search_bar}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if has_search_bar is not None:
            self._values["has_search_bar"] = has_search_bar
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink"]], result)

    @builtins.property
    def has_search_bar(self) -> typing.Optional[builtins.str]:
        '''Controls the display of the search bar. Valid values are ``always``, ``never``, ``auto``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_search_bar Dashboard#has_search_bar}
        '''
        result = self._values.get("has_search_bar")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "aggregator": "aggregator",
        "alias": "alias",
        "apm_query": "apmQuery",
        "apm_stats_query": "apmStatsQuery",
        "cell_display_mode": "cellDisplayMode",
        "conditional_formats": "conditionalFormats",
        "limit": "limit",
        "log_query": "logQuery",
        "order": "order",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest:
    def __init__(
        self,
        *,
        aggregator: typing.Optional[builtins.str] = None,
        alias: typing.Optional[builtins.str] = None,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery"]] = None,
        apm_stats_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery"]] = None,
        cell_display_mode: typing.Optional[typing.Sequence[builtins.str]] = None,
        conditional_formats: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormats"]] = None,
        limit: typing.Optional[jsii.Number] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery"]] = None,
        order: typing.Optional[builtins.str] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery"]] = None,
    ) -> None:
        '''
        :param aggregator: The aggregator to use for time aggregation. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param alias: The alias for the column name. Default is the metric name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param apm_stats_query: apm_stats_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_stats_query Dashboard#apm_stats_query}
        :param cell_display_mode: A list of display modes for each table cell. List items one of ``number``, ``bar``. Valid values are ``number``, ``bar``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#cell_display_mode Dashboard#cell_display_mode}
        :param conditional_formats: conditional_formats block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        :param limit: The number of lines to show in the table. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param order: The sort order for the rows. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if alias is not None:
            self._values["alias"] = alias
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if apm_stats_query is not None:
            self._values["apm_stats_query"] = apm_stats_query
        if cell_display_mode is not None:
            self._values["cell_display_mode"] = cell_display_mode
        if conditional_formats is not None:
            self._values["conditional_formats"] = conditional_formats
        if limit is not None:
            self._values["limit"] = limit
        if log_query is not None:
            self._values["log_query"] = log_query
        if order is not None:
            self._values["order"] = order
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregator to use for time aggregation. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''The alias for the column name. Default is the metric name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery"]], result)

    @builtins.property
    def apm_stats_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery"]]:
        '''apm_stats_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_stats_query Dashboard#apm_stats_query}
        '''
        result = self._values.get("apm_stats_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery"]], result)

    @builtins.property
    def cell_display_mode(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of display modes for each table cell.

        List items one of ``number``, ``bar``. Valid values are ``number``, ``bar``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#cell_display_mode Dashboard#cell_display_mode}
        '''
        result = self._values.get("cell_display_mode")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def conditional_formats(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormats"]]:
        '''conditional_formats block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        '''
        result = self._values.get("conditional_formats")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormats"]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''The number of lines to show in the table.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery"]], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''The sort order for the rows. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery",
    jsii_struct_bases=[],
    name_mapping={
        "env": "env",
        "name": "name",
        "primary_tag": "primaryTag",
        "row_type": "rowType",
        "service": "service",
        "columns": "columns",
        "resource": "resource",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery:
    def __init__(
        self,
        *,
        env: builtins.str,
        name: builtins.str,
        primary_tag: builtins.str,
        row_type: builtins.str,
        service: builtins.str,
        columns: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumns"]] = None,
        resource: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param env: Environment name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#env Dashboard#env}
        :param name: Operation name associated with service. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param primary_tag: The organization's host group name and value. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#primary_tag Dashboard#primary_tag}
        :param row_type: The level of detail for the request. Valid values are ``service``, ``resource``, ``span``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#row_type Dashboard#row_type}
        :param service: Service name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        :param columns: columns block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#columns Dashboard#columns}
        :param resource: Resource name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#resource Dashboard#resource}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "env": env,
            "name": name,
            "primary_tag": primary_tag,
            "row_type": row_type,
            "service": service,
        }
        if columns is not None:
            self._values["columns"] = columns
        if resource is not None:
            self._values["resource"] = resource

    @builtins.property
    def env(self) -> builtins.str:
        '''Environment name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#env Dashboard#env}
        '''
        result = self._values.get("env")
        assert result is not None, "Required property 'env' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Operation name associated with service.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def primary_tag(self) -> builtins.str:
        '''The organization's host group name and value.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#primary_tag Dashboard#primary_tag}
        '''
        result = self._values.get("primary_tag")
        assert result is not None, "Required property 'primary_tag' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def row_type(self) -> builtins.str:
        '''The level of detail for the request. Valid values are ``service``, ``resource``, ``span``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#row_type Dashboard#row_type}
        '''
        result = self._values.get("row_type")
        assert result is not None, "Required property 'row_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> builtins.str:
        '''Service name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def columns(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumns"]]:
        '''columns block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#columns Dashboard#columns}
        '''
        result = self._values.get("columns")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumns"]], result)

    @builtins.property
    def resource(self) -> typing.Optional[builtins.str]:
        '''Resource name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#resource Dashboard#resource}
        '''
        result = self._values.get("resource")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumns",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alias": "alias",
        "cell_display_mode": "cellDisplayMode",
        "order": "order",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumns:
    def __init__(
        self,
        *,
        name: builtins.str,
        alias: typing.Optional[builtins.str] = None,
        cell_display_mode: typing.Optional[builtins.str] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Column name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param alias: A user-assigned alias for the column. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param cell_display_mode: A list of display modes for each table cell. Valid values are ``number``, ``bar``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#cell_display_mode Dashboard#cell_display_mode}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if alias is not None:
            self._values["alias"] = alias
        if cell_display_mode is not None:
            self._values["cell_display_mode"] = cell_display_mode
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def name(self) -> builtins.str:
        '''Column name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''A user-assigned alias for the column.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cell_display_mode(self) -> typing.Optional[builtins.str]:
        '''A list of display modes for each table cell. Valid values are ``number``, ``bar``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#cell_display_mode Dashboard#cell_display_mode}
        '''
        result = self._values.get("cell_display_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumns(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormats",
    jsii_struct_bases=[],
    name_mapping={
        "comparator": "comparator",
        "palette": "palette",
        "value": "value",
        "custom_bg_color": "customBgColor",
        "custom_fg_color": "customFgColor",
        "hide_value": "hideValue",
        "image_url": "imageUrl",
        "metric": "metric",
        "timeframe": "timeframe",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormats:
    def __init__(
        self,
        *,
        comparator: builtins.str,
        palette: builtins.str,
        value: jsii.Number,
        custom_bg_color: typing.Optional[builtins.str] = None,
        custom_fg_color: typing.Optional[builtins.str] = None,
        hide_value: typing.Optional[builtins.bool] = None,
        image_url: typing.Optional[builtins.str] = None,
        metric: typing.Optional[builtins.str] = None,
        timeframe: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param comparator: Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        :param palette: Color palette to apply. Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        :param value: Value for the comparator. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        :param custom_bg_color: Color palette to apply to the background, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        :param custom_fg_color: Color palette to apply to the foreground, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        :param hide_value: Setting this to True hides values. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        :param image_url: Displays an image as the background. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        :param metric: Metric from the request to correlate this conditional format with. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param timeframe: Defines the displayed timeframe. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "comparator": comparator,
            "palette": palette,
            "value": value,
        }
        if custom_bg_color is not None:
            self._values["custom_bg_color"] = custom_bg_color
        if custom_fg_color is not None:
            self._values["custom_fg_color"] = custom_fg_color
        if hide_value is not None:
            self._values["hide_value"] = hide_value
        if image_url is not None:
            self._values["image_url"] = image_url
        if metric is not None:
            self._values["metric"] = metric
        if timeframe is not None:
            self._values["timeframe"] = timeframe

    @builtins.property
    def comparator(self) -> builtins.str:
        '''Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        '''
        result = self._values.get("comparator")
        assert result is not None, "Required property 'comparator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def palette(self) -> builtins.str:
        '''Color palette to apply.

        Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        assert result is not None, "Required property 'palette' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        '''Value for the comparator.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def custom_bg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the background, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        '''
        result = self._values.get("custom_bg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def custom_fg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the foreground, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        '''
        result = self._values.get("custom_fg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hide_value(self) -> typing.Optional[builtins.bool]:
        '''Setting this to True hides values.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        '''
        result = self._values.get("hide_value")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def image_url(self) -> typing.Optional[builtins.str]:
        '''Displays an image as the background.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        '''
        result = self._values.get("image_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric from the request to correlate this conditional format with.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timeframe(self) -> typing.Optional[builtins.str]:
        '''Defines the displayed timeframe.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        result = self._values.get("timeframe")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormats(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "autoscale": "autoscale",
        "custom_link": "customLink",
        "custom_unit": "customUnit",
        "live_span": "liveSpan",
        "precision": "precision",
        "request": "request",
        "text_align": "textAlign",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinition:
    def __init__(
        self,
        *,
        autoscale: typing.Optional[builtins.bool] = None,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink"]] = None,
        custom_unit: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        precision: typing.Optional[jsii.Number] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest"]] = None,
        text_align: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param autoscale: Boolean indicating whether to automatically scale the tile. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#autoscale Dashboard#autoscale}
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param custom_unit: The unit for the value displayed in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_unit Dashboard#custom_unit}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param precision: The precision to use when displaying the tile. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#precision Dashboard#precision}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param text_align: The alignment of the widget's text. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if autoscale is not None:
            self._values["autoscale"] = autoscale
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if custom_unit is not None:
            self._values["custom_unit"] = custom_unit
        if live_span is not None:
            self._values["live_span"] = live_span
        if precision is not None:
            self._values["precision"] = precision
        if request is not None:
            self._values["request"] = request
        if text_align is not None:
            self._values["text_align"] = text_align
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def autoscale(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to automatically scale the tile.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#autoscale Dashboard#autoscale}
        '''
        result = self._values.get("autoscale")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink"]], result)

    @builtins.property
    def custom_unit(self) -> typing.Optional[builtins.str]:
        '''The unit for the value displayed in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_unit Dashboard#custom_unit}
        '''
        result = self._values.get("custom_unit")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def precision(self) -> typing.Optional[jsii.Number]:
        '''The precision to use when displaying the tile.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#precision Dashboard#precision}
        '''
        result = self._values.get("precision")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest"]], result)

    @builtins.property
    def text_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's text. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        '''
        result = self._values.get("text_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "aggregator": "aggregator",
        "apm_query": "apmQuery",
        "conditional_formats": "conditionalFormats",
        "formula": "formula",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "query": "query",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest:
    def __init__(
        self,
        *,
        aggregator: typing.Optional[builtins.str] = None,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery"]] = None,
        conditional_formats: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormats"]] = None,
        formula: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery"]] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery"]] = None,
    ) -> None:
        '''
        :param aggregator: The aggregator to use for time aggregation. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param conditional_formats: conditional_formats block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        :param formula: formula block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if conditional_formats is not None:
            self._values["conditional_formats"] = conditional_formats
        if formula is not None:
            self._values["formula"] = formula
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if query is not None:
            self._values["query"] = query
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregator to use for time aggregation. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery"]], result)

    @builtins.property
    def conditional_formats(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormats"]]:
        '''conditional_formats block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        '''
        result = self._values.get("conditional_formats")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormats"]], result)

    @builtins.property
    def formula(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula"]]:
        '''formula block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        '''
        result = self._values.get("formula")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery"]]:
        '''query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery"]], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormats",
    jsii_struct_bases=[],
    name_mapping={
        "comparator": "comparator",
        "palette": "palette",
        "value": "value",
        "custom_bg_color": "customBgColor",
        "custom_fg_color": "customFgColor",
        "hide_value": "hideValue",
        "image_url": "imageUrl",
        "metric": "metric",
        "timeframe": "timeframe",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormats:
    def __init__(
        self,
        *,
        comparator: builtins.str,
        palette: builtins.str,
        value: jsii.Number,
        custom_bg_color: typing.Optional[builtins.str] = None,
        custom_fg_color: typing.Optional[builtins.str] = None,
        hide_value: typing.Optional[builtins.bool] = None,
        image_url: typing.Optional[builtins.str] = None,
        metric: typing.Optional[builtins.str] = None,
        timeframe: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param comparator: Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        :param palette: Color palette to apply. Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        :param value: Value for the comparator. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        :param custom_bg_color: Color palette to apply to the background, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        :param custom_fg_color: Color palette to apply to the foreground, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        :param hide_value: Setting this to True hides values. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        :param image_url: Displays an image as the background. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        :param metric: Metric from the request to correlate this conditional format with. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param timeframe: Defines the displayed timeframe. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "comparator": comparator,
            "palette": palette,
            "value": value,
        }
        if custom_bg_color is not None:
            self._values["custom_bg_color"] = custom_bg_color
        if custom_fg_color is not None:
            self._values["custom_fg_color"] = custom_fg_color
        if hide_value is not None:
            self._values["hide_value"] = hide_value
        if image_url is not None:
            self._values["image_url"] = image_url
        if metric is not None:
            self._values["metric"] = metric
        if timeframe is not None:
            self._values["timeframe"] = timeframe

    @builtins.property
    def comparator(self) -> builtins.str:
        '''Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        '''
        result = self._values.get("comparator")
        assert result is not None, "Required property 'comparator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def palette(self) -> builtins.str:
        '''Color palette to apply.

        Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        assert result is not None, "Required property 'palette' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        '''Value for the comparator.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def custom_bg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the background, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        '''
        result = self._values.get("custom_bg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def custom_fg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the foreground, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        '''
        result = self._values.get("custom_fg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hide_value(self) -> typing.Optional[builtins.bool]:
        '''Setting this to True hides values.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        '''
        result = self._values.get("hide_value")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def image_url(self) -> typing.Optional[builtins.str]:
        '''Displays an image as the background.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        '''
        result = self._values.get("image_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric from the request to correlate this conditional format with.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timeframe(self) -> typing.Optional[builtins.str]:
        '''Defines the displayed timeframe.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        result = self._values.get("timeframe")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormats(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula",
    jsii_struct_bases=[],
    name_mapping={
        "formula_expression": "formulaExpression",
        "alias": "alias",
        "limit": "limit",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula:
    def __init__(
        self,
        *,
        formula_expression: builtins.str,
        alias: typing.Optional[builtins.str] = None,
        limit: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit"]] = None,
    ) -> None:
        '''
        :param formula_expression: String expression built from queries, formulas and functions. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        :param alias: Expression alias. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param limit: limit block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "formula_expression": formula_expression,
        }
        if alias is not None:
            self._values["alias"] = alias
        if limit is not None:
            self._values["limit"] = limit

    @builtins.property
    def formula_expression(self) -> builtins.str:
        '''String expression built from queries, formulas and functions.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        '''
        result = self._values.get("formula_expression")
        assert result is not None, "Required property 'formula_expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''Expression alias.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit"]]:
        '''limit block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit",
    jsii_struct_bases=[],
    name_mapping={"count": "count", "order": "order"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit:
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: Number of results to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''Number of results to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery",
    jsii_struct_bases=[],
    name_mapping={
        "event_query": "eventQuery",
        "metric_query": "metricQuery",
        "process_query": "processQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery:
    def __init__(
        self,
        *,
        event_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery"]] = None,
        metric_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery"]] = None,
    ) -> None:
        '''
        :param event_query: event_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        :param metric_query: metric_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if event_query is not None:
            self._values["event_query"] = event_query
        if metric_query is not None:
            self._values["metric_query"] = metric_query
        if process_query is not None:
            self._values["process_query"] = process_query

    @builtins.property
    def event_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery"]]:
        '''event_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        '''
        result = self._values.get("event_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery"]], result)

    @builtins.property
    def metric_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery"]]:
        '''metric_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        '''
        result = self._values.get("metric_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery",
    jsii_struct_bases=[],
    name_mapping={
        "compute": "compute",
        "data_source": "dataSource",
        "name": "name",
        "group_by": "groupBy",
        "indexes": "indexes",
        "search": "search",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery:
    def __init__(
        self,
        *,
        compute: typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute"],
        data_source: builtins.str,
        name: builtins.str,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy"]] = None,
        indexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        search: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch"]] = None,
    ) -> None:
        '''
        :param compute: compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        :param data_source: Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param indexes: An array of index names to query in the stream. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        :param search: search block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "compute": compute,
            "data_source": data_source,
            "name": name,
        }
        if group_by is not None:
            self._values["group_by"] = group_by
        if indexes is not None:
            self._values["indexes"] = indexes
        if search is not None:
            self._values["search"] = search

    @builtins.property
    def compute(
        self,
    ) -> typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute"]:
        '''compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        '''
        result = self._values.get("compute")
        assert result is not None, "Required property 'compute' is missing"
        return typing.cast(typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute"], result)

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy"]], result)

    @builtins.property
    def indexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of index names to query in the stream.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        '''
        result = self._values.get("indexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def search(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch"]]:
        '''search block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        result = self._values.get("search")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "interval": "interval",
        "metric": "metric",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        interval: typing.Optional[jsii.Number] = None,
        metric: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param interval: A time interval in milliseconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        :param metric: Measurable attribute to compute. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if interval is not None:
            self._values["interval"] = interval
        if metric is not None:
            self._values["metric"] = metric

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''A time interval in milliseconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Measurable attribute to compute.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort": "sort"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy:
    def __init__(
        self,
        *,
        facet: builtins.str,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort"]] = None,
    ) -> None:
        '''
        :param facet: Event facet. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Number of groups to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: sort block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "facet": facet,
        }
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort

    @builtins.property
    def facet(self) -> builtins.str:
        '''Event facet.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        assert result is not None, "Required property 'facet' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of groups to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort"]]:
        '''sort block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "metric": "metric", "order": "order"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        metric: typing.Optional[builtins.str] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param metric: Metric used for sorting group by results. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if metric is not None:
            self._values["metric"] = metric
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric used for sorting group by results.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Events search string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Events search string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "query": "query",
        "aggregator": "aggregator",
        "data_source": "dataSource",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery:
    def __init__(
        self,
        *,
        name: builtins.str,
        query: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        data_source: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Name of the query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param query: Metrics query definition. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param data_source: Data source for metrics queries. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "query": query,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if data_source is not None:
            self._values["data_source"] = data_source

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''Metrics query definition.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def data_source(self) -> typing.Optional[builtins.str]:
        '''Data source for metrics queries.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "data_source": "dataSource",
        "metric": "metric",
        "name": "name",
        "aggregator": "aggregator",
        "is_normalized_cpu": "isNormalizedCpu",
        "limit": "limit",
        "sort": "sort",
        "tag_filters": "tagFilters",
        "text_filter": "textFilter",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery:
    def __init__(
        self,
        *,
        data_source: builtins.str,
        metric: builtins.str,
        name: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        is_normalized_cpu: typing.Optional[builtins.bool] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[builtins.str] = None,
        tag_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
        text_filter: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param data_source: Data source for process queries. Valid values are ``process``, ``container``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param metric: Process metric name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param is_normalized_cpu: Whether to normalize the CPU percentages. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        :param limit: Number of hits to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param tag_filters: An array of tags to filter by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        :param text_filter: Text to use as filter. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "data_source": data_source,
            "metric": metric,
            "name": name,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if is_normalized_cpu is not None:
            self._values["is_normalized_cpu"] = is_normalized_cpu
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort
        if tag_filters is not None:
            self._values["tag_filters"] = tag_filters
        if text_filter is not None:
            self._values["text_filter"] = text_filter

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for process queries. Valid values are ``process``, ``container``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> builtins.str:
        '''Process metric name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_normalized_cpu(self) -> typing.Optional[builtins.bool]:
        '''Whether to normalize the CPU percentages.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        '''
        result = self._values.get("is_normalized_cpu")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of hits to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_filters(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of tags to filter by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        '''
        result = self._values.get("tag_filters")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def text_filter(self) -> typing.Optional[builtins.str]:
        '''Text to use as filter.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        result = self._values.get("text_filter")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "color_by_groups": "colorByGroups",
        "custom_link": "customLink",
        "live_span": "liveSpan",
        "request": "request",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
        "xaxis": "xaxis",
        "yaxis": "yaxis",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinition:
    def __init__(
        self,
        *,
        color_by_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink"]] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
        xaxis: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis"]] = None,
        yaxis: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis"]] = None,
    ) -> None:
        '''
        :param color_by_groups: List of groups used for colors. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color_by_groups Dashboard#color_by_groups}
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        :param xaxis: xaxis block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#xaxis Dashboard#xaxis}
        :param yaxis: yaxis block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if color_by_groups is not None:
            self._values["color_by_groups"] = color_by_groups
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size
        if xaxis is not None:
            self._values["xaxis"] = xaxis
        if yaxis is not None:
            self._values["yaxis"] = yaxis

    @builtins.property
    def color_by_groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of groups used for colors.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color_by_groups Dashboard#color_by_groups}
        '''
        result = self._values.get("color_by_groups")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink"]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def xaxis(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis"]]:
        '''xaxis block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#xaxis Dashboard#xaxis}
        '''
        result = self._values.get("xaxis")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis"]], result)

    @builtins.property
    def yaxis(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis"]]:
        '''yaxis block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        result = self._values.get("yaxis")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={"x": "x", "y": "y"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest:
    def __init__(
        self,
        *,
        x: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX"]] = None,
        y: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY"]] = None,
    ) -> None:
        '''
        :param x: x block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#x Dashboard#x}
        :param y: y block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#y Dashboard#y}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if x is not None:
            self._values["x"] = x
        if y is not None:
            self._values["y"] = y

    @builtins.property
    def x(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX"]]:
        '''x block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#x Dashboard#x}
        '''
        result = self._values.get("x")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX"]], result)

    @builtins.property
    def y(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY"]]:
        '''y block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#y Dashboard#y}
        '''
        result = self._values.get("y")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX",
    jsii_struct_bases=[],
    name_mapping={
        "aggregator": "aggregator",
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX:
    def __init__(
        self,
        *,
        aggregator: typing.Optional[builtins.str] = None,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery"]] = None,
    ) -> None:
        '''
        :param aggregator: Aggregator used for the request. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''Aggregator used for the request. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY",
    jsii_struct_bases=[],
    name_mapping={
        "aggregator": "aggregator",
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY:
    def __init__(
        self,
        *,
        aggregator: typing.Optional[builtins.str] = None,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery"]] = None,
    ) -> None:
        '''
        :param aggregator: Aggregator used for the request. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''Aggregator used for the request. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis",
    jsii_struct_bases=[],
    name_mapping={
        "include_zero": "includeZero",
        "label": "label",
        "max": "max",
        "min": "min",
        "scale": "scale",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis:
    def __init__(
        self,
        *,
        include_zero: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        max: typing.Optional[builtins.str] = None,
        min: typing.Optional[builtins.str] = None,
        scale: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param include_zero: Always include zero or fit the axis to the data range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        :param label: The label of the axis to display on the graph. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param max: Specify the maximum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        :param min: Specify the minimum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        :param scale: Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if include_zero is not None:
            self._values["include_zero"] = include_zero
        if label is not None:
            self._values["label"] = label
        if max is not None:
            self._values["max"] = max
        if min is not None:
            self._values["min"] = min
        if scale is not None:
            self._values["scale"] = scale

    @builtins.property
    def include_zero(self) -> typing.Optional[builtins.bool]:
        '''Always include zero or fit the axis to the data range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        '''
        result = self._values.get("include_zero")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label of the axis to display on the graph.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max(self) -> typing.Optional[builtins.str]:
        '''Specify the maximum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        '''
        result = self._values.get("max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def min(self) -> typing.Optional[builtins.str]:
        '''Specify the minimum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        '''
        result = self._values.get("min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale(self) -> typing.Optional[builtins.str]:
        '''Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        result = self._values.get("scale")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis",
    jsii_struct_bases=[],
    name_mapping={
        "include_zero": "includeZero",
        "label": "label",
        "max": "max",
        "min": "min",
        "scale": "scale",
    },
)
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis:
    def __init__(
        self,
        *,
        include_zero: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        max: typing.Optional[builtins.str] = None,
        min: typing.Optional[builtins.str] = None,
        scale: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param include_zero: Always include zero or fit the axis to the data range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        :param label: The label of the axis to display on the graph. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param max: Specify the maximum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        :param min: Specify the minimum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        :param scale: Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if include_zero is not None:
            self._values["include_zero"] = include_zero
        if label is not None:
            self._values["label"] = label
        if max is not None:
            self._values["max"] = max
        if min is not None:
            self._values["min"] = min
        if scale is not None:
            self._values["scale"] = scale

    @builtins.property
    def include_zero(self) -> typing.Optional[builtins.bool]:
        '''Always include zero or fit the axis to the data range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        '''
        result = self._values.get("include_zero")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label of the axis to display on the graph.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max(self) -> typing.Optional[builtins.str]:
        '''Specify the maximum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        '''
        result = self._values.get("max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def min(self) -> typing.Optional[builtins.str]:
        '''Specify the minimum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        '''
        result = self._values.get("min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale(self) -> typing.Optional[builtins.str]:
        '''Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        result = self._values.get("scale")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "slo_id": "sloId",
        "time_windows": "timeWindows",
        "view_mode": "viewMode",
        "view_type": "viewType",
        "global_time_target": "globalTimeTarget",
        "show_error_budget": "showErrorBudget",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition:
    def __init__(
        self,
        *,
        slo_id: builtins.str,
        time_windows: typing.Sequence[builtins.str],
        view_mode: builtins.str,
        view_type: builtins.str,
        global_time_target: typing.Optional[builtins.str] = None,
        show_error_budget: typing.Optional[builtins.bool] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param slo_id: The ID of the service level objective used by the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#slo_id Dashboard#slo_id}
        :param time_windows: List of time windows to display in the widget. Valid values are ``7d``, ``30d``, ``90d``, ``week_to_date``, ``previous_week``, ``month_to_date``, ``previous_month``, ``global_time``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#time_windows Dashboard#time_windows}
        :param view_mode: View mode for the widget. Valid values are ``overall``, ``component``, ``both``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view_mode Dashboard#view_mode}
        :param view_type: Type of view to use when displaying the widget. Only ``detail`` is currently supported. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view_type Dashboard#view_type}
        :param global_time_target: The global time target of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#global_time_target Dashboard#global_time_target}
        :param show_error_budget: Whether to show the error budget or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_error_budget Dashboard#show_error_budget}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "slo_id": slo_id,
            "time_windows": time_windows,
            "view_mode": view_mode,
            "view_type": view_type,
        }
        if global_time_target is not None:
            self._values["global_time_target"] = global_time_target
        if show_error_budget is not None:
            self._values["show_error_budget"] = show_error_budget
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def slo_id(self) -> builtins.str:
        '''The ID of the service level objective used by the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#slo_id Dashboard#slo_id}
        '''
        result = self._values.get("slo_id")
        assert result is not None, "Required property 'slo_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def time_windows(self) -> typing.List[builtins.str]:
        '''List of time windows to display in the widget.

        Valid values are ``7d``, ``30d``, ``90d``, ``week_to_date``, ``previous_week``, ``month_to_date``, ``previous_month``, ``global_time``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#time_windows Dashboard#time_windows}
        '''
        result = self._values.get("time_windows")
        assert result is not None, "Required property 'time_windows' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def view_mode(self) -> builtins.str:
        '''View mode for the widget. Valid values are ``overall``, ``component``, ``both``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view_mode Dashboard#view_mode}
        '''
        result = self._values.get("view_mode")
        assert result is not None, "Required property 'view_mode' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def view_type(self) -> builtins.str:
        '''Type of view to use when displaying the widget. Only ``detail`` is currently supported.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view_type Dashboard#view_type}
        '''
        result = self._values.get("view_type")
        assert result is not None, "Required property 'view_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def global_time_target(self) -> typing.Optional[builtins.str]:
        '''The global time target of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#global_time_target Dashboard#global_time_target}
        '''
        result = self._values.get("global_time_target")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def show_error_budget(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the error budget or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_error_budget Dashboard#show_error_budget}
        '''
        result = self._values.get("show_error_budget")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetServicemapDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "filters": "filters",
        "service": "service",
        "custom_link": "customLink",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetServicemapDefinition:
    def __init__(
        self,
        *,
        filters: typing.Sequence[builtins.str],
        service: builtins.str,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param filters: Your environment and primary tag (or ``*`` if enabled for your account). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filters Dashboard#filters}
        :param service: The ID of the service you want to map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "filters": filters,
            "service": service,
        }
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def filters(self) -> typing.List[builtins.str]:
        '''Your environment and primary tag (or ``*`` if enabled for your account).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filters Dashboard#filters}
        '''
        result = self._values.get("filters")
        assert result is not None, "Required property 'filters' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def service(self) -> builtins.str:
        '''The ID of the service you want to map.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetServicemapDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "event": "event",
        "legend_columns": "legendColumns",
        "legend_layout": "legendLayout",
        "legend_size": "legendSize",
        "live_span": "liveSpan",
        "marker": "marker",
        "request": "request",
        "right_yaxis": "rightYaxis",
        "show_legend": "showLegend",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
        "yaxis": "yaxis",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink"]] = None,
        event: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent"]] = None,
        legend_columns: typing.Optional[typing.Sequence[builtins.str]] = None,
        legend_layout: typing.Optional[builtins.str] = None,
        legend_size: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        marker: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker"]] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest"]] = None,
        right_yaxis: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis"]] = None,
        show_legend: typing.Optional[builtins.bool] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
        yaxis: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis"]] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param event: event block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event Dashboard#event}
        :param legend_columns: A list of columns to display in the legend. Valid values are ``value``, ``avg``, ``sum``, ``min``, ``max``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_columns Dashboard#legend_columns}
        :param legend_layout: The layout of the legend displayed in the widget. Valid values are ``auto``, ``horizontal``, ``vertical``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_layout Dashboard#legend_layout}
        :param legend_size: The size of the legend displayed in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param marker: marker block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#marker Dashboard#marker}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param right_yaxis: right_yaxis block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#right_yaxis Dashboard#right_yaxis}
        :param show_legend: Whether or not to show the legend on this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        :param yaxis: yaxis block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if event is not None:
            self._values["event"] = event
        if legend_columns is not None:
            self._values["legend_columns"] = legend_columns
        if legend_layout is not None:
            self._values["legend_layout"] = legend_layout
        if legend_size is not None:
            self._values["legend_size"] = legend_size
        if live_span is not None:
            self._values["live_span"] = live_span
        if marker is not None:
            self._values["marker"] = marker
        if request is not None:
            self._values["request"] = request
        if right_yaxis is not None:
            self._values["right_yaxis"] = right_yaxis
        if show_legend is not None:
            self._values["show_legend"] = show_legend
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size
        if yaxis is not None:
            self._values["yaxis"] = yaxis

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink"]], result)

    @builtins.property
    def event(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent"]]:
        '''event block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event Dashboard#event}
        '''
        result = self._values.get("event")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent"]], result)

    @builtins.property
    def legend_columns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of columns to display in the legend. Valid values are ``value``, ``avg``, ``sum``, ``min``, ``max``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_columns Dashboard#legend_columns}
        '''
        result = self._values.get("legend_columns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def legend_layout(self) -> typing.Optional[builtins.str]:
        '''The layout of the legend displayed in the widget. Valid values are ``auto``, ``horizontal``, ``vertical``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_layout Dashboard#legend_layout}
        '''
        result = self._values.get("legend_layout")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def legend_size(self) -> typing.Optional[builtins.str]:
        '''The size of the legend displayed in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        '''
        result = self._values.get("legend_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def marker(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker"]]:
        '''marker block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#marker Dashboard#marker}
        '''
        result = self._values.get("marker")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker"]], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest"]], result)

    @builtins.property
    def right_yaxis(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis"]]:
        '''right_yaxis block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#right_yaxis Dashboard#right_yaxis}
        '''
        result = self._values.get("right_yaxis")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis"]], result)

    @builtins.property
    def show_legend(self) -> typing.Optional[builtins.bool]:
        '''Whether or not to show the legend on this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        '''
        result = self._values.get("show_legend")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def yaxis(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis"]]:
        '''yaxis block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        result = self._values.get("yaxis")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent",
    jsii_struct_bases=[],
    name_mapping={"q": "q", "tags_execution": "tagsExecution"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent:
    def __init__(
        self,
        *,
        q: builtins.str,
        tags_execution: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param q: The event query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param tags_execution: The execution method for multi-value filters. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "q": q,
        }
        if tags_execution is not None:
            self._values["tags_execution"] = tags_execution

    @builtins.property
    def q(self) -> builtins.str:
        '''The event query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        assert result is not None, "Required property 'q' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags_execution(self) -> typing.Optional[builtins.str]:
        '''The execution method for multi-value filters.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        result = self._values.get("tags_execution")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker",
    jsii_struct_bases=[],
    name_mapping={"value": "value", "display_type": "displayType", "label": "label"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker:
    def __init__(
        self,
        *,
        value: builtins.str,
        display_type: typing.Optional[builtins.str] = None,
        label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param value: Mathematical expression describing the marker. Examples: ``y > 1``, ``-5 < y < 0``, ``y = 19``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        :param display_type: How the marker lines will look. Possible values are one of {``error``, ``warning``, ``info``, ``ok``} combined with one of {``dashed``, ``solid``, ``bold``}. Example: ``error dashed``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_type Dashboard#display_type}
        :param label: A label for the line or range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "value": value,
        }
        if display_type is not None:
            self._values["display_type"] = display_type
        if label is not None:
            self._values["label"] = label

    @builtins.property
    def value(self) -> builtins.str:
        '''Mathematical expression describing the marker. Examples: ``y > 1``, ``-5 < y < 0``, ``y = 19``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def display_type(self) -> typing.Optional[builtins.str]:
        '''How the marker lines will look.

        Possible values are one of {``error``, ``warning``, ``info``, ``ok``} combined with one of {``dashed``, ``solid``, ``bold``}. Example: ``error dashed``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_type Dashboard#display_type}
        '''
        result = self._values.get("display_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''A label for the line or range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "display_type": "displayType",
        "formula": "formula",
        "log_query": "logQuery",
        "metadata": "metadata",
        "network_query": "networkQuery",
        "on_right_yaxis": "onRightYaxis",
        "process_query": "processQuery",
        "q": "q",
        "query": "query",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
        "style": "style",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery"]] = None,
        display_type: typing.Optional[builtins.str] = None,
        formula: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery"]] = None,
        metadata: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata"]] = None,
        network_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery"]] = None,
        on_right_yaxis: typing.Optional[builtins.bool] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery"]] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery"]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param display_type: How the marker lines will look. Valid values are ``area``, ``bars``, ``line``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_type Dashboard#display_type}
        :param formula: formula block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param metadata: metadata block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metadata Dashboard#metadata}
        :param network_query: network_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#network_query Dashboard#network_query}
        :param on_right_yaxis: Boolean indicating whether the request will use the right or left Y-Axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#on_right_yaxis Dashboard#on_right_yaxis}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if display_type is not None:
            self._values["display_type"] = display_type
        if formula is not None:
            self._values["formula"] = formula
        if log_query is not None:
            self._values["log_query"] = log_query
        if metadata is not None:
            self._values["metadata"] = metadata
        if network_query is not None:
            self._values["network_query"] = network_query
        if on_right_yaxis is not None:
            self._values["on_right_yaxis"] = on_right_yaxis
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if query is not None:
            self._values["query"] = query
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query
        if style is not None:
            self._values["style"] = style

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery"]], result)

    @builtins.property
    def display_type(self) -> typing.Optional[builtins.str]:
        '''How the marker lines will look. Valid values are ``area``, ``bars``, ``line``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_type Dashboard#display_type}
        '''
        result = self._values.get("display_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def formula(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula"]]:
        '''formula block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        '''
        result = self._values.get("formula")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery"]], result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata"]]:
        '''metadata block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metadata Dashboard#metadata}
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata"]], result)

    @builtins.property
    def network_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery"]]:
        '''network_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#network_query Dashboard#network_query}
        '''
        result = self._values.get("network_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery"]], result)

    @builtins.property
    def on_right_yaxis(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether the request will use the right or left Y-Axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#on_right_yaxis Dashboard#on_right_yaxis}
        '''
        result = self._values.get("on_right_yaxis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery"]]:
        '''query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery"]], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery"]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula",
    jsii_struct_bases=[],
    name_mapping={
        "formula_expression": "formulaExpression",
        "alias": "alias",
        "limit": "limit",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula:
    def __init__(
        self,
        *,
        formula_expression: builtins.str,
        alias: typing.Optional[builtins.str] = None,
        limit: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit"]] = None,
    ) -> None:
        '''
        :param formula_expression: String expression built from queries, formulas and functions. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        :param alias: Expression alias. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param limit: limit block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "formula_expression": formula_expression,
        }
        if alias is not None:
            self._values["alias"] = alias
        if limit is not None:
            self._values["limit"] = limit

    @builtins.property
    def formula_expression(self) -> builtins.str:
        '''String expression built from queries, formulas and functions.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        '''
        result = self._values.get("formula_expression")
        assert result is not None, "Required property 'formula_expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''Expression alias.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit"]]:
        '''limit block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit",
    jsii_struct_bases=[],
    name_mapping={"count": "count", "order": "order"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit:
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: Number of results to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''Number of results to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata",
    jsii_struct_bases=[],
    name_mapping={"expression": "expression", "alias_name": "aliasName"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata:
    def __init__(
        self,
        *,
        expression: builtins.str,
        alias_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param expression: Expression name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#expression Dashboard#expression}
        :param alias_name: Expression alias. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias_name Dashboard#alias_name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "expression": expression,
        }
        if alias_name is not None:
            self._values["alias_name"] = alias_name

    @builtins.property
    def expression(self) -> builtins.str:
        '''Expression name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#expression Dashboard#expression}
        '''
        result = self._values.get("expression")
        assert result is not None, "Required property 'expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias_name(self) -> typing.Optional[builtins.str]:
        '''Expression alias.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias_name Dashboard#alias_name}
        '''
        result = self._values.get("alias_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery",
    jsii_struct_bases=[],
    name_mapping={
        "event_query": "eventQuery",
        "metric_query": "metricQuery",
        "process_query": "processQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery:
    def __init__(
        self,
        *,
        event_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery"]] = None,
        metric_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery"]] = None,
    ) -> None:
        '''
        :param event_query: event_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        :param metric_query: metric_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if event_query is not None:
            self._values["event_query"] = event_query
        if metric_query is not None:
            self._values["metric_query"] = metric_query
        if process_query is not None:
            self._values["process_query"] = process_query

    @builtins.property
    def event_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery"]]:
        '''event_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        '''
        result = self._values.get("event_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery"]], result)

    @builtins.property
    def metric_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery"]]:
        '''metric_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        '''
        result = self._values.get("metric_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery",
    jsii_struct_bases=[],
    name_mapping={
        "compute": "compute",
        "data_source": "dataSource",
        "name": "name",
        "group_by": "groupBy",
        "indexes": "indexes",
        "search": "search",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery:
    def __init__(
        self,
        *,
        compute: typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute"],
        data_source: builtins.str,
        name: builtins.str,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy"]] = None,
        indexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        search: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch"]] = None,
    ) -> None:
        '''
        :param compute: compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        :param data_source: Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param indexes: An array of index names to query in the stream. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        :param search: search block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "compute": compute,
            "data_source": data_source,
            "name": name,
        }
        if group_by is not None:
            self._values["group_by"] = group_by
        if indexes is not None:
            self._values["indexes"] = indexes
        if search is not None:
            self._values["search"] = search

    @builtins.property
    def compute(
        self,
    ) -> typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute"]:
        '''compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        '''
        result = self._values.get("compute")
        assert result is not None, "Required property 'compute' is missing"
        return typing.cast(typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute"], result)

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy"]], result)

    @builtins.property
    def indexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of index names to query in the stream.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        '''
        result = self._values.get("indexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def search(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch"]]:
        '''search block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        result = self._values.get("search")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "interval": "interval",
        "metric": "metric",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        interval: typing.Optional[jsii.Number] = None,
        metric: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param interval: A time interval in milliseconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        :param metric: Measurable attribute to compute. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if interval is not None:
            self._values["interval"] = interval
        if metric is not None:
            self._values["metric"] = metric

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''A time interval in milliseconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Measurable attribute to compute.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort": "sort"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy:
    def __init__(
        self,
        *,
        facet: builtins.str,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort"]] = None,
    ) -> None:
        '''
        :param facet: Event facet. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Number of groups to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: sort block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "facet": facet,
        }
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort

    @builtins.property
    def facet(self) -> builtins.str:
        '''Event facet.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        assert result is not None, "Required property 'facet' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of groups to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort"]]:
        '''sort block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "metric": "metric", "order": "order"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        metric: typing.Optional[builtins.str] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param metric: Metric used for sorting group by results. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if metric is not None:
            self._values["metric"] = metric
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric used for sorting group by results.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Events search string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Events search string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "query": "query",
        "aggregator": "aggregator",
        "data_source": "dataSource",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery:
    def __init__(
        self,
        *,
        name: builtins.str,
        query: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        data_source: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Name of the query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param query: Metrics query definition. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param data_source: Data source for metrics queries. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "query": query,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if data_source is not None:
            self._values["data_source"] = data_source

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''Metrics query definition.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def data_source(self) -> typing.Optional[builtins.str]:
        '''Data source for metrics queries.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "data_source": "dataSource",
        "metric": "metric",
        "name": "name",
        "aggregator": "aggregator",
        "is_normalized_cpu": "isNormalizedCpu",
        "limit": "limit",
        "sort": "sort",
        "tag_filters": "tagFilters",
        "text_filter": "textFilter",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery:
    def __init__(
        self,
        *,
        data_source: builtins.str,
        metric: builtins.str,
        name: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        is_normalized_cpu: typing.Optional[builtins.bool] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[builtins.str] = None,
        tag_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
        text_filter: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param data_source: Data source for process queries. Valid values are ``process``, ``container``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param metric: Process metric name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param is_normalized_cpu: Whether to normalize the CPU percentages. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        :param limit: Number of hits to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param tag_filters: An array of tags to filter by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        :param text_filter: Text to use as filter. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "data_source": data_source,
            "metric": metric,
            "name": name,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if is_normalized_cpu is not None:
            self._values["is_normalized_cpu"] = is_normalized_cpu
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort
        if tag_filters is not None:
            self._values["tag_filters"] = tag_filters
        if text_filter is not None:
            self._values["text_filter"] = text_filter

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for process queries. Valid values are ``process``, ``container``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> builtins.str:
        '''Process metric name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_normalized_cpu(self) -> typing.Optional[builtins.bool]:
        '''Whether to normalize the CPU percentages.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        '''
        result = self._values.get("is_normalized_cpu")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of hits to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_filters(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of tags to filter by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        '''
        result = self._values.get("tag_filters")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def text_filter(self) -> typing.Optional[builtins.str]:
        '''Text to use as filter.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        result = self._values.get("text_filter")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle",
    jsii_struct_bases=[],
    name_mapping={
        "line_type": "lineType",
        "line_width": "lineWidth",
        "palette": "palette",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle:
    def __init__(
        self,
        *,
        line_type: typing.Optional[builtins.str] = None,
        line_width: typing.Optional[builtins.str] = None,
        palette: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param line_type: Type of lines displayed. Valid values are ``dashed``, ``dotted``, ``solid``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#line_type Dashboard#line_type}
        :param line_width: Width of line displayed. Valid values are ``normal``, ``thick``, ``thin``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#line_width Dashboard#line_width}
        :param palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if line_type is not None:
            self._values["line_type"] = line_type
        if line_width is not None:
            self._values["line_width"] = line_width
        if palette is not None:
            self._values["palette"] = palette

    @builtins.property
    def line_type(self) -> typing.Optional[builtins.str]:
        '''Type of lines displayed. Valid values are ``dashed``, ``dotted``, ``solid``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#line_type Dashboard#line_type}
        '''
        result = self._values.get("line_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def line_width(self) -> typing.Optional[builtins.str]:
        '''Width of line displayed. Valid values are ``normal``, ``thick``, ``thin``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#line_width Dashboard#line_width}
        '''
        result = self._values.get("line_width")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def palette(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis",
    jsii_struct_bases=[],
    name_mapping={
        "include_zero": "includeZero",
        "label": "label",
        "max": "max",
        "min": "min",
        "scale": "scale",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis:
    def __init__(
        self,
        *,
        include_zero: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        max: typing.Optional[builtins.str] = None,
        min: typing.Optional[builtins.str] = None,
        scale: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param include_zero: Always include zero or fit the axis to the data range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        :param label: The label of the axis to display on the graph. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param max: Specify the maximum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        :param min: Specify the minimum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        :param scale: Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if include_zero is not None:
            self._values["include_zero"] = include_zero
        if label is not None:
            self._values["label"] = label
        if max is not None:
            self._values["max"] = max
        if min is not None:
            self._values["min"] = min
        if scale is not None:
            self._values["scale"] = scale

    @builtins.property
    def include_zero(self) -> typing.Optional[builtins.bool]:
        '''Always include zero or fit the axis to the data range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        '''
        result = self._values.get("include_zero")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label of the axis to display on the graph.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max(self) -> typing.Optional[builtins.str]:
        '''Specify the maximum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        '''
        result = self._values.get("max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def min(self) -> typing.Optional[builtins.str]:
        '''Specify the minimum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        '''
        result = self._values.get("min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale(self) -> typing.Optional[builtins.str]:
        '''Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        result = self._values.get("scale")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis",
    jsii_struct_bases=[],
    name_mapping={
        "include_zero": "includeZero",
        "label": "label",
        "max": "max",
        "min": "min",
        "scale": "scale",
    },
)
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis:
    def __init__(
        self,
        *,
        include_zero: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        max: typing.Optional[builtins.str] = None,
        min: typing.Optional[builtins.str] = None,
        scale: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param include_zero: Always include zero or fit the axis to the data range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        :param label: The label of the axis to display on the graph. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param max: Specify the maximum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        :param min: Specify the minimum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        :param scale: Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if include_zero is not None:
            self._values["include_zero"] = include_zero
        if label is not None:
            self._values["label"] = label
        if max is not None:
            self._values["max"] = max
        if min is not None:
            self._values["min"] = min
        if scale is not None:
            self._values["scale"] = scale

    @builtins.property
    def include_zero(self) -> typing.Optional[builtins.bool]:
        '''Always include zero or fit the axis to the data range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        '''
        result = self._values.get("include_zero")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label of the axis to display on the graph.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max(self) -> typing.Optional[builtins.str]:
        '''Specify the maximum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        '''
        result = self._values.get("max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def min(self) -> typing.Optional[builtins.str]:
        '''Specify the minimum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        '''
        result = self._values.get("min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale(self) -> typing.Optional[builtins.str]:
        '''Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        result = self._values.get("scale")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "live_span": "liveSpan",
        "request": "request",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink"]] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink"]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "conditional_formats": "conditionalFormats",
        "formula": "formula",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "query": "query",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
        "style": "style",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery"]] = None,
        conditional_formats: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormats"]] = None,
        formula: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery"]] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery"]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param conditional_formats: conditional_formats block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        :param formula: formula block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if conditional_formats is not None:
            self._values["conditional_formats"] = conditional_formats
        if formula is not None:
            self._values["formula"] = formula
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if query is not None:
            self._values["query"] = query
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query
        if style is not None:
            self._values["style"] = style

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery"]], result)

    @builtins.property
    def conditional_formats(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormats"]]:
        '''conditional_formats block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        '''
        result = self._values.get("conditional_formats")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormats"]], result)

    @builtins.property
    def formula(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula"]]:
        '''formula block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        '''
        result = self._values.get("formula")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery"]]:
        '''query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery"]], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery"]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormats",
    jsii_struct_bases=[],
    name_mapping={
        "comparator": "comparator",
        "palette": "palette",
        "value": "value",
        "custom_bg_color": "customBgColor",
        "custom_fg_color": "customFgColor",
        "hide_value": "hideValue",
        "image_url": "imageUrl",
        "metric": "metric",
        "timeframe": "timeframe",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormats:
    def __init__(
        self,
        *,
        comparator: builtins.str,
        palette: builtins.str,
        value: jsii.Number,
        custom_bg_color: typing.Optional[builtins.str] = None,
        custom_fg_color: typing.Optional[builtins.str] = None,
        hide_value: typing.Optional[builtins.bool] = None,
        image_url: typing.Optional[builtins.str] = None,
        metric: typing.Optional[builtins.str] = None,
        timeframe: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param comparator: Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        :param palette: Color palette to apply. Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        :param value: Value for the comparator. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        :param custom_bg_color: Color palette to apply to the background, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        :param custom_fg_color: Color palette to apply to the foreground, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        :param hide_value: Setting this to True hides values. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        :param image_url: Displays an image as the background. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        :param metric: Metric from the request to correlate this conditional format with. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param timeframe: Defines the displayed timeframe. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "comparator": comparator,
            "palette": palette,
            "value": value,
        }
        if custom_bg_color is not None:
            self._values["custom_bg_color"] = custom_bg_color
        if custom_fg_color is not None:
            self._values["custom_fg_color"] = custom_fg_color
        if hide_value is not None:
            self._values["hide_value"] = hide_value
        if image_url is not None:
            self._values["image_url"] = image_url
        if metric is not None:
            self._values["metric"] = metric
        if timeframe is not None:
            self._values["timeframe"] = timeframe

    @builtins.property
    def comparator(self) -> builtins.str:
        '''Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        '''
        result = self._values.get("comparator")
        assert result is not None, "Required property 'comparator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def palette(self) -> builtins.str:
        '''Color palette to apply.

        Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        assert result is not None, "Required property 'palette' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        '''Value for the comparator.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def custom_bg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the background, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        '''
        result = self._values.get("custom_bg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def custom_fg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the foreground, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        '''
        result = self._values.get("custom_fg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hide_value(self) -> typing.Optional[builtins.bool]:
        '''Setting this to True hides values.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        '''
        result = self._values.get("hide_value")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def image_url(self) -> typing.Optional[builtins.str]:
        '''Displays an image as the background.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        '''
        result = self._values.get("image_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric from the request to correlate this conditional format with.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timeframe(self) -> typing.Optional[builtins.str]:
        '''Defines the displayed timeframe.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        result = self._values.get("timeframe")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormats(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula",
    jsii_struct_bases=[],
    name_mapping={
        "formula_expression": "formulaExpression",
        "alias": "alias",
        "limit": "limit",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula:
    def __init__(
        self,
        *,
        formula_expression: builtins.str,
        alias: typing.Optional[builtins.str] = None,
        limit: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit"]] = None,
    ) -> None:
        '''
        :param formula_expression: String expression built from queries, formulas and functions. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        :param alias: Expression alias. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param limit: limit block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "formula_expression": formula_expression,
        }
        if alias is not None:
            self._values["alias"] = alias
        if limit is not None:
            self._values["limit"] = limit

    @builtins.property
    def formula_expression(self) -> builtins.str:
        '''String expression built from queries, formulas and functions.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        '''
        result = self._values.get("formula_expression")
        assert result is not None, "Required property 'formula_expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''Expression alias.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit"]]:
        '''limit block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit",
    jsii_struct_bases=[],
    name_mapping={"count": "count", "order": "order"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit:
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: Number of results to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''Number of results to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery",
    jsii_struct_bases=[],
    name_mapping={
        "event_query": "eventQuery",
        "metric_query": "metricQuery",
        "process_query": "processQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery:
    def __init__(
        self,
        *,
        event_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery"]] = None,
        metric_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery"]] = None,
    ) -> None:
        '''
        :param event_query: event_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        :param metric_query: metric_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if event_query is not None:
            self._values["event_query"] = event_query
        if metric_query is not None:
            self._values["metric_query"] = metric_query
        if process_query is not None:
            self._values["process_query"] = process_query

    @builtins.property
    def event_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery"]]:
        '''event_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        '''
        result = self._values.get("event_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery"]], result)

    @builtins.property
    def metric_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery"]]:
        '''metric_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        '''
        result = self._values.get("metric_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery",
    jsii_struct_bases=[],
    name_mapping={
        "compute": "compute",
        "data_source": "dataSource",
        "name": "name",
        "group_by": "groupBy",
        "indexes": "indexes",
        "search": "search",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery:
    def __init__(
        self,
        *,
        compute: typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute"],
        data_source: builtins.str,
        name: builtins.str,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy"]] = None,
        indexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        search: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch"]] = None,
    ) -> None:
        '''
        :param compute: compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        :param data_source: Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param indexes: An array of index names to query in the stream. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        :param search: search block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "compute": compute,
            "data_source": data_source,
            "name": name,
        }
        if group_by is not None:
            self._values["group_by"] = group_by
        if indexes is not None:
            self._values["indexes"] = indexes
        if search is not None:
            self._values["search"] = search

    @builtins.property
    def compute(
        self,
    ) -> typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute"]:
        '''compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        '''
        result = self._values.get("compute")
        assert result is not None, "Required property 'compute' is missing"
        return typing.cast(typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute"], result)

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy"]], result)

    @builtins.property
    def indexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of index names to query in the stream.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        '''
        result = self._values.get("indexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def search(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch"]]:
        '''search block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        result = self._values.get("search")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "interval": "interval",
        "metric": "metric",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        interval: typing.Optional[jsii.Number] = None,
        metric: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param interval: A time interval in milliseconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        :param metric: Measurable attribute to compute. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if interval is not None:
            self._values["interval"] = interval
        if metric is not None:
            self._values["metric"] = metric

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''A time interval in milliseconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Measurable attribute to compute.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort": "sort"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy:
    def __init__(
        self,
        *,
        facet: builtins.str,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort"]] = None,
    ) -> None:
        '''
        :param facet: Event facet. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Number of groups to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: sort block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "facet": facet,
        }
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort

    @builtins.property
    def facet(self) -> builtins.str:
        '''Event facet.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        assert result is not None, "Required property 'facet' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of groups to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort"]]:
        '''sort block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "metric": "metric", "order": "order"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        metric: typing.Optional[builtins.str] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param metric: Metric used for sorting group by results. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if metric is not None:
            self._values["metric"] = metric
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric used for sorting group by results.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Events search string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Events search string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "query": "query",
        "aggregator": "aggregator",
        "data_source": "dataSource",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery:
    def __init__(
        self,
        *,
        name: builtins.str,
        query: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        data_source: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Name of the query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param query: Metrics query definition. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param data_source: Data source for metrics queries. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "query": query,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if data_source is not None:
            self._values["data_source"] = data_source

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''Metrics query definition.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def data_source(self) -> typing.Optional[builtins.str]:
        '''Data source for metrics queries.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "data_source": "dataSource",
        "metric": "metric",
        "name": "name",
        "aggregator": "aggregator",
        "is_normalized_cpu": "isNormalizedCpu",
        "limit": "limit",
        "sort": "sort",
        "tag_filters": "tagFilters",
        "text_filter": "textFilter",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery:
    def __init__(
        self,
        *,
        data_source: builtins.str,
        metric: builtins.str,
        name: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        is_normalized_cpu: typing.Optional[builtins.bool] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[builtins.str] = None,
        tag_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
        text_filter: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param data_source: Data source for process queries. Valid values are ``process``, ``container``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param metric: Process metric name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param is_normalized_cpu: Whether to normalize the CPU percentages. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        :param limit: Number of hits to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param tag_filters: An array of tags to filter by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        :param text_filter: Text to use as filter. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "data_source": data_source,
            "metric": metric,
            "name": name,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if is_normalized_cpu is not None:
            self._values["is_normalized_cpu"] = is_normalized_cpu
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort
        if tag_filters is not None:
            self._values["tag_filters"] = tag_filters
        if text_filter is not None:
            self._values["text_filter"] = text_filter

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for process queries. Valid values are ``process``, ``container``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> builtins.str:
        '''Process metric name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_normalized_cpu(self) -> typing.Optional[builtins.bool]:
        '''Whether to normalize the CPU percentages.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        '''
        result = self._values.get("is_normalized_cpu")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of hits to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_filters(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of tags to filter by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        '''
        result = self._values.get("tag_filters")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def text_filter(self) -> typing.Optional[builtins.str]:
        '''Text to use as filter.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        result = self._values.get("text_filter")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle",
    jsii_struct_bases=[],
    name_mapping={"palette": "palette"},
)
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle:
    def __init__(self, *, palette: typing.Optional[builtins.str] = None) -> None:
        '''
        :param palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if palette is not None:
            self._values["palette"] = palette

    @builtins.property
    def palette(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "env": "env",
        "service": "service",
        "span_name": "spanName",
        "display_format": "displayFormat",
        "live_span": "liveSpan",
        "show_breakdown": "showBreakdown",
        "show_distribution": "showDistribution",
        "show_errors": "showErrors",
        "show_hits": "showHits",
        "show_latency": "showLatency",
        "show_resource_list": "showResourceList",
        "size_format": "sizeFormat",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition:
    def __init__(
        self,
        *,
        env: builtins.str,
        service: builtins.str,
        span_name: builtins.str,
        display_format: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        show_breakdown: typing.Optional[builtins.bool] = None,
        show_distribution: typing.Optional[builtins.bool] = None,
        show_errors: typing.Optional[builtins.bool] = None,
        show_hits: typing.Optional[builtins.bool] = None,
        show_latency: typing.Optional[builtins.bool] = None,
        show_resource_list: typing.Optional[builtins.bool] = None,
        size_format: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param env: APM environment. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#env Dashboard#env}
        :param service: APM service. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        :param span_name: APM span name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#span_name Dashboard#span_name}
        :param display_format: Number of columns to display. Valid values are ``one_column``, ``two_column``, ``three_column``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_format Dashboard#display_format}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param show_breakdown: Whether to show the latency breakdown or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_breakdown Dashboard#show_breakdown}
        :param show_distribution: Whether to show the latency distribution or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_distribution Dashboard#show_distribution}
        :param show_errors: Whether to show the error metrics or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_errors Dashboard#show_errors}
        :param show_hits: Whether to show the hits metrics or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_hits Dashboard#show_hits}
        :param show_latency: Whether to show the latency metrics or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_latency Dashboard#show_latency}
        :param show_resource_list: Whether to show the resource list or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_resource_list Dashboard#show_resource_list}
        :param size_format: Size of the widget. Valid values are ``small``, ``medium``, ``large``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#size_format Dashboard#size_format}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "env": env,
            "service": service,
            "span_name": span_name,
        }
        if display_format is not None:
            self._values["display_format"] = display_format
        if live_span is not None:
            self._values["live_span"] = live_span
        if show_breakdown is not None:
            self._values["show_breakdown"] = show_breakdown
        if show_distribution is not None:
            self._values["show_distribution"] = show_distribution
        if show_errors is not None:
            self._values["show_errors"] = show_errors
        if show_hits is not None:
            self._values["show_hits"] = show_hits
        if show_latency is not None:
            self._values["show_latency"] = show_latency
        if show_resource_list is not None:
            self._values["show_resource_list"] = show_resource_list
        if size_format is not None:
            self._values["size_format"] = size_format
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def env(self) -> builtins.str:
        '''APM environment.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#env Dashboard#env}
        '''
        result = self._values.get("env")
        assert result is not None, "Required property 'env' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> builtins.str:
        '''APM service.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def span_name(self) -> builtins.str:
        '''APM span name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#span_name Dashboard#span_name}
        '''
        result = self._values.get("span_name")
        assert result is not None, "Required property 'span_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def display_format(self) -> typing.Optional[builtins.str]:
        '''Number of columns to display. Valid values are ``one_column``, ``two_column``, ``three_column``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_format Dashboard#display_format}
        '''
        result = self._values.get("display_format")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def show_breakdown(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the latency breakdown or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_breakdown Dashboard#show_breakdown}
        '''
        result = self._values.get("show_breakdown")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_distribution(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the latency distribution or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_distribution Dashboard#show_distribution}
        '''
        result = self._values.get("show_distribution")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_errors(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the error metrics or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_errors Dashboard#show_errors}
        '''
        result = self._values.get("show_errors")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_hits(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the hits metrics or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_hits Dashboard#show_hits}
        '''
        result = self._values.get("show_hits")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_latency(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the latency metrics or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_latency Dashboard#show_latency}
        '''
        result = self._values.get("show_latency")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_resource_list(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the resource list or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_resource_list Dashboard#show_resource_list}
        '''
        result = self._values.get("show_resource_list")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def size_format(self) -> typing.Optional[builtins.str]:
        '''Size of the widget. Valid values are ``small``, ``medium``, ``large``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#size_format Dashboard#size_format}
        '''
        result = self._values.get("size_format")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetGroupDefinitionWidgetWidgetLayout",
    jsii_struct_bases=[],
    name_mapping={
        "height": "height",
        "width": "width",
        "x": "x",
        "y": "y",
        "is_column_break": "isColumnBreak",
    },
)
class DashboardWidgetGroupDefinitionWidgetWidgetLayout:
    def __init__(
        self,
        *,
        height: jsii.Number,
        width: jsii.Number,
        x: jsii.Number,
        y: jsii.Number,
        is_column_break: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param height: The height of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#height Dashboard#height}
        :param width: The width of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#width Dashboard#width}
        :param x: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#x Dashboard#x}
        :param y: The position of the widget on the y (vertical) axis. Should be greater or equal to 0. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#y Dashboard#y}
        :param is_column_break: Whether the widget should be the first one on the second column in high density or not. Only for the new dashboard layout and only one widget in the dashboard should have this property set to ``true``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_column_break Dashboard#is_column_break}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "height": height,
            "width": width,
            "x": x,
            "y": y,
        }
        if is_column_break is not None:
            self._values["is_column_break"] = is_column_break

    @builtins.property
    def height(self) -> jsii.Number:
        '''The height of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#height Dashboard#height}
        '''
        result = self._values.get("height")
        assert result is not None, "Required property 'height' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def width(self) -> jsii.Number:
        '''The width of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#width Dashboard#width}
        '''
        result = self._values.get("width")
        assert result is not None, "Required property 'width' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def x(self) -> jsii.Number:
        '''The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#x Dashboard#x}
        '''
        result = self._values.get("x")
        assert result is not None, "Required property 'x' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def y(self) -> jsii.Number:
        '''The position of the widget on the y (vertical) axis. Should be greater or equal to 0.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#y Dashboard#y}
        '''
        result = self._values.get("y")
        assert result is not None, "Required property 'y' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def is_column_break(self) -> typing.Optional[builtins.bool]:
        '''Whether the widget should be the first one on the second column in high density or not.

        Only for the new dashboard layout and only one widget in the dashboard should have this property set to ``true``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_column_break Dashboard#is_column_break}
        '''
        result = self._values.get("is_column_break")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetGroupDefinitionWidgetWidgetLayout(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "event": "event",
        "legend_size": "legendSize",
        "live_span": "liveSpan",
        "request": "request",
        "show_legend": "showLegend",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
        "yaxis": "yaxis",
    },
)
class DashboardWidgetHeatmapDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionCustomLink"]] = None,
        event: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionEvent"]] = None,
        legend_size: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequest"]] = None,
        show_legend: typing.Optional[builtins.bool] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
        yaxis: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionYaxis"]] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param event: event block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event Dashboard#event}
        :param legend_size: The size of the legend displayed in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param show_legend: Whether or not to show the legend on this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        :param yaxis: yaxis block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if event is not None:
            self._values["event"] = event
        if legend_size is not None:
            self._values["legend_size"] = legend_size
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if show_legend is not None:
            self._values["show_legend"] = show_legend
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size
        if yaxis is not None:
            self._values["yaxis"] = yaxis

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionCustomLink"]], result)

    @builtins.property
    def event(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionEvent"]]:
        '''event block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event Dashboard#event}
        '''
        result = self._values.get("event")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionEvent"]], result)

    @builtins.property
    def legend_size(self) -> typing.Optional[builtins.str]:
        '''The size of the legend displayed in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        '''
        result = self._values.get("legend_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequest"]], result)

    @builtins.property
    def show_legend(self) -> typing.Optional[builtins.bool]:
        '''Whether or not to show the legend on this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        '''
        result = self._values.get("show_legend")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def yaxis(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionYaxis"]]:
        '''yaxis block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        result = self._values.get("yaxis")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionYaxis"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetHeatmapDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionEvent",
    jsii_struct_bases=[],
    name_mapping={"q": "q", "tags_execution": "tagsExecution"},
)
class DashboardWidgetHeatmapDefinitionEvent:
    def __init__(
        self,
        *,
        q: builtins.str,
        tags_execution: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param q: The event query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param tags_execution: The execution method for multi-value filters. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "q": q,
        }
        if tags_execution is not None:
            self._values["tags_execution"] = tags_execution

    @builtins.property
    def q(self) -> builtins.str:
        '''The event query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        assert result is not None, "Required property 'q' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags_execution(self) -> typing.Optional[builtins.str]:
        '''The execution method for multi-value filters.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        result = self._values.get("tags_execution")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionEvent(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
        "style": "style",
    },
)
class DashboardWidgetHeatmapDefinitionRequest:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestSecurityQuery"]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestStyle"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query
        if style is not None:
            self._values["style"] = style

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestSecurityQuery"]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestStyle"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHeatmapDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHeatmapDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetHeatmapDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHeatmapDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHeatmapDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionRequestStyle",
    jsii_struct_bases=[],
    name_mapping={"palette": "palette"},
)
class DashboardWidgetHeatmapDefinitionRequestStyle:
    def __init__(self, *, palette: typing.Optional[builtins.str] = None) -> None:
        '''
        :param palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if palette is not None:
            self._values["palette"] = palette

    @builtins.property
    def palette(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionRequestStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHeatmapDefinitionYaxis",
    jsii_struct_bases=[],
    name_mapping={
        "include_zero": "includeZero",
        "label": "label",
        "max": "max",
        "min": "min",
        "scale": "scale",
    },
)
class DashboardWidgetHeatmapDefinitionYaxis:
    def __init__(
        self,
        *,
        include_zero: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        max: typing.Optional[builtins.str] = None,
        min: typing.Optional[builtins.str] = None,
        scale: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param include_zero: Always include zero or fit the axis to the data range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        :param label: The label of the axis to display on the graph. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param max: Specify the maximum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        :param min: Specify the minimum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        :param scale: Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if include_zero is not None:
            self._values["include_zero"] = include_zero
        if label is not None:
            self._values["label"] = label
        if max is not None:
            self._values["max"] = max
        if min is not None:
            self._values["min"] = min
        if scale is not None:
            self._values["scale"] = scale

    @builtins.property
    def include_zero(self) -> typing.Optional[builtins.bool]:
        '''Always include zero or fit the axis to the data range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        '''
        result = self._values.get("include_zero")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label of the axis to display on the graph.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max(self) -> typing.Optional[builtins.str]:
        '''Specify the maximum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        '''
        result = self._values.get("max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def min(self) -> typing.Optional[builtins.str]:
        '''Specify the minimum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        '''
        result = self._values.get("min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale(self) -> typing.Optional[builtins.str]:
        '''Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        result = self._values.get("scale")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHeatmapDefinitionYaxis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "group": "group",
        "node_type": "nodeType",
        "no_group_hosts": "noGroupHosts",
        "no_metric_hosts": "noMetricHosts",
        "request": "request",
        "scope": "scope",
        "style": "style",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetHostmapDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionCustomLink"]] = None,
        group: typing.Optional[typing.Sequence[builtins.str]] = None,
        node_type: typing.Optional[builtins.str] = None,
        no_group_hosts: typing.Optional[builtins.bool] = None,
        no_metric_hosts: typing.Optional[builtins.bool] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequest"]] = None,
        scope: typing.Optional[typing.Sequence[builtins.str]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionStyle"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param group: The list of tags to group nodes by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group Dashboard#group}
        :param node_type: The type of node used. Valid values are ``host``, ``container``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#node_type Dashboard#node_type}
        :param no_group_hosts: Boolean indicating whether to show ungrouped nodes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#no_group_hosts Dashboard#no_group_hosts}
        :param no_metric_hosts: Boolean indicating whether to show nodes with no metrics. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#no_metric_hosts Dashboard#no_metric_hosts}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param scope: The list of tags to filter nodes by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scope Dashboard#scope}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if group is not None:
            self._values["group"] = group
        if node_type is not None:
            self._values["node_type"] = node_type
        if no_group_hosts is not None:
            self._values["no_group_hosts"] = no_group_hosts
        if no_metric_hosts is not None:
            self._values["no_metric_hosts"] = no_metric_hosts
        if request is not None:
            self._values["request"] = request
        if scope is not None:
            self._values["scope"] = scope
        if style is not None:
            self._values["style"] = style
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionCustomLink"]], result)

    @builtins.property
    def group(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of tags to group nodes by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group Dashboard#group}
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def node_type(self) -> typing.Optional[builtins.str]:
        '''The type of node used. Valid values are ``host``, ``container``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#node_type Dashboard#node_type}
        '''
        result = self._values.get("node_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def no_group_hosts(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to show ungrouped nodes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#no_group_hosts Dashboard#no_group_hosts}
        '''
        result = self._values.get("no_group_hosts")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def no_metric_hosts(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to show nodes with no metrics.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#no_metric_hosts Dashboard#no_metric_hosts}
        '''
        result = self._values.get("no_metric_hosts")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequest"]], result)

    @builtins.property
    def scope(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of tags to filter nodes by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scope Dashboard#scope}
        '''
        result = self._values.get("scope")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionStyle"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetHostmapDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={"fill": "fill", "size": "size"},
)
class DashboardWidgetHostmapDefinitionRequest:
    def __init__(
        self,
        *,
        fill: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFill"]] = None,
        size: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSize"]] = None,
    ) -> None:
        '''
        :param fill: fill block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill Dashboard#fill}
        :param size: size block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#size Dashboard#size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if fill is not None:
            self._values["fill"] = fill
        if size is not None:
            self._values["size"] = size

    @builtins.property
    def fill(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFill"]]:
        '''fill block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill Dashboard#fill}
        '''
        result = self._values.get("fill")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFill"]], result)

    @builtins.property
    def size(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSize"]]:
        '''size block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#size Dashboard#size}
        '''
        result = self._values.get("size")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSize"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFill",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetHostmapDefinitionRequestFill:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillSecurityQuery"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFill(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSize",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetHostmapDefinitionRequestSize:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSize(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetHostmapDefinitionStyle",
    jsii_struct_bases=[],
    name_mapping={
        "fill_max": "fillMax",
        "fill_min": "fillMin",
        "palette": "palette",
        "palette_flip": "paletteFlip",
    },
)
class DashboardWidgetHostmapDefinitionStyle:
    def __init__(
        self,
        *,
        fill_max: typing.Optional[builtins.str] = None,
        fill_min: typing.Optional[builtins.str] = None,
        palette: typing.Optional[builtins.str] = None,
        palette_flip: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param fill_max: Max value to use to color the map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill_max Dashboard#fill_max}
        :param fill_min: Min value to use to color the map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill_min Dashboard#fill_min}
        :param palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        :param palette_flip: Boolean indicating whether to flip the palette tones. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette_flip Dashboard#palette_flip}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if fill_max is not None:
            self._values["fill_max"] = fill_max
        if fill_min is not None:
            self._values["fill_min"] = fill_min
        if palette is not None:
            self._values["palette"] = palette
        if palette_flip is not None:
            self._values["palette_flip"] = palette_flip

    @builtins.property
    def fill_max(self) -> typing.Optional[builtins.str]:
        '''Max value to use to color the map.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill_max Dashboard#fill_max}
        '''
        result = self._values.get("fill_max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fill_min(self) -> typing.Optional[builtins.str]:
        '''Min value to use to color the map.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#fill_min Dashboard#fill_min}
        '''
        result = self._values.get("fill_min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def palette(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def palette_flip(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to flip the palette tones.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette_flip Dashboard#palette_flip}
        '''
        result = self._values.get("palette_flip")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetHostmapDefinitionStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetIframeDefinition",
    jsii_struct_bases=[],
    name_mapping={"url": "url"},
)
class DashboardWidgetIframeDefinition:
    def __init__(self, *, url: builtins.str) -> None:
        '''
        :param url: The URL to use as a data source for the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url Dashboard#url}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "url": url,
        }

    @builtins.property
    def url(self) -> builtins.str:
        '''The URL to use as a data source for the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url Dashboard#url}
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetIframeDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetImageDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "url": "url",
        "has_background": "hasBackground",
        "has_border": "hasBorder",
        "horizontal_align": "horizontalAlign",
        "margin": "margin",
        "sizing": "sizing",
        "url_dark_theme": "urlDarkTheme",
        "vertical_align": "verticalAlign",
    },
)
class DashboardWidgetImageDefinition:
    def __init__(
        self,
        *,
        url: builtins.str,
        has_background: typing.Optional[builtins.bool] = None,
        has_border: typing.Optional[builtins.bool] = None,
        horizontal_align: typing.Optional[builtins.str] = None,
        margin: typing.Optional[builtins.str] = None,
        sizing: typing.Optional[builtins.str] = None,
        url_dark_theme: typing.Optional[builtins.str] = None,
        vertical_align: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param url: The URL to use as a data source for the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url Dashboard#url}
        :param has_background: Whether to display a background or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_background Dashboard#has_background}
        :param has_border: Whether to display a border or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_border Dashboard#has_border}
        :param horizontal_align: The horizontal alignment for the widget. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#horizontal_align Dashboard#horizontal_align}
        :param margin: The margins to use around the image. Note: ``small`` and ``large`` values are deprecated. Valid values are ``sm``, ``md``, ``lg``, ``small``, ``large``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#margin Dashboard#margin}
        :param sizing: The preferred method to adapt the dimensions of the image. The values are based on the image ``object-fit`` CSS properties. Note: ``zoom``, ``fit`` and ``center`` values are deprecated. Valid values are ``fill``, ``contain``, ``cover``, ``none``, ``scale-down``, ``zoom``, ``fit``, ``center``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sizing Dashboard#sizing}
        :param url_dark_theme: The URL in dark mode to use as a data source for the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url_dark_theme Dashboard#url_dark_theme}
        :param vertical_align: The vertical alignment for the widget. Valid values are ``center``, ``top``, ``bottom``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#vertical_align Dashboard#vertical_align}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "url": url,
        }
        if has_background is not None:
            self._values["has_background"] = has_background
        if has_border is not None:
            self._values["has_border"] = has_border
        if horizontal_align is not None:
            self._values["horizontal_align"] = horizontal_align
        if margin is not None:
            self._values["margin"] = margin
        if sizing is not None:
            self._values["sizing"] = sizing
        if url_dark_theme is not None:
            self._values["url_dark_theme"] = url_dark_theme
        if vertical_align is not None:
            self._values["vertical_align"] = vertical_align

    @builtins.property
    def url(self) -> builtins.str:
        '''The URL to use as a data source for the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url Dashboard#url}
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def has_background(self) -> typing.Optional[builtins.bool]:
        '''Whether to display a background or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_background Dashboard#has_background}
        '''
        result = self._values.get("has_background")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def has_border(self) -> typing.Optional[builtins.bool]:
        '''Whether to display a border or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_border Dashboard#has_border}
        '''
        result = self._values.get("has_border")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def horizontal_align(self) -> typing.Optional[builtins.str]:
        '''The horizontal alignment for the widget. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#horizontal_align Dashboard#horizontal_align}
        '''
        result = self._values.get("horizontal_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def margin(self) -> typing.Optional[builtins.str]:
        '''The margins to use around the image.

        Note: ``small`` and ``large`` values are deprecated. Valid values are ``sm``, ``md``, ``lg``, ``small``, ``large``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#margin Dashboard#margin}
        '''
        result = self._values.get("margin")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sizing(self) -> typing.Optional[builtins.str]:
        '''The preferred method to adapt the dimensions of the image.

        The values are based on the image ``object-fit`` CSS properties. Note: ``zoom``, ``fit`` and ``center`` values are deprecated. Valid values are ``fill``, ``contain``, ``cover``, ``none``, ``scale-down``, ``zoom``, ``fit``, ``center``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sizing Dashboard#sizing}
        '''
        result = self._values.get("sizing")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url_dark_theme(self) -> typing.Optional[builtins.str]:
        '''The URL in dark mode to use as a data source for the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#url_dark_theme Dashboard#url_dark_theme}
        '''
        result = self._values.get("url_dark_theme")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vertical_align(self) -> typing.Optional[builtins.str]:
        '''The vertical alignment for the widget. Valid values are ``center``, ``top``, ``bottom``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#vertical_align Dashboard#vertical_align}
        '''
        result = self._values.get("vertical_align")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetImageDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetLogStreamDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "columns": "columns",
        "indexes": "indexes",
        "live_span": "liveSpan",
        "message_display": "messageDisplay",
        "query": "query",
        "show_date_column": "showDateColumn",
        "show_message_column": "showMessageColumn",
        "sort": "sort",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetLogStreamDefinition:
    def __init__(
        self,
        *,
        columns: typing.Optional[typing.Sequence[builtins.str]] = None,
        indexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        live_span: typing.Optional[builtins.str] = None,
        message_display: typing.Optional[builtins.str] = None,
        query: typing.Optional[builtins.str] = None,
        show_date_column: typing.Optional[builtins.bool] = None,
        show_message_column: typing.Optional[builtins.bool] = None,
        sort: typing.Optional[typing.Sequence["DashboardWidgetLogStreamDefinitionSort"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param columns: Stringified list of columns to use. Example: ``["column1","column2","column3"]``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#columns Dashboard#columns}
        :param indexes: An array of index names to query in the stream. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param message_display: Amount of log lines to display. Valid values are ``inline``, ``expanded-md``, ``expanded-lg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#message_display Dashboard#message_display}
        :param query: The query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param show_date_column: If the date column should be displayed. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_date_column Dashboard#show_date_column}
        :param show_message_column: If the message column should be displayed. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_message_column Dashboard#show_message_column}
        :param sort: sort block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if columns is not None:
            self._values["columns"] = columns
        if indexes is not None:
            self._values["indexes"] = indexes
        if live_span is not None:
            self._values["live_span"] = live_span
        if message_display is not None:
            self._values["message_display"] = message_display
        if query is not None:
            self._values["query"] = query
        if show_date_column is not None:
            self._values["show_date_column"] = show_date_column
        if show_message_column is not None:
            self._values["show_message_column"] = show_message_column
        if sort is not None:
            self._values["sort"] = sort
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def columns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Stringified list of columns to use. Example: ``["column1","column2","column3"]``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#columns Dashboard#columns}
        '''
        result = self._values.get("columns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def indexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of index names to query in the stream.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        '''
        result = self._values.get("indexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def message_display(self) -> typing.Optional[builtins.str]:
        '''Amount of log lines to display. Valid values are ``inline``, ``expanded-md``, ``expanded-lg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#message_display Dashboard#message_display}
        '''
        result = self._values.get("message_display")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query(self) -> typing.Optional[builtins.str]:
        '''The query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def show_date_column(self) -> typing.Optional[builtins.bool]:
        '''If the date column should be displayed.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_date_column Dashboard#show_date_column}
        '''
        result = self._values.get("show_date_column")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_message_column(self) -> typing.Optional[builtins.bool]:
        '''If the message column should be displayed.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_message_column Dashboard#show_message_column}
        '''
        result = self._values.get("show_message_column")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def sort(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetLogStreamDefinitionSort"]]:
        '''sort block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetLogStreamDefinitionSort"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetLogStreamDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetLogStreamDefinitionSort",
    jsii_struct_bases=[],
    name_mapping={"column": "column", "order": "order"},
)
class DashboardWidgetLogStreamDefinitionSort:
    def __init__(self, *, column: builtins.str, order: builtins.str) -> None:
        '''
        :param column: Facet path for the column. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#column Dashboard#column}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "column": column,
            "order": order,
        }

    @builtins.property
    def column(self) -> builtins.str:
        '''Facet path for the column.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#column Dashboard#column}
        '''
        result = self._values.get("column")
        assert result is not None, "Required property 'column' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetLogStreamDefinitionSort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetManageStatusDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "query": "query",
        "color_preference": "colorPreference",
        "display_format": "displayFormat",
        "hide_zero_counts": "hideZeroCounts",
        "show_last_triggered": "showLastTriggered",
        "sort": "sort",
        "summary_type": "summaryType",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetManageStatusDefinition:
    def __init__(
        self,
        *,
        query: builtins.str,
        color_preference: typing.Optional[builtins.str] = None,
        display_format: typing.Optional[builtins.str] = None,
        hide_zero_counts: typing.Optional[builtins.bool] = None,
        show_last_triggered: typing.Optional[builtins.bool] = None,
        sort: typing.Optional[builtins.str] = None,
        summary_type: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param query: The query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param color_preference: Whether to colorize text or background. Valid values are ``background``, ``text``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color_preference Dashboard#color_preference}
        :param display_format: The display setting to use. Valid values are ``counts``, ``countsAndList``, ``list``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_format Dashboard#display_format}
        :param hide_zero_counts: Boolean indicating whether to hide empty categories. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_zero_counts Dashboard#hide_zero_counts}
        :param show_last_triggered: Boolean indicating whether to show when monitors/groups last triggered. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_last_triggered Dashboard#show_last_triggered}
        :param sort: The method to use to sort monitors. Valid values are ``name``, ``group``, ``status``, ``tags``, ``triggered``, ``group,asc``, ``group,desc``, ``name,asc``, ``name,desc``, ``status,asc``, ``status,desc``, ``tags,asc``, ``tags,desc``, ``triggered,asc``, ``triggered,desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param summary_type: Which summary type should be used. Valid values are ``monitors``, ``groups``, ``combined``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#summary_type Dashboard#summary_type}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }
        if color_preference is not None:
            self._values["color_preference"] = color_preference
        if display_format is not None:
            self._values["display_format"] = display_format
        if hide_zero_counts is not None:
            self._values["hide_zero_counts"] = hide_zero_counts
        if show_last_triggered is not None:
            self._values["show_last_triggered"] = show_last_triggered
        if sort is not None:
            self._values["sort"] = sort
        if summary_type is not None:
            self._values["summary_type"] = summary_type
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def query(self) -> builtins.str:
        '''The query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def color_preference(self) -> typing.Optional[builtins.str]:
        '''Whether to colorize text or background. Valid values are ``background``, ``text``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color_preference Dashboard#color_preference}
        '''
        result = self._values.get("color_preference")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def display_format(self) -> typing.Optional[builtins.str]:
        '''The display setting to use. Valid values are ``counts``, ``countsAndList``, ``list``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_format Dashboard#display_format}
        '''
        result = self._values.get("display_format")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hide_zero_counts(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to hide empty categories.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_zero_counts Dashboard#hide_zero_counts}
        '''
        result = self._values.get("hide_zero_counts")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_last_triggered(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to show when monitors/groups last triggered.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_last_triggered Dashboard#show_last_triggered}
        '''
        result = self._values.get("show_last_triggered")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def sort(self) -> typing.Optional[builtins.str]:
        '''The method to use to sort monitors.

        Valid values are ``name``, ``group``, ``status``, ``tags``, ``triggered``, ``group,asc``, ``group,desc``, ``name,asc``, ``name,desc``, ``status,asc``, ``status,desc``, ``tags,asc``, ``tags,desc``, ``triggered,asc``, ``triggered,desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def summary_type(self) -> typing.Optional[builtins.str]:
        '''Which summary type should be used. Valid values are ``monitors``, ``groups``, ``combined``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#summary_type Dashboard#summary_type}
        '''
        result = self._values.get("summary_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetManageStatusDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetNoteDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "content": "content",
        "background_color": "backgroundColor",
        "font_size": "fontSize",
        "has_padding": "hasPadding",
        "show_tick": "showTick",
        "text_align": "textAlign",
        "tick_edge": "tickEdge",
        "tick_pos": "tickPos",
        "vertical_align": "verticalAlign",
    },
)
class DashboardWidgetNoteDefinition:
    def __init__(
        self,
        *,
        content: builtins.str,
        background_color: typing.Optional[builtins.str] = None,
        font_size: typing.Optional[builtins.str] = None,
        has_padding: typing.Optional[builtins.bool] = None,
        show_tick: typing.Optional[builtins.bool] = None,
        text_align: typing.Optional[builtins.str] = None,
        tick_edge: typing.Optional[builtins.str] = None,
        tick_pos: typing.Optional[builtins.str] = None,
        vertical_align: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param content: Content of the note. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#content Dashboard#content}
        :param background_color: Background color of the note. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#background_color Dashboard#background_color}
        :param font_size: Size of the text. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#font_size Dashboard#font_size}
        :param has_padding: Whether to add padding or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_padding Dashboard#has_padding}
        :param show_tick: Whether to show a tick or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_tick Dashboard#show_tick}
        :param text_align: The alignment of the widget's text. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        :param tick_edge: When ``tick = true``, string indicating on which side of the widget the tick should be displayed. Valid values are ``bottom``, ``left``, ``right``, ``top``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tick_edge Dashboard#tick_edge}
        :param tick_pos: When ``tick = true``, string with a percent sign indicating the position of the tick. Example: use ``tick_pos = "50%"`` for centered alignment. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tick_pos Dashboard#tick_pos}
        :param vertical_align: The vertical alignment for the widget. Valid values are ``center``, ``top``, ``bottom``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#vertical_align Dashboard#vertical_align}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "content": content,
        }
        if background_color is not None:
            self._values["background_color"] = background_color
        if font_size is not None:
            self._values["font_size"] = font_size
        if has_padding is not None:
            self._values["has_padding"] = has_padding
        if show_tick is not None:
            self._values["show_tick"] = show_tick
        if text_align is not None:
            self._values["text_align"] = text_align
        if tick_edge is not None:
            self._values["tick_edge"] = tick_edge
        if tick_pos is not None:
            self._values["tick_pos"] = tick_pos
        if vertical_align is not None:
            self._values["vertical_align"] = vertical_align

    @builtins.property
    def content(self) -> builtins.str:
        '''Content of the note.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#content Dashboard#content}
        '''
        result = self._values.get("content")
        assert result is not None, "Required property 'content' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def background_color(self) -> typing.Optional[builtins.str]:
        '''Background color of the note.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#background_color Dashboard#background_color}
        '''
        result = self._values.get("background_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def font_size(self) -> typing.Optional[builtins.str]:
        '''Size of the text.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#font_size Dashboard#font_size}
        '''
        result = self._values.get("font_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def has_padding(self) -> typing.Optional[builtins.bool]:
        '''Whether to add padding or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_padding Dashboard#has_padding}
        '''
        result = self._values.get("has_padding")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_tick(self) -> typing.Optional[builtins.bool]:
        '''Whether to show a tick or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_tick Dashboard#show_tick}
        '''
        result = self._values.get("show_tick")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def text_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's text. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        '''
        result = self._values.get("text_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tick_edge(self) -> typing.Optional[builtins.str]:
        '''When ``tick = true``, string indicating on which side of the widget the tick should be displayed.

        Valid values are ``bottom``, ``left``, ``right``, ``top``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tick_edge Dashboard#tick_edge}
        '''
        result = self._values.get("tick_edge")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tick_pos(self) -> typing.Optional[builtins.str]:
        '''When ``tick = true``, string with a percent sign indicating the position of the tick.

        Example: use ``tick_pos = "50%"`` for centered alignment.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tick_pos Dashboard#tick_pos}
        '''
        result = self._values.get("tick_pos")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vertical_align(self) -> typing.Optional[builtins.str]:
        '''The vertical alignment for the widget. Valid values are ``center``, ``top``, ``bottom``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#vertical_align Dashboard#vertical_align}
        '''
        result = self._values.get("vertical_align")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetNoteDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "has_search_bar": "hasSearchBar",
        "live_span": "liveSpan",
        "request": "request",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetQueryTableDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionCustomLink"]] = None,
        has_search_bar: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequest"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param has_search_bar: Controls the display of the search bar. Valid values are ``always``, ``never``, ``auto``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_search_bar Dashboard#has_search_bar}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if has_search_bar is not None:
            self._values["has_search_bar"] = has_search_bar
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionCustomLink"]], result)

    @builtins.property
    def has_search_bar(self) -> typing.Optional[builtins.str]:
        '''Controls the display of the search bar. Valid values are ``always``, ``never``, ``auto``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#has_search_bar Dashboard#has_search_bar}
        '''
        result = self._values.get("has_search_bar")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequest"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetQueryTableDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "aggregator": "aggregator",
        "alias": "alias",
        "apm_query": "apmQuery",
        "apm_stats_query": "apmStatsQuery",
        "cell_display_mode": "cellDisplayMode",
        "conditional_formats": "conditionalFormats",
        "limit": "limit",
        "log_query": "logQuery",
        "order": "order",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetQueryTableDefinitionRequest:
    def __init__(
        self,
        *,
        aggregator: typing.Optional[builtins.str] = None,
        alias: typing.Optional[builtins.str] = None,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestApmQuery"]] = None,
        apm_stats_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestApmStatsQuery"]] = None,
        cell_display_mode: typing.Optional[typing.Sequence[builtins.str]] = None,
        conditional_formats: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestConditionalFormats"]] = None,
        limit: typing.Optional[jsii.Number] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestLogQuery"]] = None,
        order: typing.Optional[builtins.str] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestSecurityQuery"]] = None,
    ) -> None:
        '''
        :param aggregator: The aggregator to use for time aggregation. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param alias: The alias for the column name. Default is the metric name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param apm_stats_query: apm_stats_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_stats_query Dashboard#apm_stats_query}
        :param cell_display_mode: A list of display modes for each table cell. List items one of ``number``, ``bar``. Valid values are ``number``, ``bar``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#cell_display_mode Dashboard#cell_display_mode}
        :param conditional_formats: conditional_formats block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        :param limit: The number of lines to show in the table. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param order: The sort order for the rows. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if alias is not None:
            self._values["alias"] = alias
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if apm_stats_query is not None:
            self._values["apm_stats_query"] = apm_stats_query
        if cell_display_mode is not None:
            self._values["cell_display_mode"] = cell_display_mode
        if conditional_formats is not None:
            self._values["conditional_formats"] = conditional_formats
        if limit is not None:
            self._values["limit"] = limit
        if log_query is not None:
            self._values["log_query"] = log_query
        if order is not None:
            self._values["order"] = order
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregator to use for time aggregation. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''The alias for the column name. Default is the metric name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmQuery"]], result)

    @builtins.property
    def apm_stats_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmStatsQuery"]]:
        '''apm_stats_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_stats_query Dashboard#apm_stats_query}
        '''
        result = self._values.get("apm_stats_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmStatsQuery"]], result)

    @builtins.property
    def cell_display_mode(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of display modes for each table cell.

        List items one of ``number``, ``bar``. Valid values are ``number``, ``bar``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#cell_display_mode Dashboard#cell_display_mode}
        '''
        result = self._values.get("cell_display_mode")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def conditional_formats(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestConditionalFormats"]]:
        '''conditional_formats block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        '''
        result = self._values.get("conditional_formats")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestConditionalFormats"]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''The number of lines to show in the table.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestLogQuery"]], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''The sort order for the rows. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetQueryTableDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestApmStatsQuery",
    jsii_struct_bases=[],
    name_mapping={
        "env": "env",
        "name": "name",
        "primary_tag": "primaryTag",
        "row_type": "rowType",
        "service": "service",
        "columns": "columns",
        "resource": "resource",
    },
)
class DashboardWidgetQueryTableDefinitionRequestApmStatsQuery:
    def __init__(
        self,
        *,
        env: builtins.str,
        name: builtins.str,
        primary_tag: builtins.str,
        row_type: builtins.str,
        service: builtins.str,
        columns: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumns"]] = None,
        resource: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param env: Environment name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#env Dashboard#env}
        :param name: Operation name associated with service. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param primary_tag: The organization's host group name and value. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#primary_tag Dashboard#primary_tag}
        :param row_type: The level of detail for the request. Valid values are ``service``, ``resource``, ``span``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#row_type Dashboard#row_type}
        :param service: Service name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        :param columns: columns block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#columns Dashboard#columns}
        :param resource: Resource name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#resource Dashboard#resource}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "env": env,
            "name": name,
            "primary_tag": primary_tag,
            "row_type": row_type,
            "service": service,
        }
        if columns is not None:
            self._values["columns"] = columns
        if resource is not None:
            self._values["resource"] = resource

    @builtins.property
    def env(self) -> builtins.str:
        '''Environment name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#env Dashboard#env}
        '''
        result = self._values.get("env")
        assert result is not None, "Required property 'env' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Operation name associated with service.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def primary_tag(self) -> builtins.str:
        '''The organization's host group name and value.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#primary_tag Dashboard#primary_tag}
        '''
        result = self._values.get("primary_tag")
        assert result is not None, "Required property 'primary_tag' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def row_type(self) -> builtins.str:
        '''The level of detail for the request. Valid values are ``service``, ``resource``, ``span``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#row_type Dashboard#row_type}
        '''
        result = self._values.get("row_type")
        assert result is not None, "Required property 'row_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> builtins.str:
        '''Service name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def columns(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumns"]]:
        '''columns block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#columns Dashboard#columns}
        '''
        result = self._values.get("columns")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumns"]], result)

    @builtins.property
    def resource(self) -> typing.Optional[builtins.str]:
        '''Resource name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#resource Dashboard#resource}
        '''
        result = self._values.get("resource")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestApmStatsQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumns",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "alias": "alias",
        "cell_display_mode": "cellDisplayMode",
        "order": "order",
    },
)
class DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumns:
    def __init__(
        self,
        *,
        name: builtins.str,
        alias: typing.Optional[builtins.str] = None,
        cell_display_mode: typing.Optional[builtins.str] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Column name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param alias: A user-assigned alias for the column. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param cell_display_mode: A list of display modes for each table cell. Valid values are ``number``, ``bar``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#cell_display_mode Dashboard#cell_display_mode}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if alias is not None:
            self._values["alias"] = alias
        if cell_display_mode is not None:
            self._values["cell_display_mode"] = cell_display_mode
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def name(self) -> builtins.str:
        '''Column name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''A user-assigned alias for the column.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cell_display_mode(self) -> typing.Optional[builtins.str]:
        '''A list of display modes for each table cell. Valid values are ``number``, ``bar``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#cell_display_mode Dashboard#cell_display_mode}
        '''
        result = self._values.get("cell_display_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumns(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestConditionalFormats",
    jsii_struct_bases=[],
    name_mapping={
        "comparator": "comparator",
        "palette": "palette",
        "value": "value",
        "custom_bg_color": "customBgColor",
        "custom_fg_color": "customFgColor",
        "hide_value": "hideValue",
        "image_url": "imageUrl",
        "metric": "metric",
        "timeframe": "timeframe",
    },
)
class DashboardWidgetQueryTableDefinitionRequestConditionalFormats:
    def __init__(
        self,
        *,
        comparator: builtins.str,
        palette: builtins.str,
        value: jsii.Number,
        custom_bg_color: typing.Optional[builtins.str] = None,
        custom_fg_color: typing.Optional[builtins.str] = None,
        hide_value: typing.Optional[builtins.bool] = None,
        image_url: typing.Optional[builtins.str] = None,
        metric: typing.Optional[builtins.str] = None,
        timeframe: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param comparator: Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        :param palette: Color palette to apply. Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        :param value: Value for the comparator. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        :param custom_bg_color: Color palette to apply to the background, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        :param custom_fg_color: Color palette to apply to the foreground, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        :param hide_value: Setting this to True hides values. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        :param image_url: Displays an image as the background. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        :param metric: Metric from the request to correlate this conditional format with. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param timeframe: Defines the displayed timeframe. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "comparator": comparator,
            "palette": palette,
            "value": value,
        }
        if custom_bg_color is not None:
            self._values["custom_bg_color"] = custom_bg_color
        if custom_fg_color is not None:
            self._values["custom_fg_color"] = custom_fg_color
        if hide_value is not None:
            self._values["hide_value"] = hide_value
        if image_url is not None:
            self._values["image_url"] = image_url
        if metric is not None:
            self._values["metric"] = metric
        if timeframe is not None:
            self._values["timeframe"] = timeframe

    @builtins.property
    def comparator(self) -> builtins.str:
        '''Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        '''
        result = self._values.get("comparator")
        assert result is not None, "Required property 'comparator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def palette(self) -> builtins.str:
        '''Color palette to apply.

        Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        assert result is not None, "Required property 'palette' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        '''Value for the comparator.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def custom_bg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the background, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        '''
        result = self._values.get("custom_bg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def custom_fg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the foreground, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        '''
        result = self._values.get("custom_fg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hide_value(self) -> typing.Optional[builtins.bool]:
        '''Setting this to True hides values.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        '''
        result = self._values.get("hide_value")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def image_url(self) -> typing.Optional[builtins.str]:
        '''Displays an image as the background.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        '''
        result = self._values.get("image_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric from the request to correlate this conditional format with.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timeframe(self) -> typing.Optional[builtins.str]:
        '''Defines the displayed timeframe.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        result = self._values.get("timeframe")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestConditionalFormats(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetQueryTableDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetQueryTableDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetQueryTableDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetQueryTableDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "autoscale": "autoscale",
        "custom_link": "customLink",
        "custom_unit": "customUnit",
        "live_span": "liveSpan",
        "precision": "precision",
        "request": "request",
        "text_align": "textAlign",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetQueryValueDefinition:
    def __init__(
        self,
        *,
        autoscale: typing.Optional[builtins.bool] = None,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionCustomLink"]] = None,
        custom_unit: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        precision: typing.Optional[jsii.Number] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequest"]] = None,
        text_align: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param autoscale: Boolean indicating whether to automatically scale the tile. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#autoscale Dashboard#autoscale}
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param custom_unit: The unit for the value displayed in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_unit Dashboard#custom_unit}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param precision: The precision to use when displaying the tile. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#precision Dashboard#precision}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param text_align: The alignment of the widget's text. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if autoscale is not None:
            self._values["autoscale"] = autoscale
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if custom_unit is not None:
            self._values["custom_unit"] = custom_unit
        if live_span is not None:
            self._values["live_span"] = live_span
        if precision is not None:
            self._values["precision"] = precision
        if request is not None:
            self._values["request"] = request
        if text_align is not None:
            self._values["text_align"] = text_align
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def autoscale(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether to automatically scale the tile.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#autoscale Dashboard#autoscale}
        '''
        result = self._values.get("autoscale")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionCustomLink"]], result)

    @builtins.property
    def custom_unit(self) -> typing.Optional[builtins.str]:
        '''The unit for the value displayed in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_unit Dashboard#custom_unit}
        '''
        result = self._values.get("custom_unit")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def precision(self) -> typing.Optional[jsii.Number]:
        '''The precision to use when displaying the tile.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#precision Dashboard#precision}
        '''
        result = self._values.get("precision")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequest"]], result)

    @builtins.property
    def text_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's text. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_align Dashboard#text_align}
        '''
        result = self._values.get("text_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetQueryValueDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "aggregator": "aggregator",
        "apm_query": "apmQuery",
        "conditional_formats": "conditionalFormats",
        "formula": "formula",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "query": "query",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetQueryValueDefinitionRequest:
    def __init__(
        self,
        *,
        aggregator: typing.Optional[builtins.str] = None,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestApmQuery"]] = None,
        conditional_formats: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestConditionalFormats"]] = None,
        formula: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestFormula"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestQuery"]] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestSecurityQuery"]] = None,
    ) -> None:
        '''
        :param aggregator: The aggregator to use for time aggregation. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param conditional_formats: conditional_formats block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        :param formula: formula block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if conditional_formats is not None:
            self._values["conditional_formats"] = conditional_formats
        if formula is not None:
            self._values["formula"] = formula
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if query is not None:
            self._values["query"] = query
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregator to use for time aggregation. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestApmQuery"]], result)

    @builtins.property
    def conditional_formats(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestConditionalFormats"]]:
        '''conditional_formats block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        '''
        result = self._values.get("conditional_formats")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestConditionalFormats"]], result)

    @builtins.property
    def formula(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestFormula"]]:
        '''formula block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        '''
        result = self._values.get("formula")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestFormula"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQuery"]]:
        '''query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQuery"]], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetQueryValueDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestConditionalFormats",
    jsii_struct_bases=[],
    name_mapping={
        "comparator": "comparator",
        "palette": "palette",
        "value": "value",
        "custom_bg_color": "customBgColor",
        "custom_fg_color": "customFgColor",
        "hide_value": "hideValue",
        "image_url": "imageUrl",
        "metric": "metric",
        "timeframe": "timeframe",
    },
)
class DashboardWidgetQueryValueDefinitionRequestConditionalFormats:
    def __init__(
        self,
        *,
        comparator: builtins.str,
        palette: builtins.str,
        value: jsii.Number,
        custom_bg_color: typing.Optional[builtins.str] = None,
        custom_fg_color: typing.Optional[builtins.str] = None,
        hide_value: typing.Optional[builtins.bool] = None,
        image_url: typing.Optional[builtins.str] = None,
        metric: typing.Optional[builtins.str] = None,
        timeframe: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param comparator: Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        :param palette: Color palette to apply. Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        :param value: Value for the comparator. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        :param custom_bg_color: Color palette to apply to the background, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        :param custom_fg_color: Color palette to apply to the foreground, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        :param hide_value: Setting this to True hides values. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        :param image_url: Displays an image as the background. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        :param metric: Metric from the request to correlate this conditional format with. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param timeframe: Defines the displayed timeframe. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "comparator": comparator,
            "palette": palette,
            "value": value,
        }
        if custom_bg_color is not None:
            self._values["custom_bg_color"] = custom_bg_color
        if custom_fg_color is not None:
            self._values["custom_fg_color"] = custom_fg_color
        if hide_value is not None:
            self._values["hide_value"] = hide_value
        if image_url is not None:
            self._values["image_url"] = image_url
        if metric is not None:
            self._values["metric"] = metric
        if timeframe is not None:
            self._values["timeframe"] = timeframe

    @builtins.property
    def comparator(self) -> builtins.str:
        '''Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        '''
        result = self._values.get("comparator")
        assert result is not None, "Required property 'comparator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def palette(self) -> builtins.str:
        '''Color palette to apply.

        Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        assert result is not None, "Required property 'palette' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        '''Value for the comparator.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def custom_bg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the background, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        '''
        result = self._values.get("custom_bg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def custom_fg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the foreground, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        '''
        result = self._values.get("custom_fg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hide_value(self) -> typing.Optional[builtins.bool]:
        '''Setting this to True hides values.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        '''
        result = self._values.get("hide_value")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def image_url(self) -> typing.Optional[builtins.str]:
        '''Displays an image as the background.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        '''
        result = self._values.get("image_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric from the request to correlate this conditional format with.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timeframe(self) -> typing.Optional[builtins.str]:
        '''Defines the displayed timeframe.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        result = self._values.get("timeframe")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestConditionalFormats(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestFormula",
    jsii_struct_bases=[],
    name_mapping={
        "formula_expression": "formulaExpression",
        "alias": "alias",
        "limit": "limit",
    },
)
class DashboardWidgetQueryValueDefinitionRequestFormula:
    def __init__(
        self,
        *,
        formula_expression: builtins.str,
        alias: typing.Optional[builtins.str] = None,
        limit: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestFormulaLimit"]] = None,
    ) -> None:
        '''
        :param formula_expression: String expression built from queries, formulas and functions. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        :param alias: Expression alias. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param limit: limit block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "formula_expression": formula_expression,
        }
        if alias is not None:
            self._values["alias"] = alias
        if limit is not None:
            self._values["limit"] = limit

    @builtins.property
    def formula_expression(self) -> builtins.str:
        '''String expression built from queries, formulas and functions.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        '''
        result = self._values.get("formula_expression")
        assert result is not None, "Required property 'formula_expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''Expression alias.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestFormulaLimit"]]:
        '''limit block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestFormulaLimit"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestFormula(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestFormulaLimit",
    jsii_struct_bases=[],
    name_mapping={"count": "count", "order": "order"},
)
class DashboardWidgetQueryValueDefinitionRequestFormulaLimit:
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: Number of results to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''Number of results to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestFormulaLimit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetQueryValueDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetQueryValueDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestQuery",
    jsii_struct_bases=[],
    name_mapping={
        "event_query": "eventQuery",
        "metric_query": "metricQuery",
        "process_query": "processQuery",
    },
)
class DashboardWidgetQueryValueDefinitionRequestQuery:
    def __init__(
        self,
        *,
        event_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestQueryEventQuery"]] = None,
        metric_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery"]] = None,
    ) -> None:
        '''
        :param event_query: event_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        :param metric_query: metric_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if event_query is not None:
            self._values["event_query"] = event_query
        if metric_query is not None:
            self._values["metric_query"] = metric_query
        if process_query is not None:
            self._values["process_query"] = process_query

    @builtins.property
    def event_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryEventQuery"]]:
        '''event_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        '''
        result = self._values.get("event_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryEventQuery"]], result)

    @builtins.property
    def metric_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery"]]:
        '''metric_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        '''
        result = self._values.get("metric_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestQueryEventQuery",
    jsii_struct_bases=[],
    name_mapping={
        "compute": "compute",
        "data_source": "dataSource",
        "name": "name",
        "group_by": "groupBy",
        "indexes": "indexes",
        "search": "search",
    },
)
class DashboardWidgetQueryValueDefinitionRequestQueryEventQuery:
    def __init__(
        self,
        *,
        compute: typing.Sequence["DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute"],
        data_source: builtins.str,
        name: builtins.str,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy"]] = None,
        indexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        search: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch"]] = None,
    ) -> None:
        '''
        :param compute: compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        :param data_source: Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param indexes: An array of index names to query in the stream. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        :param search: search block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "compute": compute,
            "data_source": data_source,
            "name": name,
        }
        if group_by is not None:
            self._values["group_by"] = group_by
        if indexes is not None:
            self._values["indexes"] = indexes
        if search is not None:
            self._values["search"] = search

    @builtins.property
    def compute(
        self,
    ) -> typing.List["DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute"]:
        '''compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        '''
        result = self._values.get("compute")
        assert result is not None, "Required property 'compute' is missing"
        return typing.cast(typing.List["DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute"], result)

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy"]], result)

    @builtins.property
    def indexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of index names to query in the stream.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        '''
        result = self._values.get("indexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def search(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch"]]:
        '''search block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        result = self._values.get("search")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestQueryEventQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "interval": "interval",
        "metric": "metric",
    },
)
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        interval: typing.Optional[jsii.Number] = None,
        metric: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param interval: A time interval in milliseconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        :param metric: Measurable attribute to compute. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if interval is not None:
            self._values["interval"] = interval
        if metric is not None:
            self._values["metric"] = metric

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''A time interval in milliseconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Measurable attribute to compute.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort": "sort"},
)
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy:
    def __init__(
        self,
        *,
        facet: builtins.str,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort"]] = None,
    ) -> None:
        '''
        :param facet: Event facet. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Number of groups to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: sort block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "facet": facet,
        }
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort

    @builtins.property
    def facet(self) -> builtins.str:
        '''Event facet.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        assert result is not None, "Required property 'facet' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of groups to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort"]]:
        '''sort block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "metric": "metric", "order": "order"},
)
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        metric: typing.Optional[builtins.str] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param metric: Metric used for sorting group by results. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if metric is not None:
            self._values["metric"] = metric
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric used for sorting group by results.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Events search string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Events search string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "query": "query",
        "aggregator": "aggregator",
        "data_source": "dataSource",
    },
)
class DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery:
    def __init__(
        self,
        *,
        name: builtins.str,
        query: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        data_source: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Name of the query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param query: Metrics query definition. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param data_source: Data source for metrics queries. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "query": query,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if data_source is not None:
            self._values["data_source"] = data_source

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''Metrics query definition.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def data_source(self) -> typing.Optional[builtins.str]:
        '''Data source for metrics queries.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "data_source": "dataSource",
        "metric": "metric",
        "name": "name",
        "aggregator": "aggregator",
        "is_normalized_cpu": "isNormalizedCpu",
        "limit": "limit",
        "sort": "sort",
        "tag_filters": "tagFilters",
        "text_filter": "textFilter",
    },
)
class DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery:
    def __init__(
        self,
        *,
        data_source: builtins.str,
        metric: builtins.str,
        name: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        is_normalized_cpu: typing.Optional[builtins.bool] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[builtins.str] = None,
        tag_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
        text_filter: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param data_source: Data source for process queries. Valid values are ``process``, ``container``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param metric: Process metric name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param is_normalized_cpu: Whether to normalize the CPU percentages. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        :param limit: Number of hits to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param tag_filters: An array of tags to filter by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        :param text_filter: Text to use as filter. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "data_source": data_source,
            "metric": metric,
            "name": name,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if is_normalized_cpu is not None:
            self._values["is_normalized_cpu"] = is_normalized_cpu
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort
        if tag_filters is not None:
            self._values["tag_filters"] = tag_filters
        if text_filter is not None:
            self._values["text_filter"] = text_filter

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for process queries. Valid values are ``process``, ``container``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> builtins.str:
        '''Process metric name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_normalized_cpu(self) -> typing.Optional[builtins.bool]:
        '''Whether to normalize the CPU percentages.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        '''
        result = self._values.get("is_normalized_cpu")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of hits to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_filters(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of tags to filter by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        '''
        result = self._values.get("tag_filters")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def text_filter(self) -> typing.Optional[builtins.str]:
        '''Text to use as filter.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        result = self._values.get("text_filter")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetQueryValueDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetQueryValueDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "color_by_groups": "colorByGroups",
        "custom_link": "customLink",
        "live_span": "liveSpan",
        "request": "request",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
        "xaxis": "xaxis",
        "yaxis": "yaxis",
    },
)
class DashboardWidgetScatterplotDefinition:
    def __init__(
        self,
        *,
        color_by_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionCustomLink"]] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequest"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
        xaxis: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionXaxis"]] = None,
        yaxis: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionYaxis"]] = None,
    ) -> None:
        '''
        :param color_by_groups: List of groups used for colors. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color_by_groups Dashboard#color_by_groups}
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        :param xaxis: xaxis block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#xaxis Dashboard#xaxis}
        :param yaxis: yaxis block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if color_by_groups is not None:
            self._values["color_by_groups"] = color_by_groups
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size
        if xaxis is not None:
            self._values["xaxis"] = xaxis
        if yaxis is not None:
            self._values["yaxis"] = yaxis

    @builtins.property
    def color_by_groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of groups used for colors.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#color_by_groups Dashboard#color_by_groups}
        '''
        result = self._values.get("color_by_groups")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionCustomLink"]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequest"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def xaxis(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionXaxis"]]:
        '''xaxis block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#xaxis Dashboard#xaxis}
        '''
        result = self._values.get("xaxis")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionXaxis"]], result)

    @builtins.property
    def yaxis(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionYaxis"]]:
        '''yaxis block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        result = self._values.get("yaxis")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionYaxis"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetScatterplotDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={"x": "x", "y": "y"},
)
class DashboardWidgetScatterplotDefinitionRequest:
    def __init__(
        self,
        *,
        x: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestX"]] = None,
        y: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestY"]] = None,
    ) -> None:
        '''
        :param x: x block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#x Dashboard#x}
        :param y: y block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#y Dashboard#y}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if x is not None:
            self._values["x"] = x
        if y is not None:
            self._values["y"] = y

    @builtins.property
    def x(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestX"]]:
        '''x block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#x Dashboard#x}
        '''
        result = self._values.get("x")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestX"]], result)

    @builtins.property
    def y(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestY"]]:
        '''y block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#y Dashboard#y}
        '''
        result = self._values.get("y")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestY"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestX",
    jsii_struct_bases=[],
    name_mapping={
        "aggregator": "aggregator",
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetScatterplotDefinitionRequestX:
    def __init__(
        self,
        *,
        aggregator: typing.Optional[builtins.str] = None,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXSecurityQuery"]] = None,
    ) -> None:
        '''
        :param aggregator: Aggregator used for the request. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''Aggregator used for the request. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestX(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestY",
    jsii_struct_bases=[],
    name_mapping={
        "aggregator": "aggregator",
        "apm_query": "apmQuery",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
    },
)
class DashboardWidgetScatterplotDefinitionRequestY:
    def __init__(
        self,
        *,
        aggregator: typing.Optional[builtins.str] = None,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYApmQuery"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYSecurityQuery"]] = None,
    ) -> None:
        '''
        :param aggregator: Aggregator used for the request. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''Aggregator used for the request. Valid values are ``avg``, ``last``, ``max``, ``min``, ``sum``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYApmQuery"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYSecurityQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestY(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionXaxis",
    jsii_struct_bases=[],
    name_mapping={
        "include_zero": "includeZero",
        "label": "label",
        "max": "max",
        "min": "min",
        "scale": "scale",
    },
)
class DashboardWidgetScatterplotDefinitionXaxis:
    def __init__(
        self,
        *,
        include_zero: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        max: typing.Optional[builtins.str] = None,
        min: typing.Optional[builtins.str] = None,
        scale: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param include_zero: Always include zero or fit the axis to the data range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        :param label: The label of the axis to display on the graph. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param max: Specify the maximum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        :param min: Specify the minimum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        :param scale: Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if include_zero is not None:
            self._values["include_zero"] = include_zero
        if label is not None:
            self._values["label"] = label
        if max is not None:
            self._values["max"] = max
        if min is not None:
            self._values["min"] = min
        if scale is not None:
            self._values["scale"] = scale

    @builtins.property
    def include_zero(self) -> typing.Optional[builtins.bool]:
        '''Always include zero or fit the axis to the data range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        '''
        result = self._values.get("include_zero")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label of the axis to display on the graph.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max(self) -> typing.Optional[builtins.str]:
        '''Specify the maximum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        '''
        result = self._values.get("max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def min(self) -> typing.Optional[builtins.str]:
        '''Specify the minimum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        '''
        result = self._values.get("min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale(self) -> typing.Optional[builtins.str]:
        '''Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        result = self._values.get("scale")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionXaxis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetScatterplotDefinitionYaxis",
    jsii_struct_bases=[],
    name_mapping={
        "include_zero": "includeZero",
        "label": "label",
        "max": "max",
        "min": "min",
        "scale": "scale",
    },
)
class DashboardWidgetScatterplotDefinitionYaxis:
    def __init__(
        self,
        *,
        include_zero: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        max: typing.Optional[builtins.str] = None,
        min: typing.Optional[builtins.str] = None,
        scale: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param include_zero: Always include zero or fit the axis to the data range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        :param label: The label of the axis to display on the graph. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param max: Specify the maximum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        :param min: Specify the minimum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        :param scale: Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if include_zero is not None:
            self._values["include_zero"] = include_zero
        if label is not None:
            self._values["label"] = label
        if max is not None:
            self._values["max"] = max
        if min is not None:
            self._values["min"] = min
        if scale is not None:
            self._values["scale"] = scale

    @builtins.property
    def include_zero(self) -> typing.Optional[builtins.bool]:
        '''Always include zero or fit the axis to the data range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        '''
        result = self._values.get("include_zero")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label of the axis to display on the graph.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max(self) -> typing.Optional[builtins.str]:
        '''Specify the maximum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        '''
        result = self._values.get("max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def min(self) -> typing.Optional[builtins.str]:
        '''Specify the minimum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        '''
        result = self._values.get("min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale(self) -> typing.Optional[builtins.str]:
        '''Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        result = self._values.get("scale")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetScatterplotDefinitionYaxis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetServiceLevelObjectiveDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "slo_id": "sloId",
        "time_windows": "timeWindows",
        "view_mode": "viewMode",
        "view_type": "viewType",
        "global_time_target": "globalTimeTarget",
        "show_error_budget": "showErrorBudget",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetServiceLevelObjectiveDefinition:
    def __init__(
        self,
        *,
        slo_id: builtins.str,
        time_windows: typing.Sequence[builtins.str],
        view_mode: builtins.str,
        view_type: builtins.str,
        global_time_target: typing.Optional[builtins.str] = None,
        show_error_budget: typing.Optional[builtins.bool] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param slo_id: The ID of the service level objective used by the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#slo_id Dashboard#slo_id}
        :param time_windows: List of time windows to display in the widget. Valid values are ``7d``, ``30d``, ``90d``, ``week_to_date``, ``previous_week``, ``month_to_date``, ``previous_month``, ``global_time``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#time_windows Dashboard#time_windows}
        :param view_mode: View mode for the widget. Valid values are ``overall``, ``component``, ``both``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view_mode Dashboard#view_mode}
        :param view_type: Type of view to use when displaying the widget. Only ``detail`` is currently supported. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view_type Dashboard#view_type}
        :param global_time_target: The global time target of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#global_time_target Dashboard#global_time_target}
        :param show_error_budget: Whether to show the error budget or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_error_budget Dashboard#show_error_budget}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "slo_id": slo_id,
            "time_windows": time_windows,
            "view_mode": view_mode,
            "view_type": view_type,
        }
        if global_time_target is not None:
            self._values["global_time_target"] = global_time_target
        if show_error_budget is not None:
            self._values["show_error_budget"] = show_error_budget
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def slo_id(self) -> builtins.str:
        '''The ID of the service level objective used by the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#slo_id Dashboard#slo_id}
        '''
        result = self._values.get("slo_id")
        assert result is not None, "Required property 'slo_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def time_windows(self) -> typing.List[builtins.str]:
        '''List of time windows to display in the widget.

        Valid values are ``7d``, ``30d``, ``90d``, ``week_to_date``, ``previous_week``, ``month_to_date``, ``previous_month``, ``global_time``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#time_windows Dashboard#time_windows}
        '''
        result = self._values.get("time_windows")
        assert result is not None, "Required property 'time_windows' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def view_mode(self) -> builtins.str:
        '''View mode for the widget. Valid values are ``overall``, ``component``, ``both``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view_mode Dashboard#view_mode}
        '''
        result = self._values.get("view_mode")
        assert result is not None, "Required property 'view_mode' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def view_type(self) -> builtins.str:
        '''Type of view to use when displaying the widget. Only ``detail`` is currently supported.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#view_type Dashboard#view_type}
        '''
        result = self._values.get("view_type")
        assert result is not None, "Required property 'view_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def global_time_target(self) -> typing.Optional[builtins.str]:
        '''The global time target of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#global_time_target Dashboard#global_time_target}
        '''
        result = self._values.get("global_time_target")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def show_error_budget(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the error budget or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_error_budget Dashboard#show_error_budget}
        '''
        result = self._values.get("show_error_budget")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetServiceLevelObjectiveDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetServicemapDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "filters": "filters",
        "service": "service",
        "custom_link": "customLink",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetServicemapDefinition:
    def __init__(
        self,
        *,
        filters: typing.Sequence[builtins.str],
        service: builtins.str,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetServicemapDefinitionCustomLink"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param filters: Your environment and primary tag (or ``*`` if enabled for your account). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filters Dashboard#filters}
        :param service: The ID of the service you want to map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "filters": filters,
            "service": service,
        }
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def filters(self) -> typing.List[builtins.str]:
        '''Your environment and primary tag (or ``*`` if enabled for your account).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filters Dashboard#filters}
        '''
        result = self._values.get("filters")
        assert result is not None, "Required property 'filters' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def service(self) -> builtins.str:
        '''The ID of the service you want to map.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetServicemapDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetServicemapDefinitionCustomLink"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetServicemapDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetServicemapDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetServicemapDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetServicemapDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "event": "event",
        "legend_columns": "legendColumns",
        "legend_layout": "legendLayout",
        "legend_size": "legendSize",
        "live_span": "liveSpan",
        "marker": "marker",
        "request": "request",
        "right_yaxis": "rightYaxis",
        "show_legend": "showLegend",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
        "yaxis": "yaxis",
    },
)
class DashboardWidgetTimeseriesDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionCustomLink"]] = None,
        event: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionEvent"]] = None,
        legend_columns: typing.Optional[typing.Sequence[builtins.str]] = None,
        legend_layout: typing.Optional[builtins.str] = None,
        legend_size: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        marker: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionMarker"]] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequest"]] = None,
        right_yaxis: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRightYaxis"]] = None,
        show_legend: typing.Optional[builtins.bool] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
        yaxis: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionYaxis"]] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param event: event block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event Dashboard#event}
        :param legend_columns: A list of columns to display in the legend. Valid values are ``value``, ``avg``, ``sum``, ``min``, ``max``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_columns Dashboard#legend_columns}
        :param legend_layout: The layout of the legend displayed in the widget. Valid values are ``auto``, ``horizontal``, ``vertical``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_layout Dashboard#legend_layout}
        :param legend_size: The size of the legend displayed in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param marker: marker block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#marker Dashboard#marker}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param right_yaxis: right_yaxis block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#right_yaxis Dashboard#right_yaxis}
        :param show_legend: Whether or not to show the legend on this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        :param yaxis: yaxis block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if event is not None:
            self._values["event"] = event
        if legend_columns is not None:
            self._values["legend_columns"] = legend_columns
        if legend_layout is not None:
            self._values["legend_layout"] = legend_layout
        if legend_size is not None:
            self._values["legend_size"] = legend_size
        if live_span is not None:
            self._values["live_span"] = live_span
        if marker is not None:
            self._values["marker"] = marker
        if request is not None:
            self._values["request"] = request
        if right_yaxis is not None:
            self._values["right_yaxis"] = right_yaxis
        if show_legend is not None:
            self._values["show_legend"] = show_legend
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size
        if yaxis is not None:
            self._values["yaxis"] = yaxis

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionCustomLink"]], result)

    @builtins.property
    def event(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionEvent"]]:
        '''event block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event Dashboard#event}
        '''
        result = self._values.get("event")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionEvent"]], result)

    @builtins.property
    def legend_columns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of columns to display in the legend. Valid values are ``value``, ``avg``, ``sum``, ``min``, ``max``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_columns Dashboard#legend_columns}
        '''
        result = self._values.get("legend_columns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def legend_layout(self) -> typing.Optional[builtins.str]:
        '''The layout of the legend displayed in the widget. Valid values are ``auto``, ``horizontal``, ``vertical``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_layout Dashboard#legend_layout}
        '''
        result = self._values.get("legend_layout")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def legend_size(self) -> typing.Optional[builtins.str]:
        '''The size of the legend displayed in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#legend_size Dashboard#legend_size}
        '''
        result = self._values.get("legend_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def marker(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionMarker"]]:
        '''marker block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#marker Dashboard#marker}
        '''
        result = self._values.get("marker")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionMarker"]], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequest"]], result)

    @builtins.property
    def right_yaxis(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRightYaxis"]]:
        '''right_yaxis block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#right_yaxis Dashboard#right_yaxis}
        '''
        result = self._values.get("right_yaxis")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRightYaxis"]], result)

    @builtins.property
    def show_legend(self) -> typing.Optional[builtins.bool]:
        '''Whether or not to show the legend on this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_legend Dashboard#show_legend}
        '''
        result = self._values.get("show_legend")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def yaxis(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionYaxis"]]:
        '''yaxis block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#yaxis Dashboard#yaxis}
        '''
        result = self._values.get("yaxis")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionYaxis"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetTimeseriesDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionEvent",
    jsii_struct_bases=[],
    name_mapping={"q": "q", "tags_execution": "tagsExecution"},
)
class DashboardWidgetTimeseriesDefinitionEvent:
    def __init__(
        self,
        *,
        q: builtins.str,
        tags_execution: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param q: The event query to use in the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param tags_execution: The execution method for multi-value filters. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "q": q,
        }
        if tags_execution is not None:
            self._values["tags_execution"] = tags_execution

    @builtins.property
    def q(self) -> builtins.str:
        '''The event query to use in the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        assert result is not None, "Required property 'q' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags_execution(self) -> typing.Optional[builtins.str]:
        '''The execution method for multi-value filters.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tags_execution Dashboard#tags_execution}
        '''
        result = self._values.get("tags_execution")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionEvent(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionMarker",
    jsii_struct_bases=[],
    name_mapping={"value": "value", "display_type": "displayType", "label": "label"},
)
class DashboardWidgetTimeseriesDefinitionMarker:
    def __init__(
        self,
        *,
        value: builtins.str,
        display_type: typing.Optional[builtins.str] = None,
        label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param value: Mathematical expression describing the marker. Examples: ``y > 1``, ``-5 < y < 0``, ``y = 19``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        :param display_type: How the marker lines will look. Possible values are one of {``error``, ``warning``, ``info``, ``ok``} combined with one of {``dashed``, ``solid``, ``bold``}. Example: ``error dashed``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_type Dashboard#display_type}
        :param label: A label for the line or range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "value": value,
        }
        if display_type is not None:
            self._values["display_type"] = display_type
        if label is not None:
            self._values["label"] = label

    @builtins.property
    def value(self) -> builtins.str:
        '''Mathematical expression describing the marker. Examples: ``y > 1``, ``-5 < y < 0``, ``y = 19``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def display_type(self) -> typing.Optional[builtins.str]:
        '''How the marker lines will look.

        Possible values are one of {``error``, ``warning``, ``info``, ``ok``} combined with one of {``dashed``, ``solid``, ``bold``}. Example: ``error dashed``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_type Dashboard#display_type}
        '''
        result = self._values.get("display_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''A label for the line or range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionMarker(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "display_type": "displayType",
        "formula": "formula",
        "log_query": "logQuery",
        "metadata": "metadata",
        "network_query": "networkQuery",
        "on_right_yaxis": "onRightYaxis",
        "process_query": "processQuery",
        "q": "q",
        "query": "query",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
        "style": "style",
    },
)
class DashboardWidgetTimeseriesDefinitionRequest:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestApmQuery"]] = None,
        display_type: typing.Optional[builtins.str] = None,
        formula: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestFormula"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestLogQuery"]] = None,
        metadata: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestMetadata"]] = None,
        network_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestNetworkQuery"]] = None,
        on_right_yaxis: typing.Optional[builtins.bool] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestQuery"]] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestSecurityQuery"]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestStyle"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param display_type: How the marker lines will look. Valid values are ``area``, ``bars``, ``line``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_type Dashboard#display_type}
        :param formula: formula block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param metadata: metadata block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metadata Dashboard#metadata}
        :param network_query: network_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#network_query Dashboard#network_query}
        :param on_right_yaxis: Boolean indicating whether the request will use the right or left Y-Axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#on_right_yaxis Dashboard#on_right_yaxis}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if display_type is not None:
            self._values["display_type"] = display_type
        if formula is not None:
            self._values["formula"] = formula
        if log_query is not None:
            self._values["log_query"] = log_query
        if metadata is not None:
            self._values["metadata"] = metadata
        if network_query is not None:
            self._values["network_query"] = network_query
        if on_right_yaxis is not None:
            self._values["on_right_yaxis"] = on_right_yaxis
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if query is not None:
            self._values["query"] = query
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query
        if style is not None:
            self._values["style"] = style

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestApmQuery"]], result)

    @builtins.property
    def display_type(self) -> typing.Optional[builtins.str]:
        '''How the marker lines will look. Valid values are ``area``, ``bars``, ``line``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_type Dashboard#display_type}
        '''
        result = self._values.get("display_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def formula(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestFormula"]]:
        '''formula block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        '''
        result = self._values.get("formula")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestFormula"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestLogQuery"]], result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestMetadata"]]:
        '''metadata block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metadata Dashboard#metadata}
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestMetadata"]], result)

    @builtins.property
    def network_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestNetworkQuery"]]:
        '''network_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#network_query Dashboard#network_query}
        '''
        result = self._values.get("network_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestNetworkQuery"]], result)

    @builtins.property
    def on_right_yaxis(self) -> typing.Optional[builtins.bool]:
        '''Boolean indicating whether the request will use the right or left Y-Axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#on_right_yaxis Dashboard#on_right_yaxis}
        '''
        result = self._values.get("on_right_yaxis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQuery"]]:
        '''query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQuery"]], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestSecurityQuery"]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestStyle"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestFormula",
    jsii_struct_bases=[],
    name_mapping={
        "formula_expression": "formulaExpression",
        "alias": "alias",
        "limit": "limit",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestFormula:
    def __init__(
        self,
        *,
        formula_expression: builtins.str,
        alias: typing.Optional[builtins.str] = None,
        limit: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestFormulaLimit"]] = None,
    ) -> None:
        '''
        :param formula_expression: String expression built from queries, formulas and functions. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        :param alias: Expression alias. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param limit: limit block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "formula_expression": formula_expression,
        }
        if alias is not None:
            self._values["alias"] = alias
        if limit is not None:
            self._values["limit"] = limit

    @builtins.property
    def formula_expression(self) -> builtins.str:
        '''String expression built from queries, formulas and functions.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        '''
        result = self._values.get("formula_expression")
        assert result is not None, "Required property 'formula_expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''Expression alias.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestFormulaLimit"]]:
        '''limit block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestFormulaLimit"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestFormula(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestFormulaLimit",
    jsii_struct_bases=[],
    name_mapping={"count": "count", "order": "order"},
)
class DashboardWidgetTimeseriesDefinitionRequestFormulaLimit:
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: Number of results to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''Number of results to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestFormulaLimit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestMetadata",
    jsii_struct_bases=[],
    name_mapping={"expression": "expression", "alias_name": "aliasName"},
)
class DashboardWidgetTimeseriesDefinitionRequestMetadata:
    def __init__(
        self,
        *,
        expression: builtins.str,
        alias_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param expression: Expression name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#expression Dashboard#expression}
        :param alias_name: Expression alias. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias_name Dashboard#alias_name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "expression": expression,
        }
        if alias_name is not None:
            self._values["alias_name"] = alias_name

    @builtins.property
    def expression(self) -> builtins.str:
        '''Expression name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#expression Dashboard#expression}
        '''
        result = self._values.get("expression")
        assert result is not None, "Required property 'expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias_name(self) -> typing.Optional[builtins.str]:
        '''Expression alias.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias_name Dashboard#alias_name}
        '''
        result = self._values.get("alias_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestNetworkQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestNetworkQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestQuery",
    jsii_struct_bases=[],
    name_mapping={
        "event_query": "eventQuery",
        "metric_query": "metricQuery",
        "process_query": "processQuery",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestQuery:
    def __init__(
        self,
        *,
        event_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery"]] = None,
        metric_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery"]] = None,
    ) -> None:
        '''
        :param event_query: event_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        :param metric_query: metric_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if event_query is not None:
            self._values["event_query"] = event_query
        if metric_query is not None:
            self._values["metric_query"] = metric_query
        if process_query is not None:
            self._values["process_query"] = process_query

    @builtins.property
    def event_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery"]]:
        '''event_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        '''
        result = self._values.get("event_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery"]], result)

    @builtins.property
    def metric_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery"]]:
        '''metric_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        '''
        result = self._values.get("metric_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery",
    jsii_struct_bases=[],
    name_mapping={
        "compute": "compute",
        "data_source": "dataSource",
        "name": "name",
        "group_by": "groupBy",
        "indexes": "indexes",
        "search": "search",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery:
    def __init__(
        self,
        *,
        compute: typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute"],
        data_source: builtins.str,
        name: builtins.str,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy"]] = None,
        indexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        search: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch"]] = None,
    ) -> None:
        '''
        :param compute: compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        :param data_source: Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param indexes: An array of index names to query in the stream. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        :param search: search block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "compute": compute,
            "data_source": data_source,
            "name": name,
        }
        if group_by is not None:
            self._values["group_by"] = group_by
        if indexes is not None:
            self._values["indexes"] = indexes
        if search is not None:
            self._values["search"] = search

    @builtins.property
    def compute(
        self,
    ) -> typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute"]:
        '''compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        '''
        result = self._values.get("compute")
        assert result is not None, "Required property 'compute' is missing"
        return typing.cast(typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute"], result)

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy"]], result)

    @builtins.property
    def indexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of index names to query in the stream.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        '''
        result = self._values.get("indexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def search(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch"]]:
        '''search block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        result = self._values.get("search")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "interval": "interval",
        "metric": "metric",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        interval: typing.Optional[jsii.Number] = None,
        metric: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param interval: A time interval in milliseconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        :param metric: Measurable attribute to compute. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if interval is not None:
            self._values["interval"] = interval
        if metric is not None:
            self._values["metric"] = metric

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''A time interval in milliseconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Measurable attribute to compute.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort": "sort"},
)
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy:
    def __init__(
        self,
        *,
        facet: builtins.str,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort"]] = None,
    ) -> None:
        '''
        :param facet: Event facet. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Number of groups to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: sort block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "facet": facet,
        }
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort

    @builtins.property
    def facet(self) -> builtins.str:
        '''Event facet.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        assert result is not None, "Required property 'facet' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of groups to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort"]]:
        '''sort block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "metric": "metric", "order": "order"},
)
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        metric: typing.Optional[builtins.str] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param metric: Metric used for sorting group by results. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if metric is not None:
            self._values["metric"] = metric
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric used for sorting group by results.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Events search string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Events search string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "query": "query",
        "aggregator": "aggregator",
        "data_source": "dataSource",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery:
    def __init__(
        self,
        *,
        name: builtins.str,
        query: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        data_source: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Name of the query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param query: Metrics query definition. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param data_source: Data source for metrics queries. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "query": query,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if data_source is not None:
            self._values["data_source"] = data_source

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''Metrics query definition.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def data_source(self) -> typing.Optional[builtins.str]:
        '''Data source for metrics queries.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "data_source": "dataSource",
        "metric": "metric",
        "name": "name",
        "aggregator": "aggregator",
        "is_normalized_cpu": "isNormalizedCpu",
        "limit": "limit",
        "sort": "sort",
        "tag_filters": "tagFilters",
        "text_filter": "textFilter",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery:
    def __init__(
        self,
        *,
        data_source: builtins.str,
        metric: builtins.str,
        name: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        is_normalized_cpu: typing.Optional[builtins.bool] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[builtins.str] = None,
        tag_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
        text_filter: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param data_source: Data source for process queries. Valid values are ``process``, ``container``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param metric: Process metric name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param is_normalized_cpu: Whether to normalize the CPU percentages. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        :param limit: Number of hits to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param tag_filters: An array of tags to filter by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        :param text_filter: Text to use as filter. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "data_source": data_source,
            "metric": metric,
            "name": name,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if is_normalized_cpu is not None:
            self._values["is_normalized_cpu"] = is_normalized_cpu
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort
        if tag_filters is not None:
            self._values["tag_filters"] = tag_filters
        if text_filter is not None:
            self._values["text_filter"] = text_filter

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for process queries. Valid values are ``process``, ``container``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> builtins.str:
        '''Process metric name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_normalized_cpu(self) -> typing.Optional[builtins.bool]:
        '''Whether to normalize the CPU percentages.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        '''
        result = self._values.get("is_normalized_cpu")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of hits to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_filters(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of tags to filter by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        '''
        result = self._values.get("tag_filters")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def text_filter(self) -> typing.Optional[builtins.str]:
        '''Text to use as filter.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        result = self._values.get("text_filter")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRequestStyle",
    jsii_struct_bases=[],
    name_mapping={
        "line_type": "lineType",
        "line_width": "lineWidth",
        "palette": "palette",
    },
)
class DashboardWidgetTimeseriesDefinitionRequestStyle:
    def __init__(
        self,
        *,
        line_type: typing.Optional[builtins.str] = None,
        line_width: typing.Optional[builtins.str] = None,
        palette: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param line_type: Type of lines displayed. Valid values are ``dashed``, ``dotted``, ``solid``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#line_type Dashboard#line_type}
        :param line_width: Width of line displayed. Valid values are ``normal``, ``thick``, ``thin``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#line_width Dashboard#line_width}
        :param palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if line_type is not None:
            self._values["line_type"] = line_type
        if line_width is not None:
            self._values["line_width"] = line_width
        if palette is not None:
            self._values["palette"] = palette

    @builtins.property
    def line_type(self) -> typing.Optional[builtins.str]:
        '''Type of lines displayed. Valid values are ``dashed``, ``dotted``, ``solid``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#line_type Dashboard#line_type}
        '''
        result = self._values.get("line_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def line_width(self) -> typing.Optional[builtins.str]:
        '''Width of line displayed. Valid values are ``normal``, ``thick``, ``thin``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#line_width Dashboard#line_width}
        '''
        result = self._values.get("line_width")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def palette(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRequestStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionRightYaxis",
    jsii_struct_bases=[],
    name_mapping={
        "include_zero": "includeZero",
        "label": "label",
        "max": "max",
        "min": "min",
        "scale": "scale",
    },
)
class DashboardWidgetTimeseriesDefinitionRightYaxis:
    def __init__(
        self,
        *,
        include_zero: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        max: typing.Optional[builtins.str] = None,
        min: typing.Optional[builtins.str] = None,
        scale: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param include_zero: Always include zero or fit the axis to the data range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        :param label: The label of the axis to display on the graph. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param max: Specify the maximum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        :param min: Specify the minimum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        :param scale: Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if include_zero is not None:
            self._values["include_zero"] = include_zero
        if label is not None:
            self._values["label"] = label
        if max is not None:
            self._values["max"] = max
        if min is not None:
            self._values["min"] = min
        if scale is not None:
            self._values["scale"] = scale

    @builtins.property
    def include_zero(self) -> typing.Optional[builtins.bool]:
        '''Always include zero or fit the axis to the data range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        '''
        result = self._values.get("include_zero")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label of the axis to display on the graph.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max(self) -> typing.Optional[builtins.str]:
        '''Specify the maximum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        '''
        result = self._values.get("max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def min(self) -> typing.Optional[builtins.str]:
        '''Specify the minimum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        '''
        result = self._values.get("min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale(self) -> typing.Optional[builtins.str]:
        '''Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        result = self._values.get("scale")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionRightYaxis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTimeseriesDefinitionYaxis",
    jsii_struct_bases=[],
    name_mapping={
        "include_zero": "includeZero",
        "label": "label",
        "max": "max",
        "min": "min",
        "scale": "scale",
    },
)
class DashboardWidgetTimeseriesDefinitionYaxis:
    def __init__(
        self,
        *,
        include_zero: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        max: typing.Optional[builtins.str] = None,
        min: typing.Optional[builtins.str] = None,
        scale: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param include_zero: Always include zero or fit the axis to the data range. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        :param label: The label of the axis to display on the graph. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param max: Specify the maximum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        :param min: Specify the minimum value to show on the Y-axis. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        :param scale: Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if include_zero is not None:
            self._values["include_zero"] = include_zero
        if label is not None:
            self._values["label"] = label
        if max is not None:
            self._values["max"] = max
        if min is not None:
            self._values["min"] = min
        if scale is not None:
            self._values["scale"] = scale

    @builtins.property
    def include_zero(self) -> typing.Optional[builtins.bool]:
        '''Always include zero or fit the axis to the data range.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#include_zero Dashboard#include_zero}
        '''
        result = self._values.get("include_zero")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label of the axis to display on the graph.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max(self) -> typing.Optional[builtins.str]:
        '''Specify the maximum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#max Dashboard#max}
        '''
        result = self._values.get("max")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def min(self) -> typing.Optional[builtins.str]:
        '''Specify the minimum value to show on the Y-axis.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#min Dashboard#min}
        '''
        result = self._values.get("min")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale(self) -> typing.Optional[builtins.str]:
        '''Specifies the scale type. One of ``linear``, ``log``, ``pow``, ``sqrt``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#scale Dashboard#scale}
        '''
        result = self._values.get("scale")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTimeseriesDefinitionYaxis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "custom_link": "customLink",
        "live_span": "liveSpan",
        "request": "request",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetToplistDefinition:
    def __init__(
        self,
        *,
        custom_link: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionCustomLink"]] = None,
        live_span: typing.Optional[builtins.str] = None,
        request: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequest"]] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param custom_link: custom_link block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param request: request block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if custom_link is not None:
            self._values["custom_link"] = custom_link
        if live_span is not None:
            self._values["live_span"] = live_span
        if request is not None:
            self._values["request"] = request
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def custom_link(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionCustomLink"]]:
        '''custom_link block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_link Dashboard#custom_link}
        '''
        result = self._values.get("custom_link")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionCustomLink"]], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequest"]]:
        '''request block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#request Dashboard#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequest"]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionCustomLink",
    jsii_struct_bases=[],
    name_mapping={
        "is_hidden": "isHidden",
        "label": "label",
        "link": "link",
        "override_label": "overrideLabel",
    },
)
class DashboardWidgetToplistDefinitionCustomLink:
    def __init__(
        self,
        *,
        is_hidden: typing.Optional[builtins.bool] = None,
        label: typing.Optional[builtins.str] = None,
        link: typing.Optional[builtins.str] = None,
        override_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param is_hidden: The flag for toggling context menu link visibility. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        :param label: The label for the custom link URL. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        :param link: The URL of the custom link. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        :param override_label: The label id that refers to a context menu link item. When override_label is provided, the client request will omit the label field. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_hidden is not None:
            self._values["is_hidden"] = is_hidden
        if label is not None:
            self._values["label"] = label
        if link is not None:
            self._values["link"] = link
        if override_label is not None:
            self._values["override_label"] = override_label

    @builtins.property
    def is_hidden(self) -> typing.Optional[builtins.bool]:
        '''The flag for toggling context menu link visibility.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_hidden Dashboard#is_hidden}
        '''
        result = self._values.get("is_hidden")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''The label for the custom link URL.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#label Dashboard#label}
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def link(self) -> typing.Optional[builtins.str]:
        '''The URL of the custom link.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#link Dashboard#link}
        '''
        result = self._values.get("link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_label(self) -> typing.Optional[builtins.str]:
        '''The label id that refers to a context menu link item.

        When override_label is provided, the client request will omit the label field.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#override_label Dashboard#override_label}
        '''
        result = self._values.get("override_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionCustomLink(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequest",
    jsii_struct_bases=[],
    name_mapping={
        "apm_query": "apmQuery",
        "conditional_formats": "conditionalFormats",
        "formula": "formula",
        "log_query": "logQuery",
        "process_query": "processQuery",
        "q": "q",
        "query": "query",
        "rum_query": "rumQuery",
        "security_query": "securityQuery",
        "style": "style",
    },
)
class DashboardWidgetToplistDefinitionRequest:
    def __init__(
        self,
        *,
        apm_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestApmQuery"]] = None,
        conditional_formats: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestConditionalFormats"]] = None,
        formula: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestFormula"]] = None,
        log_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestLogQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestProcessQuery"]] = None,
        q: typing.Optional[builtins.str] = None,
        query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestQuery"]] = None,
        rum_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestRumQuery"]] = None,
        security_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestSecurityQuery"]] = None,
        style: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestStyle"]] = None,
    ) -> None:
        '''
        :param apm_query: apm_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        :param conditional_formats: conditional_formats block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        :param formula: formula block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        :param log_query: log_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        :param q: The metric query to use for this widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param rum_query: rum_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        :param security_query: security_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        :param style: style block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if apm_query is not None:
            self._values["apm_query"] = apm_query
        if conditional_formats is not None:
            self._values["conditional_formats"] = conditional_formats
        if formula is not None:
            self._values["formula"] = formula
        if log_query is not None:
            self._values["log_query"] = log_query
        if process_query is not None:
            self._values["process_query"] = process_query
        if q is not None:
            self._values["q"] = q
        if query is not None:
            self._values["query"] = query
        if rum_query is not None:
            self._values["rum_query"] = rum_query
        if security_query is not None:
            self._values["security_query"] = security_query
        if style is not None:
            self._values["style"] = style

    @builtins.property
    def apm_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestApmQuery"]]:
        '''apm_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#apm_query Dashboard#apm_query}
        '''
        result = self._values.get("apm_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestApmQuery"]], result)

    @builtins.property
    def conditional_formats(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestConditionalFormats"]]:
        '''conditional_formats block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#conditional_formats Dashboard#conditional_formats}
        '''
        result = self._values.get("conditional_formats")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestConditionalFormats"]], result)

    @builtins.property
    def formula(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestFormula"]]:
        '''formula block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula Dashboard#formula}
        '''
        result = self._values.get("formula")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestFormula"]], result)

    @builtins.property
    def log_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestLogQuery"]]:
        '''log_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#log_query Dashboard#log_query}
        '''
        result = self._values.get("log_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestLogQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestProcessQuery"]], result)

    @builtins.property
    def q(self) -> typing.Optional[builtins.str]:
        '''The metric query to use for this widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#q Dashboard#q}
        '''
        result = self._values.get("q")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQuery"]]:
        '''query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQuery"]], result)

    @builtins.property
    def rum_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestRumQuery"]]:
        '''rum_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#rum_query Dashboard#rum_query}
        '''
        result = self._values.get("rum_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestRumQuery"]], result)

    @builtins.property
    def security_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestSecurityQuery"]]:
        '''security_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#security_query Dashboard#security_query}
        '''
        result = self._values.get("security_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestSecurityQuery"]], result)

    @builtins.property
    def style(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestStyle"]]:
        '''style block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#style Dashboard#style}
        '''
        result = self._values.get("style")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestStyle"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestApmQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetToplistDefinitionRequestApmQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestApmQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestApmQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestApmQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestApmQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestApmQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetToplistDefinitionRequestApmQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestApmQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestConditionalFormats",
    jsii_struct_bases=[],
    name_mapping={
        "comparator": "comparator",
        "palette": "palette",
        "value": "value",
        "custom_bg_color": "customBgColor",
        "custom_fg_color": "customFgColor",
        "hide_value": "hideValue",
        "image_url": "imageUrl",
        "metric": "metric",
        "timeframe": "timeframe",
    },
)
class DashboardWidgetToplistDefinitionRequestConditionalFormats:
    def __init__(
        self,
        *,
        comparator: builtins.str,
        palette: builtins.str,
        value: jsii.Number,
        custom_bg_color: typing.Optional[builtins.str] = None,
        custom_fg_color: typing.Optional[builtins.str] = None,
        hide_value: typing.Optional[builtins.bool] = None,
        image_url: typing.Optional[builtins.str] = None,
        metric: typing.Optional[builtins.str] = None,
        timeframe: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param comparator: Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        :param palette: Color palette to apply. Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        :param value: Value for the comparator. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        :param custom_bg_color: Color palette to apply to the background, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        :param custom_fg_color: Color palette to apply to the foreground, same values available as palette. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        :param hide_value: Setting this to True hides values. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        :param image_url: Displays an image as the background. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        :param metric: Metric from the request to correlate this conditional format with. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param timeframe: Defines the displayed timeframe. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "comparator": comparator,
            "palette": palette,
            "value": value,
        }
        if custom_bg_color is not None:
            self._values["custom_bg_color"] = custom_bg_color
        if custom_fg_color is not None:
            self._values["custom_fg_color"] = custom_fg_color
        if hide_value is not None:
            self._values["hide_value"] = hide_value
        if image_url is not None:
            self._values["image_url"] = image_url
        if metric is not None:
            self._values["metric"] = metric
        if timeframe is not None:
            self._values["timeframe"] = timeframe

    @builtins.property
    def comparator(self) -> builtins.str:
        '''Comparator to use. Valid values are ``>``, ``>=``, ``<``, ``<=``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#comparator Dashboard#comparator}
        '''
        result = self._values.get("comparator")
        assert result is not None, "Required property 'comparator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def palette(self) -> builtins.str:
        '''Color palette to apply.

        Valid values are ``blue``, ``custom_bg``, ``custom_image``, ``custom_text``, ``gray_on_white``, ``grey``, ``green``, ``orange``, ``red``, ``red_on_white``, ``white_on_gray``, ``white_on_green``, ``green_on_white``, ``white_on_red``, ``white_on_yellow``, ``yellow_on_white``, ``black_on_light_yellow``, ``black_on_light_green``, ``black_on_light_red``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        assert result is not None, "Required property 'palette' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> jsii.Number:
        '''Value for the comparator.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#value Dashboard#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def custom_bg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the background, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_bg_color Dashboard#custom_bg_color}
        '''
        result = self._values.get("custom_bg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def custom_fg_color(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the foreground, same values available as palette.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#custom_fg_color Dashboard#custom_fg_color}
        '''
        result = self._values.get("custom_fg_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hide_value(self) -> typing.Optional[builtins.bool]:
        '''Setting this to True hides values.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#hide_value Dashboard#hide_value}
        '''
        result = self._values.get("hide_value")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def image_url(self) -> typing.Optional[builtins.str]:
        '''Displays an image as the background.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#image_url Dashboard#image_url}
        '''
        result = self._values.get("image_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric from the request to correlate this conditional format with.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timeframe(self) -> typing.Optional[builtins.str]:
        '''Defines the displayed timeframe.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#timeframe Dashboard#timeframe}
        '''
        result = self._values.get("timeframe")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestConditionalFormats(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestFormula",
    jsii_struct_bases=[],
    name_mapping={
        "formula_expression": "formulaExpression",
        "alias": "alias",
        "limit": "limit",
    },
)
class DashboardWidgetToplistDefinitionRequestFormula:
    def __init__(
        self,
        *,
        formula_expression: builtins.str,
        alias: typing.Optional[builtins.str] = None,
        limit: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestFormulaLimit"]] = None,
    ) -> None:
        '''
        :param formula_expression: String expression built from queries, formulas and functions. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        :param alias: Expression alias. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        :param limit: limit block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "formula_expression": formula_expression,
        }
        if alias is not None:
            self._values["alias"] = alias
        if limit is not None:
            self._values["limit"] = limit

    @builtins.property
    def formula_expression(self) -> builtins.str:
        '''String expression built from queries, formulas and functions.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#formula_expression Dashboard#formula_expression}
        '''
        result = self._values.get("formula_expression")
        assert result is not None, "Required property 'formula_expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''Expression alias.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#alias Dashboard#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestFormulaLimit"]]:
        '''limit block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestFormulaLimit"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestFormula(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestFormulaLimit",
    jsii_struct_bases=[],
    name_mapping={"count": "count", "order": "order"},
)
class DashboardWidgetToplistDefinitionRequestFormulaLimit:
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: Number of results to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''Number of results to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#count Dashboard#count}
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestFormulaLimit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestLogQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetToplistDefinitionRequestLogQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestLogQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestLogQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestLogQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestLogQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestLogQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetToplistDefinitionRequestLogQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestLogQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "metric": "metric",
        "filter_by": "filterBy",
        "limit": "limit",
        "search_by": "searchBy",
    },
)
class DashboardWidgetToplistDefinitionRequestProcessQuery:
    def __init__(
        self,
        *,
        metric: builtins.str,
        filter_by: typing.Optional[typing.Sequence[builtins.str]] = None,
        limit: typing.Optional[jsii.Number] = None,
        search_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric: Your chosen metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param filter_by: List of processes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        :param limit: Max number of items in the filter list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param search_by: Your chosen search term. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if filter_by is not None:
            self._values["filter_by"] = filter_by
        if limit is not None:
            self._values["limit"] = limit
        if search_by is not None:
            self._values["search_by"] = search_by

    @builtins.property
    def metric(self) -> builtins.str:
        '''Your chosen metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_by(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of processes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#filter_by Dashboard#filter_by}
        '''
        result = self._values.get("filter_by")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Max number of items in the filter list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def search_by(self) -> typing.Optional[builtins.str]:
        '''Your chosen search term.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_by Dashboard#search_by}
        '''
        result = self._values.get("search_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestQuery",
    jsii_struct_bases=[],
    name_mapping={
        "event_query": "eventQuery",
        "metric_query": "metricQuery",
        "process_query": "processQuery",
    },
)
class DashboardWidgetToplistDefinitionRequestQuery:
    def __init__(
        self,
        *,
        event_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestQueryEventQuery"]] = None,
        metric_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestQueryMetricQuery"]] = None,
        process_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestQueryProcessQuery"]] = None,
    ) -> None:
        '''
        :param event_query: event_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        :param metric_query: metric_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        :param process_query: process_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if event_query is not None:
            self._values["event_query"] = event_query
        if metric_query is not None:
            self._values["metric_query"] = metric_query
        if process_query is not None:
            self._values["process_query"] = process_query

    @builtins.property
    def event_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryEventQuery"]]:
        '''event_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#event_query Dashboard#event_query}
        '''
        result = self._values.get("event_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryEventQuery"]], result)

    @builtins.property
    def metric_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryMetricQuery"]]:
        '''metric_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric_query Dashboard#metric_query}
        '''
        result = self._values.get("metric_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryMetricQuery"]], result)

    @builtins.property
    def process_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryProcessQuery"]]:
        '''process_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#process_query Dashboard#process_query}
        '''
        result = self._values.get("process_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryProcessQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestQueryEventQuery",
    jsii_struct_bases=[],
    name_mapping={
        "compute": "compute",
        "data_source": "dataSource",
        "name": "name",
        "group_by": "groupBy",
        "indexes": "indexes",
        "search": "search",
    },
)
class DashboardWidgetToplistDefinitionRequestQueryEventQuery:
    def __init__(
        self,
        *,
        compute: typing.Sequence["DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute"],
        data_source: builtins.str,
        name: builtins.str,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy"]] = None,
        indexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        search: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch"]] = None,
    ) -> None:
        '''
        :param compute: compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        :param data_source: Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param indexes: An array of index names to query in the stream. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        :param search: search block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "compute": compute,
            "data_source": data_source,
            "name": name,
        }
        if group_by is not None:
            self._values["group_by"] = group_by
        if indexes is not None:
            self._values["indexes"] = indexes
        if search is not None:
            self._values["search"] = search

    @builtins.property
    def compute(
        self,
    ) -> typing.List["DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute"]:
        '''compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute Dashboard#compute}
        '''
        result = self._values.get("compute")
        assert result is not None, "Required property 'compute' is missing"
        return typing.cast(typing.List["DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute"], result)

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for event platform-based queries. Valid values are ``logs``, ``spans``, ``network``, ``rum``, ``security_signals``, ``profiles``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy"]], result)

    @builtins.property
    def indexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of index names to query in the stream.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#indexes Dashboard#indexes}
        '''
        result = self._values.get("indexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def search(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch"]]:
        '''search block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search Dashboard#search}
        '''
        result = self._values.get("search")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestQueryEventQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "interval": "interval",
        "metric": "metric",
    },
)
class DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        interval: typing.Optional[jsii.Number] = None,
        metric: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param interval: A time interval in milliseconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        :param metric: Measurable attribute to compute. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if interval is not None:
            self._values["interval"] = interval
        if metric is not None:
            self._values["metric"] = metric

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''A time interval in milliseconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Measurable attribute to compute.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort": "sort"},
)
class DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy:
    def __init__(
        self,
        *,
        facet: builtins.str,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort"]] = None,
    ) -> None:
        '''
        :param facet: Event facet. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Number of groups to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: sort block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "facet": facet,
        }
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort

    @builtins.property
    def facet(self) -> builtins.str:
        '''Event facet.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        assert result is not None, "Required property 'facet' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of groups to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort"]]:
        '''sort block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "metric": "metric", "order": "order"},
)
class DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        metric: typing.Optional[builtins.str] = None,
        order: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: Aggregation methods for event platform queries. Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param metric: Metric used for sorting group by results. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param order: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if metric is not None:
            self._values["metric"] = metric
        if order is not None:
            self._values["order"] = order

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''Aggregation methods for event platform queries.

        Valid values are ``count``, ``cardinality``, ``median``, ``pc75``, ``pc90``, ``pc95``, ``pc98``, ``pc99``, ``sum``, ``min``, ``max``, ``avg``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''Metric used for sorting group by results.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def order(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Events search string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Events search string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestQueryMetricQuery",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "query": "query",
        "aggregator": "aggregator",
        "data_source": "dataSource",
    },
)
class DashboardWidgetToplistDefinitionRequestQueryMetricQuery:
    def __init__(
        self,
        *,
        name: builtins.str,
        query: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        data_source: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Name of the query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param query: Metrics query definition. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param data_source: Data source for metrics queries. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "query": query,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if data_source is not None:
            self._values["data_source"] = data_source

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''Metrics query definition.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#query Dashboard#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def data_source(self) -> typing.Optional[builtins.str]:
        '''Data source for metrics queries.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestQueryMetricQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestQueryProcessQuery",
    jsii_struct_bases=[],
    name_mapping={
        "data_source": "dataSource",
        "metric": "metric",
        "name": "name",
        "aggregator": "aggregator",
        "is_normalized_cpu": "isNormalizedCpu",
        "limit": "limit",
        "sort": "sort",
        "tag_filters": "tagFilters",
        "text_filter": "textFilter",
    },
)
class DashboardWidgetToplistDefinitionRequestQueryProcessQuery:
    def __init__(
        self,
        *,
        data_source: builtins.str,
        metric: builtins.str,
        name: builtins.str,
        aggregator: typing.Optional[builtins.str] = None,
        is_normalized_cpu: typing.Optional[builtins.bool] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort: typing.Optional[builtins.str] = None,
        tag_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
        text_filter: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param data_source: Data source for process queries. Valid values are ``process``, ``container``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        :param metric: Process metric name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        :param name: Name of query for use in formulas. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        :param aggregator: The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        :param is_normalized_cpu: Whether to normalize the CPU percentages. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        :param limit: Number of hits to return. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort: Direction of sort. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        :param tag_filters: An array of tags to filter by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        :param text_filter: Text to use as filter. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "data_source": data_source,
            "metric": metric,
            "name": name,
        }
        if aggregator is not None:
            self._values["aggregator"] = aggregator
        if is_normalized_cpu is not None:
            self._values["is_normalized_cpu"] = is_normalized_cpu
        if limit is not None:
            self._values["limit"] = limit
        if sort is not None:
            self._values["sort"] = sort
        if tag_filters is not None:
            self._values["tag_filters"] = tag_filters
        if text_filter is not None:
            self._values["text_filter"] = text_filter

    @builtins.property
    def data_source(self) -> builtins.str:
        '''Data source for process queries. Valid values are ``process``, ``container``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#data_source Dashboard#data_source}
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(self) -> builtins.str:
        '''Process metric name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#metric Dashboard#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of query for use in formulas.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#name Dashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregator(self) -> typing.Optional[builtins.str]:
        '''The aggregation methods available for metrics queries. Valid values are ``avg``, ``min``, ``max``, ``sum``, ``last``, ``area``, ``l2norm``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregator Dashboard#aggregator}
        '''
        result = self._values.get("aggregator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_normalized_cpu(self) -> typing.Optional[builtins.bool]:
        '''Whether to normalize the CPU percentages.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_normalized_cpu Dashboard#is_normalized_cpu}
        '''
        result = self._values.get("is_normalized_cpu")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Number of hits to return.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort(self) -> typing.Optional[builtins.str]:
        '''Direction of sort. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort Dashboard#sort}
        '''
        result = self._values.get("sort")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_filters(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of tags to filter by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#tag_filters Dashboard#tag_filters}
        '''
        result = self._values.get("tag_filters")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def text_filter(self) -> typing.Optional[builtins.str]:
        '''Text to use as filter.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#text_filter Dashboard#text_filter}
        '''
        result = self._values.get("text_filter")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestQueryProcessQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestRumQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetToplistDefinitionRequestRumQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestRumQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestRumQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestRumQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestRumQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestRumQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetToplistDefinitionRequestRumQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestRumQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestSecurityQuery",
    jsii_struct_bases=[],
    name_mapping={
        "index": "index",
        "compute_query": "computeQuery",
        "group_by": "groupBy",
        "multi_compute": "multiCompute",
        "search_query": "searchQuery",
    },
)
class DashboardWidgetToplistDefinitionRequestSecurityQuery:
    def __init__(
        self,
        *,
        index: builtins.str,
        compute_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery"]] = None,
        group_by: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy"]] = None,
        multi_compute: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute"]] = None,
        search_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param index: Name of the index to query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        :param compute_query: compute_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        :param multi_compute: multi_compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        :param search_query: The search query to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "index": index,
        }
        if compute_query is not None:
            self._values["compute_query"] = compute_query
        if group_by is not None:
            self._values["group_by"] = group_by
        if multi_compute is not None:
            self._values["multi_compute"] = multi_compute
        if search_query is not None:
            self._values["search_query"] = search_query

    @builtins.property
    def index(self) -> builtins.str:
        '''Name of the index to query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#index Dashboard#index}
        '''
        result = self._values.get("index")
        assert result is not None, "Required property 'index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def compute_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery"]]:
        '''compute_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#compute_query Dashboard#compute_query}
        '''
        result = self._values.get("compute_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery"]], result)

    @builtins.property
    def group_by(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#group_by Dashboard#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy"]], result)

    @builtins.property
    def multi_compute(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute"]]:
        '''multi_compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#multi_compute Dashboard#multi_compute}
        '''
        result = self._values.get("multi_compute")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute"]], result)

    @builtins.property
    def search_query(self) -> typing.Optional[builtins.str]:
        '''The search query to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#search_query Dashboard#search_query}
        '''
        result = self._values.get("search_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestSecurityQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy",
    jsii_struct_bases=[],
    name_mapping={"facet": "facet", "limit": "limit", "sort_query": "sortQuery"},
)
class DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy:
    def __init__(
        self,
        *,
        facet: typing.Optional[builtins.str] = None,
        limit: typing.Optional[jsii.Number] = None,
        sort_query: typing.Optional[typing.Sequence["DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery"]] = None,
    ) -> None:
        '''
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param limit: Maximum number of items in the group. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        :param sort_query: sort_query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if facet is not None:
            self._values["facet"] = facet
        if limit is not None:
            self._values["limit"] = limit
        if sort_query is not None:
            self._values["sort_query"] = sort_query

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of items in the group.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#limit Dashboard#limit}
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sort_query(
        self,
    ) -> typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery"]]:
        '''sort_query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#sort_query Dashboard#sort_query}
        '''
        result = self._values.get("sort_query")
        return typing.cast(typing.Optional[typing.List["DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery",
    jsii_struct_bases=[],
    name_mapping={"aggregation": "aggregation", "order": "order", "facet": "facet"},
)
class DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        order: builtins.str,
        facet: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param order: Widget sorting methods. Valid values are ``asc``, ``desc``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
            "order": order,
        }
        if facet is not None:
            self._values["facet"] = facet

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def order(self) -> builtins.str:
        '''Widget sorting methods. Valid values are ``asc``, ``desc``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#order Dashboard#order}
        '''
        result = self._values.get("order")
        assert result is not None, "Required property 'order' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute",
    jsii_struct_bases=[],
    name_mapping={
        "aggregation": "aggregation",
        "facet": "facet",
        "interval": "interval",
    },
)
class DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute:
    def __init__(
        self,
        *,
        aggregation: builtins.str,
        facet: typing.Optional[builtins.str] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param aggregation: The aggregation method. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        :param facet: Facet name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        :param interval: Define a time interval in seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation": aggregation,
        }
        if facet is not None:
            self._values["facet"] = facet
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def aggregation(self) -> builtins.str:
        '''The aggregation method.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#aggregation Dashboard#aggregation}
        '''
        result = self._values.get("aggregation")
        assert result is not None, "Required property 'aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def facet(self) -> typing.Optional[builtins.str]:
        '''Facet name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#facet Dashboard#facet}
        '''
        result = self._values.get("facet")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Define a time interval in seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#interval Dashboard#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetToplistDefinitionRequestStyle",
    jsii_struct_bases=[],
    name_mapping={"palette": "palette"},
)
class DashboardWidgetToplistDefinitionRequestStyle:
    def __init__(self, *, palette: typing.Optional[builtins.str] = None) -> None:
        '''
        :param palette: Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if palette is not None:
            self._values["palette"] = palette

    @builtins.property
    def palette(self) -> typing.Optional[builtins.str]:
        '''Color palette to apply to the widget. The available options are available here: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#palette Dashboard#palette}
        '''
        result = self._values.get("palette")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetToplistDefinitionRequestStyle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetTraceServiceDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "env": "env",
        "service": "service",
        "span_name": "spanName",
        "display_format": "displayFormat",
        "live_span": "liveSpan",
        "show_breakdown": "showBreakdown",
        "show_distribution": "showDistribution",
        "show_errors": "showErrors",
        "show_hits": "showHits",
        "show_latency": "showLatency",
        "show_resource_list": "showResourceList",
        "size_format": "sizeFormat",
        "title": "title",
        "title_align": "titleAlign",
        "title_size": "titleSize",
    },
)
class DashboardWidgetTraceServiceDefinition:
    def __init__(
        self,
        *,
        env: builtins.str,
        service: builtins.str,
        span_name: builtins.str,
        display_format: typing.Optional[builtins.str] = None,
        live_span: typing.Optional[builtins.str] = None,
        show_breakdown: typing.Optional[builtins.bool] = None,
        show_distribution: typing.Optional[builtins.bool] = None,
        show_errors: typing.Optional[builtins.bool] = None,
        show_hits: typing.Optional[builtins.bool] = None,
        show_latency: typing.Optional[builtins.bool] = None,
        show_resource_list: typing.Optional[builtins.bool] = None,
        size_format: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        title_align: typing.Optional[builtins.str] = None,
        title_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param env: APM environment. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#env Dashboard#env}
        :param service: APM service. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        :param span_name: APM span name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#span_name Dashboard#span_name}
        :param display_format: Number of columns to display. Valid values are ``one_column``, ``two_column``, ``three_column``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_format Dashboard#display_format}
        :param live_span: The timeframe to use when displaying the widget. Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        :param show_breakdown: Whether to show the latency breakdown or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_breakdown Dashboard#show_breakdown}
        :param show_distribution: Whether to show the latency distribution or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_distribution Dashboard#show_distribution}
        :param show_errors: Whether to show the error metrics or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_errors Dashboard#show_errors}
        :param show_hits: Whether to show the hits metrics or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_hits Dashboard#show_hits}
        :param show_latency: Whether to show the latency metrics or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_latency Dashboard#show_latency}
        :param show_resource_list: Whether to show the resource list or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_resource_list Dashboard#show_resource_list}
        :param size_format: Size of the widget. Valid values are ``small``, ``medium``, ``large``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#size_format Dashboard#size_format}
        :param title: The title of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        :param title_align: The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        :param title_size: The size of the widget's title. Default is 16. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "env": env,
            "service": service,
            "span_name": span_name,
        }
        if display_format is not None:
            self._values["display_format"] = display_format
        if live_span is not None:
            self._values["live_span"] = live_span
        if show_breakdown is not None:
            self._values["show_breakdown"] = show_breakdown
        if show_distribution is not None:
            self._values["show_distribution"] = show_distribution
        if show_errors is not None:
            self._values["show_errors"] = show_errors
        if show_hits is not None:
            self._values["show_hits"] = show_hits
        if show_latency is not None:
            self._values["show_latency"] = show_latency
        if show_resource_list is not None:
            self._values["show_resource_list"] = show_resource_list
        if size_format is not None:
            self._values["size_format"] = size_format
        if title is not None:
            self._values["title"] = title
        if title_align is not None:
            self._values["title_align"] = title_align
        if title_size is not None:
            self._values["title_size"] = title_size

    @builtins.property
    def env(self) -> builtins.str:
        '''APM environment.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#env Dashboard#env}
        '''
        result = self._values.get("env")
        assert result is not None, "Required property 'env' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> builtins.str:
        '''APM service.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#service Dashboard#service}
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def span_name(self) -> builtins.str:
        '''APM span name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#span_name Dashboard#span_name}
        '''
        result = self._values.get("span_name")
        assert result is not None, "Required property 'span_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def display_format(self) -> typing.Optional[builtins.str]:
        '''Number of columns to display. Valid values are ``one_column``, ``two_column``, ``three_column``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#display_format Dashboard#display_format}
        '''
        result = self._values.get("display_format")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def live_span(self) -> typing.Optional[builtins.str]:
        '''The timeframe to use when displaying the widget.

        Valid values are ``1m``, ``5m``, ``10m``, ``15m``, ``30m``, ``1h``, ``4h``, ``1d``, ``2d``, ``1w``, ``1mo``, ``3mo``, ``6mo``, ``1y``, ``alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#live_span Dashboard#live_span}
        '''
        result = self._values.get("live_span")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def show_breakdown(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the latency breakdown or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_breakdown Dashboard#show_breakdown}
        '''
        result = self._values.get("show_breakdown")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_distribution(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the latency distribution or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_distribution Dashboard#show_distribution}
        '''
        result = self._values.get("show_distribution")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_errors(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the error metrics or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_errors Dashboard#show_errors}
        '''
        result = self._values.get("show_errors")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_hits(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the hits metrics or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_hits Dashboard#show_hits}
        '''
        result = self._values.get("show_hits")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_latency(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the latency metrics or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_latency Dashboard#show_latency}
        '''
        result = self._values.get("show_latency")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def show_resource_list(self) -> typing.Optional[builtins.bool]:
        '''Whether to show the resource list or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#show_resource_list Dashboard#show_resource_list}
        '''
        result = self._values.get("show_resource_list")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def size_format(self) -> typing.Optional[builtins.str]:
        '''Size of the widget. Valid values are ``small``, ``medium``, ``large``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#size_format Dashboard#size_format}
        '''
        result = self._values.get("size_format")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''The title of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title Dashboard#title}
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_align(self) -> typing.Optional[builtins.str]:
        '''The alignment of the widget's title. Valid values are ``center``, ``left``, ``right``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_align Dashboard#title_align}
        '''
        result = self._values.get("title_align")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title_size(self) -> typing.Optional[builtins.str]:
        '''The size of the widget's title. Default is 16.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#title_size Dashboard#title_size}
        '''
        result = self._values.get("title_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetTraceServiceDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DashboardWidgetWidgetLayout",
    jsii_struct_bases=[],
    name_mapping={
        "height": "height",
        "width": "width",
        "x": "x",
        "y": "y",
        "is_column_break": "isColumnBreak",
    },
)
class DashboardWidgetWidgetLayout:
    def __init__(
        self,
        *,
        height: jsii.Number,
        width: jsii.Number,
        x: jsii.Number,
        y: jsii.Number,
        is_column_break: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param height: The height of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#height Dashboard#height}
        :param width: The width of the widget. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#width Dashboard#width}
        :param x: The position of the widget on the x (horizontal) axis. Should be greater or equal to 0. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#x Dashboard#x}
        :param y: The position of the widget on the y (vertical) axis. Should be greater or equal to 0. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#y Dashboard#y}
        :param is_column_break: Whether the widget should be the first one on the second column in high density or not. Only for the new dashboard layout and only one widget in the dashboard should have this property set to ``true``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_column_break Dashboard#is_column_break}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "height": height,
            "width": width,
            "x": x,
            "y": y,
        }
        if is_column_break is not None:
            self._values["is_column_break"] = is_column_break

    @builtins.property
    def height(self) -> jsii.Number:
        '''The height of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#height Dashboard#height}
        '''
        result = self._values.get("height")
        assert result is not None, "Required property 'height' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def width(self) -> jsii.Number:
        '''The width of the widget.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#width Dashboard#width}
        '''
        result = self._values.get("width")
        assert result is not None, "Required property 'width' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def x(self) -> jsii.Number:
        '''The position of the widget on the x (horizontal) axis. Should be greater or equal to 0.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#x Dashboard#x}
        '''
        result = self._values.get("x")
        assert result is not None, "Required property 'x' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def y(self) -> jsii.Number:
        '''The position of the widget on the y (vertical) axis. Should be greater or equal to 0.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#y Dashboard#y}
        '''
        result = self._values.get("y")
        assert result is not None, "Required property 'y' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def is_column_break(self) -> typing.Optional[builtins.bool]:
        '''Whether the widget should be the first one on the second column in high density or not.

        Only for the new dashboard layout and only one widget in the dashboard should have this property set to ``true``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/dashboard.html#is_column_break Dashboard#is_column_break}
        '''
        result = self._values.get("is_column_break")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DashboardWidgetWidgetLayout(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataDatadogDashboard(
    cdktf.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogDashboard",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/d/dashboard.html datadog_dashboard}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        name: builtins.str,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/d/dashboard.html datadog_dashboard} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param name: The dashboard name to search for. Must only match one dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/dashboard.html#name DataDatadogDashboard#name}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DataDatadogDashboardConfig(
            name=name,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(DataDatadogDashboard, self, [scope, id, config])

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="url")
    def url(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "url"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DataDatadogDashboardConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "name": "name",
    },
)
class DataDatadogDashboardConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        name: builtins.str,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param name: The dashboard name to search for. Must only match one dashboard. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/dashboard.html#name DataDatadogDashboard#name}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The dashboard name to search for. Must only match one dashboard.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/dashboard.html#name DataDatadogDashboard#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataDatadogDashboardConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataDatadogDashboardList(
    cdktf.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogDashboardList",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/d/dashboard_list.html datadog_dashboard_list}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        name: builtins.str,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/d/dashboard_list.html datadog_dashboard_list} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param name: A dashboard list name to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/dashboard_list.html#name DataDatadogDashboardList#name}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DataDatadogDashboardListConfig(
            name=name,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(DataDatadogDashboardList, self, [scope, id, config])

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DataDatadogDashboardListConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "name": "name",
    },
)
class DataDatadogDashboardListConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        name: builtins.str,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param name: A dashboard list name to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/dashboard_list.html#name DataDatadogDashboardList#name}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''A dashboard list name to limit the search.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/dashboard_list.html#name DataDatadogDashboardList#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataDatadogDashboardListConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataDatadogIpRanges(
    cdktf.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogIpRanges",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/d/ip_ranges.html datadog_ip_ranges}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/d/ip_ranges.html datadog_ip_ranges} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DataDatadogIpRangesConfig(
            count=count, depends_on=depends_on, lifecycle=lifecycle, provider=provider
        )

        jsii.create(DataDatadogIpRanges, self, [scope, id, config])

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @jsii.member(jsii_name="syntheticsIpv4ByLocation")
    def synthetics_ipv4_by_location(self, key: builtins.str) -> builtins.str:
        '''
        :param key: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "syntheticsIpv4ByLocation", [key]))

    @jsii.member(jsii_name="syntheticsIpv6ByLocation")
    def synthetics_ipv6_by_location(self, key: builtins.str) -> builtins.str:
        '''
        :param key: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "syntheticsIpv6ByLocation", [key]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="agentsIpv4")
    def agents_ipv4(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "agentsIpv4"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="agentsIpv6")
    def agents_ipv6(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "agentsIpv6"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apiIpv4")
    def api_ipv4(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "apiIpv4"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apiIpv6")
    def api_ipv6(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "apiIpv6"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apmIpv4")
    def apm_ipv4(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "apmIpv4"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apmIpv6")
    def apm_ipv6(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "apmIpv6"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="logsIpv4")
    def logs_ipv4(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "logsIpv4"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="logsIpv6")
    def logs_ipv6(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "logsIpv6"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="processIpv4")
    def process_ipv4(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "processIpv4"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="processIpv6")
    def process_ipv6(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "processIpv6"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="syntheticsIpv4")
    def synthetics_ipv4(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "syntheticsIpv4"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="syntheticsIpv6")
    def synthetics_ipv6(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "syntheticsIpv6"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="webhooksIpv4")
    def webhooks_ipv4(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "webhooksIpv4"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="webhooksIpv6")
    def webhooks_ipv6(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "webhooksIpv6"))


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DataDatadogIpRangesConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
    },
)
class DataDatadogIpRangesConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataDatadogIpRangesConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataDatadogMonitor(
    cdktf.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogMonitor",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/d/monitor.html datadog_monitor}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        monitor_tags_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
        name_filter: typing.Optional[builtins.str] = None,
        tags_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/d/monitor.html datadog_monitor} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param monitor_tags_filter: A list of monitor tags to limit the search. This filters on the tags set on the monitor itself. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitor.html#monitor_tags_filter DataDatadogMonitor#monitor_tags_filter}
        :param name_filter: A monitor name to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitor.html#name_filter DataDatadogMonitor#name_filter}
        :param tags_filter: A list of tags to limit the search. This filters on the monitor scope. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitor.html#tags_filter DataDatadogMonitor#tags_filter}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DataDatadogMonitorConfig(
            monitor_tags_filter=monitor_tags_filter,
            name_filter=name_filter,
            tags_filter=tags_filter,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(DataDatadogMonitor, self, [scope, id, config])

    @jsii.member(jsii_name="monitorThresholds")
    def monitor_thresholds(
        self,
        index: builtins.str,
    ) -> "DataDatadogMonitorMonitorThresholds":
        '''
        :param index: -
        '''
        return typing.cast("DataDatadogMonitorMonitorThresholds", jsii.invoke(self, "monitorThresholds", [index]))

    @jsii.member(jsii_name="monitorThresholdWindows")
    def monitor_threshold_windows(
        self,
        index: builtins.str,
    ) -> "DataDatadogMonitorMonitorThresholdWindows":
        '''
        :param index: -
        '''
        return typing.cast("DataDatadogMonitorMonitorThresholdWindows", jsii.invoke(self, "monitorThresholdWindows", [index]))

    @jsii.member(jsii_name="resetMonitorTagsFilter")
    def reset_monitor_tags_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMonitorTagsFilter", []))

    @jsii.member(jsii_name="resetNameFilter")
    def reset_name_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNameFilter", []))

    @jsii.member(jsii_name="resetTagsFilter")
    def reset_tags_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTagsFilter", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enableLogsSample")
    def enable_logs_sample(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableLogsSample"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="escalationMessage")
    def escalation_message(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "escalationMessage"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="evaluationDelay")
    def evaluation_delay(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "evaluationDelay"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupbySimpleMonitor")
    def groupby_simple_monitor(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "groupbySimpleMonitor"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="includeTags")
    def include_tags(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "includeTags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="locked")
    def locked(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "locked"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="message")
    def message(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "message"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="newHostDelay")
    def new_host_delay(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "newHostDelay"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="noDataTimeframe")
    def no_data_timeframe(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "noDataTimeframe"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="notifyAudit")
    def notify_audit(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "notifyAudit"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="notifyNoData")
    def notify_no_data(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "notifyNoData"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="query")
    def query(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "query"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="renotifyInterval")
    def renotify_interval(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "renotifyInterval"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requireFullWindow")
    def require_full_window(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "requireFullWindow"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="restrictedRoles")
    def restricted_roles(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "restrictedRoles"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="timeoutH")
    def timeout_h(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timeoutH"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorTagsFilterInput")
    def monitor_tags_filter_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "monitorTagsFilterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameFilterInput")
    def name_filter_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameFilterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsFilterInput")
    def tags_filter_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsFilterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorTagsFilter")
    def monitor_tags_filter(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "monitorTagsFilter"))

    @monitor_tags_filter.setter
    def monitor_tags_filter(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "monitorTagsFilter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameFilter")
    def name_filter(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameFilter"))

    @name_filter.setter
    def name_filter(self, value: builtins.str) -> None:
        jsii.set(self, "nameFilter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsFilter")
    def tags_filter(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tagsFilter"))

    @tags_filter.setter
    def tags_filter(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "tagsFilter", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DataDatadogMonitorConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "monitor_tags_filter": "monitorTagsFilter",
        "name_filter": "nameFilter",
        "tags_filter": "tagsFilter",
    },
)
class DataDatadogMonitorConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        monitor_tags_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
        name_filter: typing.Optional[builtins.str] = None,
        tags_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param monitor_tags_filter: A list of monitor tags to limit the search. This filters on the tags set on the monitor itself. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitor.html#monitor_tags_filter DataDatadogMonitor#monitor_tags_filter}
        :param name_filter: A monitor name to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitor.html#name_filter DataDatadogMonitor#name_filter}
        :param tags_filter: A list of tags to limit the search. This filters on the monitor scope. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitor.html#tags_filter DataDatadogMonitor#tags_filter}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if monitor_tags_filter is not None:
            self._values["monitor_tags_filter"] = monitor_tags_filter
        if name_filter is not None:
            self._values["name_filter"] = name_filter
        if tags_filter is not None:
            self._values["tags_filter"] = tags_filter

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def monitor_tags_filter(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of monitor tags to limit the search. This filters on the tags set on the monitor itself.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitor.html#monitor_tags_filter DataDatadogMonitor#monitor_tags_filter}
        '''
        result = self._values.get("monitor_tags_filter")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def name_filter(self) -> typing.Optional[builtins.str]:
        '''A monitor name to limit the search.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitor.html#name_filter DataDatadogMonitor#name_filter}
        '''
        result = self._values.get("name_filter")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags_filter(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of tags to limit the search. This filters on the monitor scope.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitor.html#tags_filter DataDatadogMonitor#tags_filter}
        '''
        result = self._values.get("tags_filter")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataDatadogMonitorConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataDatadogMonitorMonitorThresholdWindows(
    cdktf.ComplexComputedList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogMonitorMonitorThresholdWindows",
):
    def __init__(
        self,
        terraform_resource: cdktf.ITerraformResource,
        terraform_attribute: builtins.str,
        complex_computed_list_index: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: -
        :param terraform_attribute: -
        :param complex_computed_list_index: -

        :stability: experimental
        '''
        jsii.create(DataDatadogMonitorMonitorThresholdWindows, self, [terraform_resource, terraform_attribute, complex_computed_list_index])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="recoveryWindow")
    def recovery_window(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "recoveryWindow"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="triggerWindow")
    def trigger_window(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "triggerWindow"))


class DataDatadogMonitorMonitorThresholds(
    cdktf.ComplexComputedList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogMonitorMonitorThresholds",
):
    def __init__(
        self,
        terraform_resource: cdktf.ITerraformResource,
        terraform_attribute: builtins.str,
        complex_computed_list_index: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: -
        :param terraform_attribute: -
        :param complex_computed_list_index: -

        :stability: experimental
        '''
        jsii.create(DataDatadogMonitorMonitorThresholds, self, [terraform_resource, terraform_attribute, complex_computed_list_index])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="critical")
    def critical(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "critical"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="criticalRecovery")
    def critical_recovery(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "criticalRecovery"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ok")
    def ok(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "ok"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="unknown")
    def unknown(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "unknown"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="warning")
    def warning(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "warning"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="warningRecovery")
    def warning_recovery(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "warningRecovery"))


class DataDatadogMonitors(
    cdktf.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogMonitors",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/d/monitors.html datadog_monitors}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        monitor_tags_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
        name_filter: typing.Optional[builtins.str] = None,
        tags_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/d/monitors.html datadog_monitors} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param monitor_tags_filter: A list of monitor tags to limit the search. This filters on the tags set on the monitor itself. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitors.html#monitor_tags_filter DataDatadogMonitors#monitor_tags_filter}
        :param name_filter: A monitor name to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitors.html#name_filter DataDatadogMonitors#name_filter}
        :param tags_filter: A list of tags to limit the search. This filters on the monitor scope. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitors.html#tags_filter DataDatadogMonitors#tags_filter}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DataDatadogMonitorsConfig(
            monitor_tags_filter=monitor_tags_filter,
            name_filter=name_filter,
            tags_filter=tags_filter,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(DataDatadogMonitors, self, [scope, id, config])

    @jsii.member(jsii_name="monitors")
    def monitors(self, index: builtins.str) -> "DataDatadogMonitorsMonitors":
        '''
        :param index: -
        '''
        return typing.cast("DataDatadogMonitorsMonitors", jsii.invoke(self, "monitors", [index]))

    @jsii.member(jsii_name="resetMonitorTagsFilter")
    def reset_monitor_tags_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMonitorTagsFilter", []))

    @jsii.member(jsii_name="resetNameFilter")
    def reset_name_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNameFilter", []))

    @jsii.member(jsii_name="resetTagsFilter")
    def reset_tags_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTagsFilter", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorTagsFilterInput")
    def monitor_tags_filter_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "monitorTagsFilterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameFilterInput")
    def name_filter_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameFilterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsFilterInput")
    def tags_filter_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsFilterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorTagsFilter")
    def monitor_tags_filter(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "monitorTagsFilter"))

    @monitor_tags_filter.setter
    def monitor_tags_filter(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "monitorTagsFilter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameFilter")
    def name_filter(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameFilter"))

    @name_filter.setter
    def name_filter(self, value: builtins.str) -> None:
        jsii.set(self, "nameFilter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsFilter")
    def tags_filter(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tagsFilter"))

    @tags_filter.setter
    def tags_filter(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "tagsFilter", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DataDatadogMonitorsConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "monitor_tags_filter": "monitorTagsFilter",
        "name_filter": "nameFilter",
        "tags_filter": "tagsFilter",
    },
)
class DataDatadogMonitorsConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        monitor_tags_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
        name_filter: typing.Optional[builtins.str] = None,
        tags_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param monitor_tags_filter: A list of monitor tags to limit the search. This filters on the tags set on the monitor itself. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitors.html#monitor_tags_filter DataDatadogMonitors#monitor_tags_filter}
        :param name_filter: A monitor name to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitors.html#name_filter DataDatadogMonitors#name_filter}
        :param tags_filter: A list of tags to limit the search. This filters on the monitor scope. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitors.html#tags_filter DataDatadogMonitors#tags_filter}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if monitor_tags_filter is not None:
            self._values["monitor_tags_filter"] = monitor_tags_filter
        if name_filter is not None:
            self._values["name_filter"] = name_filter
        if tags_filter is not None:
            self._values["tags_filter"] = tags_filter

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def monitor_tags_filter(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of monitor tags to limit the search. This filters on the tags set on the monitor itself.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitors.html#monitor_tags_filter DataDatadogMonitors#monitor_tags_filter}
        '''
        result = self._values.get("monitor_tags_filter")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def name_filter(self) -> typing.Optional[builtins.str]:
        '''A monitor name to limit the search.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitors.html#name_filter DataDatadogMonitors#name_filter}
        '''
        result = self._values.get("name_filter")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags_filter(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of tags to limit the search. This filters on the monitor scope.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/monitors.html#tags_filter DataDatadogMonitors#tags_filter}
        '''
        result = self._values.get("tags_filter")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataDatadogMonitorsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataDatadogMonitorsMonitors(
    cdktf.ComplexComputedList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogMonitorsMonitors",
):
    def __init__(
        self,
        terraform_resource: cdktf.ITerraformResource,
        terraform_attribute: builtins.str,
        complex_computed_list_index: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: -
        :param terraform_attribute: -
        :param complex_computed_list_index: -

        :stability: experimental
        '''
        jsii.create(DataDatadogMonitorsMonitors, self, [terraform_resource, terraform_attribute, complex_computed_list_index])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))


class DataDatadogPermissions(
    cdktf.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogPermissions",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/d/permissions.html datadog_permissions}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/d/permissions.html datadog_permissions} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DataDatadogPermissionsConfig(
            count=count, depends_on=depends_on, lifecycle=lifecycle, provider=provider
        )

        jsii.create(DataDatadogPermissions, self, [scope, id, config])

    @jsii.member(jsii_name="permissions")
    def permissions(self, key: builtins.str) -> builtins.str:
        '''
        :param key: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "permissions", [key]))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DataDatadogPermissionsConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
    },
)
class DataDatadogPermissionsConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataDatadogPermissionsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataDatadogRole(
    cdktf.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogRole",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/d/role.html datadog_role}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        filter: builtins.str,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/d/role.html datadog_role} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param filter: A string on which to filter the roles. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/role.html#filter DataDatadogRole#filter}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DataDatadogRoleConfig(
            filter=filter,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(DataDatadogRole, self, [scope, id, config])

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filterInput")
    def filter_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "filterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="userCount")
    def user_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "userCount"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filter")
    def filter(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "filter"))

    @filter.setter
    def filter(self, value: builtins.str) -> None:
        jsii.set(self, "filter", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DataDatadogRoleConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "filter": "filter",
    },
)
class DataDatadogRoleConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        filter: builtins.str,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param filter: A string on which to filter the roles. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/role.html#filter DataDatadogRole#filter}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "filter": filter,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def filter(self) -> builtins.str:
        '''A string on which to filter the roles.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/role.html#filter DataDatadogRole#filter}
        '''
        result = self._values.get("filter")
        assert result is not None, "Required property 'filter' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataDatadogRoleConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataDatadogSecurityMonitoringRules(
    cdktf.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogSecurityMonitoringRules",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html datadog_security_monitoring_rules}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        default_only_filter: typing.Optional[builtins.bool] = None,
        name_filter: typing.Optional[builtins.str] = None,
        tags_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
        user_only_filter: typing.Optional[builtins.bool] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html datadog_security_monitoring_rules} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param default_only_filter: Limit the search to default rules. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#default_only_filter DataDatadogSecurityMonitoringRules#default_only_filter}
        :param name_filter: A rule name to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#name_filter DataDatadogSecurityMonitoringRules#name_filter}
        :param tags_filter: A list of tags to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#tags_filter DataDatadogSecurityMonitoringRules#tags_filter}
        :param user_only_filter: Limit the search to user rules. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#user_only_filter DataDatadogSecurityMonitoringRules#user_only_filter}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DataDatadogSecurityMonitoringRulesConfig(
            default_only_filter=default_only_filter,
            name_filter=name_filter,
            tags_filter=tags_filter,
            user_only_filter=user_only_filter,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(DataDatadogSecurityMonitoringRules, self, [scope, id, config])

    @jsii.member(jsii_name="resetDefaultOnlyFilter")
    def reset_default_only_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDefaultOnlyFilter", []))

    @jsii.member(jsii_name="resetNameFilter")
    def reset_name_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNameFilter", []))

    @jsii.member(jsii_name="resetTagsFilter")
    def reset_tags_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTagsFilter", []))

    @jsii.member(jsii_name="resetUserOnlyFilter")
    def reset_user_only_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUserOnlyFilter", []))

    @jsii.member(jsii_name="rules")
    def rules(self, index: builtins.str) -> "DataDatadogSecurityMonitoringRulesRules":
        '''
        :param index: -
        '''
        return typing.cast("DataDatadogSecurityMonitoringRulesRules", jsii.invoke(self, "rules", [index]))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ruleIds")
    def rule_ids(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "ruleIds"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="defaultOnlyFilterInput")
    def default_only_filter_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "defaultOnlyFilterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameFilterInput")
    def name_filter_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameFilterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsFilterInput")
    def tags_filter_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsFilterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="userOnlyFilterInput")
    def user_only_filter_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "userOnlyFilterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="defaultOnlyFilter")
    def default_only_filter(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "defaultOnlyFilter"))

    @default_only_filter.setter
    def default_only_filter(self, value: builtins.bool) -> None:
        jsii.set(self, "defaultOnlyFilter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameFilter")
    def name_filter(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameFilter"))

    @name_filter.setter
    def name_filter(self, value: builtins.str) -> None:
        jsii.set(self, "nameFilter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsFilter")
    def tags_filter(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tagsFilter"))

    @tags_filter.setter
    def tags_filter(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "tagsFilter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="userOnlyFilter")
    def user_only_filter(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "userOnlyFilter"))

    @user_only_filter.setter
    def user_only_filter(self, value: builtins.bool) -> None:
        jsii.set(self, "userOnlyFilter", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DataDatadogSecurityMonitoringRulesConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "default_only_filter": "defaultOnlyFilter",
        "name_filter": "nameFilter",
        "tags_filter": "tagsFilter",
        "user_only_filter": "userOnlyFilter",
    },
)
class DataDatadogSecurityMonitoringRulesConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        default_only_filter: typing.Optional[builtins.bool] = None,
        name_filter: typing.Optional[builtins.str] = None,
        tags_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
        user_only_filter: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param default_only_filter: Limit the search to default rules. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#default_only_filter DataDatadogSecurityMonitoringRules#default_only_filter}
        :param name_filter: A rule name to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#name_filter DataDatadogSecurityMonitoringRules#name_filter}
        :param tags_filter: A list of tags to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#tags_filter DataDatadogSecurityMonitoringRules#tags_filter}
        :param user_only_filter: Limit the search to user rules. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#user_only_filter DataDatadogSecurityMonitoringRules#user_only_filter}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if default_only_filter is not None:
            self._values["default_only_filter"] = default_only_filter
        if name_filter is not None:
            self._values["name_filter"] = name_filter
        if tags_filter is not None:
            self._values["tags_filter"] = tags_filter
        if user_only_filter is not None:
            self._values["user_only_filter"] = user_only_filter

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def default_only_filter(self) -> typing.Optional[builtins.bool]:
        '''Limit the search to default rules.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#default_only_filter DataDatadogSecurityMonitoringRules#default_only_filter}
        '''
        result = self._values.get("default_only_filter")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name_filter(self) -> typing.Optional[builtins.str]:
        '''A rule name to limit the search.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#name_filter DataDatadogSecurityMonitoringRules#name_filter}
        '''
        result = self._values.get("name_filter")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags_filter(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of tags to limit the search.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#tags_filter DataDatadogSecurityMonitoringRules#tags_filter}
        '''
        result = self._values.get("tags_filter")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def user_only_filter(self) -> typing.Optional[builtins.bool]:
        '''Limit the search to user rules.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/security_monitoring_rules.html#user_only_filter DataDatadogSecurityMonitoringRules#user_only_filter}
        '''
        result = self._values.get("user_only_filter")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataDatadogSecurityMonitoringRulesConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataDatadogSecurityMonitoringRulesRules(
    cdktf.ComplexComputedList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogSecurityMonitoringRulesRules",
):
    def __init__(
        self,
        terraform_resource: cdktf.ITerraformResource,
        terraform_attribute: builtins.str,
        complex_computed_list_index: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: -
        :param terraform_attribute: -
        :param complex_computed_list_index: -

        :stability: experimental
        '''
        jsii.create(DataDatadogSecurityMonitoringRulesRules, self, [terraform_resource, terraform_attribute, complex_computed_list_index])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="case")
    def case(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.get(self, "case"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enabled"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filter")
    def filter(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.get(self, "filter"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hasExtendedTitle")
    def has_extended_title(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "hasExtendedTitle"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="message")
    def message(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "message"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="options")
    def options(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.get(self, "options"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="query")
    def query(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.get(self, "query"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))


class DataDatadogSecurityMonitoringRulesRulesCase(
    cdktf.ComplexComputedList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogSecurityMonitoringRulesRulesCase",
):
    def __init__(
        self,
        terraform_resource: cdktf.ITerraformResource,
        terraform_attribute: builtins.str,
        complex_computed_list_index: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: -
        :param terraform_attribute: -
        :param complex_computed_list_index: -

        :stability: experimental
        '''
        jsii.create(DataDatadogSecurityMonitoringRulesRulesCase, self, [terraform_resource, terraform_attribute, complex_computed_list_index])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="condition")
    def condition(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "condition"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="notifications")
    def notifications(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "notifications"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="status")
    def status(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "status"))


class DataDatadogSecurityMonitoringRulesRulesFilter(
    cdktf.ComplexComputedList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogSecurityMonitoringRulesRulesFilter",
):
    def __init__(
        self,
        terraform_resource: cdktf.ITerraformResource,
        terraform_attribute: builtins.str,
        complex_computed_list_index: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: -
        :param terraform_attribute: -
        :param complex_computed_list_index: -

        :stability: experimental
        '''
        jsii.create(DataDatadogSecurityMonitoringRulesRulesFilter, self, [terraform_resource, terraform_attribute, complex_computed_list_index])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="query")
    def query(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "query"))


class DataDatadogSecurityMonitoringRulesRulesOptions(
    cdktf.ComplexComputedList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogSecurityMonitoringRulesRulesOptions",
):
    def __init__(
        self,
        terraform_resource: cdktf.ITerraformResource,
        terraform_attribute: builtins.str,
        complex_computed_list_index: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: -
        :param terraform_attribute: -
        :param complex_computed_list_index: -

        :stability: experimental
        '''
        jsii.create(DataDatadogSecurityMonitoringRulesRulesOptions, self, [terraform_resource, terraform_attribute, complex_computed_list_index])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="detectionMethod")
    def detection_method(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "detectionMethod"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="evaluationWindow")
    def evaluation_window(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "evaluationWindow"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="keepAlive")
    def keep_alive(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "keepAlive"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="maxSignalDuration")
    def max_signal_duration(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxSignalDuration"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="newValueOptions")
    def new_value_options(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.get(self, "newValueOptions"))


class DataDatadogSecurityMonitoringRulesRulesOptionsNewValueOptions(
    cdktf.ComplexComputedList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogSecurityMonitoringRulesRulesOptionsNewValueOptions",
):
    def __init__(
        self,
        terraform_resource: cdktf.ITerraformResource,
        terraform_attribute: builtins.str,
        complex_computed_list_index: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: -
        :param terraform_attribute: -
        :param complex_computed_list_index: -

        :stability: experimental
        '''
        jsii.create(DataDatadogSecurityMonitoringRulesRulesOptionsNewValueOptions, self, [terraform_resource, terraform_attribute, complex_computed_list_index])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="forgetAfter")
    def forget_after(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "forgetAfter"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="learningDuration")
    def learning_duration(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "learningDuration"))


class DataDatadogSecurityMonitoringRulesRulesQuery(
    cdktf.ComplexComputedList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogSecurityMonitoringRulesRulesQuery",
):
    def __init__(
        self,
        terraform_resource: cdktf.ITerraformResource,
        terraform_attribute: builtins.str,
        complex_computed_list_index: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: -
        :param terraform_attribute: -
        :param complex_computed_list_index: -

        :stability: experimental
        '''
        jsii.create(DataDatadogSecurityMonitoringRulesRulesQuery, self, [terraform_resource, terraform_attribute, complex_computed_list_index])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="aggregation")
    def aggregation(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "aggregation"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="distinctFields")
    def distinct_fields(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "distinctFields"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupByFields")
    def group_by_fields(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "groupByFields"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="metric")
    def metric(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "metric"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="query")
    def query(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "query"))


class DataDatadogServiceLevelObjective(
    cdktf.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogServiceLevelObjective",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html datadog_service_level_objective}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id_: builtins.str,
        *,
        id: typing.Optional[builtins.str] = None,
        metrics_query: typing.Optional[builtins.str] = None,
        name_query: typing.Optional[builtins.str] = None,
        tags_query: typing.Optional[builtins.str] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html datadog_service_level_objective} Data Source.

        :param scope: The scope in which to define this construct.
        :param id_: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param id: A SLO ID to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#id DataDatadogServiceLevelObjective#id}
        :param metrics_query: Filter results based on SLO numerator and denominator. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#metrics_query DataDatadogServiceLevelObjective#metrics_query}
        :param name_query: Filter results based on SLO names. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#name_query DataDatadogServiceLevelObjective#name_query}
        :param tags_query: Filter results based on a single SLO tag. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#tags_query DataDatadogServiceLevelObjective#tags_query}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DataDatadogServiceLevelObjectiveConfig(
            id=id,
            metrics_query=metrics_query,
            name_query=name_query,
            tags_query=tags_query,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(DataDatadogServiceLevelObjective, self, [scope, id_, config])

    @jsii.member(jsii_name="resetId")
    def reset_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetId", []))

    @jsii.member(jsii_name="resetMetricsQuery")
    def reset_metrics_query(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMetricsQuery", []))

    @jsii.member(jsii_name="resetNameQuery")
    def reset_name_query(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNameQuery", []))

    @jsii.member(jsii_name="resetTagsQuery")
    def reset_tags_query(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTagsQuery", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="idInput")
    def id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="metricsQueryInput")
    def metrics_query_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "metricsQueryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameQueryInput")
    def name_query_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameQueryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsQueryInput")
    def tags_query_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagsQueryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @id.setter
    def id(self, value: builtins.str) -> None:
        jsii.set(self, "id", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="metricsQuery")
    def metrics_query(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "metricsQuery"))

    @metrics_query.setter
    def metrics_query(self, value: builtins.str) -> None:
        jsii.set(self, "metricsQuery", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameQuery")
    def name_query(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameQuery"))

    @name_query.setter
    def name_query(self, value: builtins.str) -> None:
        jsii.set(self, "nameQuery", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsQuery")
    def tags_query(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tagsQuery"))

    @tags_query.setter
    def tags_query(self, value: builtins.str) -> None:
        jsii.set(self, "tagsQuery", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DataDatadogServiceLevelObjectiveConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "id": "id",
        "metrics_query": "metricsQuery",
        "name_query": "nameQuery",
        "tags_query": "tagsQuery",
    },
)
class DataDatadogServiceLevelObjectiveConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        id: typing.Optional[builtins.str] = None,
        metrics_query: typing.Optional[builtins.str] = None,
        name_query: typing.Optional[builtins.str] = None,
        tags_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param id: A SLO ID to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#id DataDatadogServiceLevelObjective#id}
        :param metrics_query: Filter results based on SLO numerator and denominator. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#metrics_query DataDatadogServiceLevelObjective#metrics_query}
        :param name_query: Filter results based on SLO names. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#name_query DataDatadogServiceLevelObjective#name_query}
        :param tags_query: Filter results based on a single SLO tag. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#tags_query DataDatadogServiceLevelObjective#tags_query}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if id is not None:
            self._values["id"] = id
        if metrics_query is not None:
            self._values["metrics_query"] = metrics_query
        if name_query is not None:
            self._values["name_query"] = name_query
        if tags_query is not None:
            self._values["tags_query"] = tags_query

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        '''A SLO ID to limit the search.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#id DataDatadogServiceLevelObjective#id}
        '''
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metrics_query(self) -> typing.Optional[builtins.str]:
        '''Filter results based on SLO numerator and denominator.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#metrics_query DataDatadogServiceLevelObjective#metrics_query}
        '''
        result = self._values.get("metrics_query")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name_query(self) -> typing.Optional[builtins.str]:
        '''Filter results based on SLO names.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#name_query DataDatadogServiceLevelObjective#name_query}
        '''
        result = self._values.get("name_query")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags_query(self) -> typing.Optional[builtins.str]:
        '''Filter results based on a single SLO tag.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objective.html#tags_query DataDatadogServiceLevelObjective#tags_query}
        '''
        result = self._values.get("tags_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataDatadogServiceLevelObjectiveConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataDatadogServiceLevelObjectives(
    cdktf.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogServiceLevelObjectives",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html datadog_service_level_objectives}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        metrics_query: typing.Optional[builtins.str] = None,
        name_query: typing.Optional[builtins.str] = None,
        tags_query: typing.Optional[builtins.str] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html datadog_service_level_objectives} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param ids: An array of SLO IDs to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#ids DataDatadogServiceLevelObjectives#ids}
        :param metrics_query: Filter results based on SLO numerator and denominator. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#metrics_query DataDatadogServiceLevelObjectives#metrics_query}
        :param name_query: Filter results based on SLO names. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#name_query DataDatadogServiceLevelObjectives#name_query}
        :param tags_query: Filter results based on a single SLO tag. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#tags_query DataDatadogServiceLevelObjectives#tags_query}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DataDatadogServiceLevelObjectivesConfig(
            ids=ids,
            metrics_query=metrics_query,
            name_query=name_query,
            tags_query=tags_query,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(DataDatadogServiceLevelObjectives, self, [scope, id, config])

    @jsii.member(jsii_name="resetIds")
    def reset_ids(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIds", []))

    @jsii.member(jsii_name="resetMetricsQuery")
    def reset_metrics_query(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMetricsQuery", []))

    @jsii.member(jsii_name="resetNameQuery")
    def reset_name_query(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNameQuery", []))

    @jsii.member(jsii_name="resetTagsQuery")
    def reset_tags_query(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTagsQuery", []))

    @jsii.member(jsii_name="slos")
    def slos(self, index: builtins.str) -> "DataDatadogServiceLevelObjectivesSlos":
        '''
        :param index: -
        '''
        return typing.cast("DataDatadogServiceLevelObjectivesSlos", jsii.invoke(self, "slos", [index]))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="idsInput")
    def ids_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "idsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="metricsQueryInput")
    def metrics_query_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "metricsQueryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameQueryInput")
    def name_query_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameQueryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsQueryInput")
    def tags_query_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagsQueryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ids")
    def ids(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "ids"))

    @ids.setter
    def ids(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "ids", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="metricsQuery")
    def metrics_query(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "metricsQuery"))

    @metrics_query.setter
    def metrics_query(self, value: builtins.str) -> None:
        jsii.set(self, "metricsQuery", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameQuery")
    def name_query(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameQuery"))

    @name_query.setter
    def name_query(self, value: builtins.str) -> None:
        jsii.set(self, "nameQuery", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsQuery")
    def tags_query(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tagsQuery"))

    @tags_query.setter
    def tags_query(self, value: builtins.str) -> None:
        jsii.set(self, "tagsQuery", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DataDatadogServiceLevelObjectivesConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "ids": "ids",
        "metrics_query": "metricsQuery",
        "name_query": "nameQuery",
        "tags_query": "tagsQuery",
    },
)
class DataDatadogServiceLevelObjectivesConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        metrics_query: typing.Optional[builtins.str] = None,
        name_query: typing.Optional[builtins.str] = None,
        tags_query: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param ids: An array of SLO IDs to limit the search. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#ids DataDatadogServiceLevelObjectives#ids}
        :param metrics_query: Filter results based on SLO numerator and denominator. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#metrics_query DataDatadogServiceLevelObjectives#metrics_query}
        :param name_query: Filter results based on SLO names. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#name_query DataDatadogServiceLevelObjectives#name_query}
        :param tags_query: Filter results based on a single SLO tag. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#tags_query DataDatadogServiceLevelObjectives#tags_query}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if ids is not None:
            self._values["ids"] = ids
        if metrics_query is not None:
            self._values["metrics_query"] = metrics_query
        if name_query is not None:
            self._values["name_query"] = name_query
        if tags_query is not None:
            self._values["tags_query"] = tags_query

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of SLO IDs to limit the search.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#ids DataDatadogServiceLevelObjectives#ids}
        '''
        result = self._values.get("ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def metrics_query(self) -> typing.Optional[builtins.str]:
        '''Filter results based on SLO numerator and denominator.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#metrics_query DataDatadogServiceLevelObjectives#metrics_query}
        '''
        result = self._values.get("metrics_query")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name_query(self) -> typing.Optional[builtins.str]:
        '''Filter results based on SLO names.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#name_query DataDatadogServiceLevelObjectives#name_query}
        '''
        result = self._values.get("name_query")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags_query(self) -> typing.Optional[builtins.str]:
        '''Filter results based on a single SLO tag.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/d/service_level_objectives.html#tags_query DataDatadogServiceLevelObjectives#tags_query}
        '''
        result = self._values.get("tags_query")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataDatadogServiceLevelObjectivesConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataDatadogServiceLevelObjectivesSlos(
    cdktf.ComplexComputedList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogServiceLevelObjectivesSlos",
):
    def __init__(
        self,
        terraform_resource: cdktf.ITerraformResource,
        terraform_attribute: builtins.str,
        complex_computed_list_index: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: -
        :param terraform_attribute: -
        :param complex_computed_list_index: -

        :stability: experimental
        '''
        jsii.create(DataDatadogServiceLevelObjectivesSlos, self, [terraform_resource, terraform_attribute, complex_computed_list_index])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))


class DataDatadogSyntheticsLocations(
    cdktf.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DataDatadogSyntheticsLocations",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/d/synthetics_locations.html datadog_synthetics_locations}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/d/synthetics_locations.html datadog_synthetics_locations} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DataDatadogSyntheticsLocationsConfig(
            count=count, depends_on=depends_on, lifecycle=lifecycle, provider=provider
        )

        jsii.create(DataDatadogSyntheticsLocations, self, [scope, id, config])

    @jsii.member(jsii_name="locations")
    def locations(self, key: builtins.str) -> builtins.str:
        '''
        :param key: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "locations", [key]))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DataDatadogSyntheticsLocationsConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
    },
)
class DataDatadogSyntheticsLocationsConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataDatadogSyntheticsLocationsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DatadogProvider(
    cdktf.TerraformProvider,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.DatadogProvider",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog datadog}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        alias: typing.Optional[builtins.str] = None,
        api_key: typing.Optional[builtins.str] = None,
        api_url: typing.Optional[builtins.str] = None,
        app_key: typing.Optional[builtins.str] = None,
        http_client_retry_enabled: typing.Optional[builtins.bool] = None,
        http_client_retry_timeout: typing.Optional[jsii.Number] = None,
        validate: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog datadog} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param alias: Alias name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#alias DatadogProvider#alias}
        :param api_key: (Required unless validate is false) Datadog API key. This can also be set via the DD_API_KEY environment variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#api_key DatadogProvider#api_key}
        :param api_url: The API URL. This can also be set via the DD_HOST environment variable. Note that this URL must not end with the /api/ path. For example, https://api.datadoghq.com/ is a correct value, while https://api.datadoghq.com/api/ is not. And if you're working with "EU" version of Datadog, use https://api.datadoghq.eu/. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#api_url DatadogProvider#api_url}
        :param app_key: (Required unless validate is false) Datadog APP key. This can also be set via the DD_APP_KEY environment variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#app_key DatadogProvider#app_key}
        :param http_client_retry_enabled: Enables request retries on HTTP status codes 429 and 5xx. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#http_client_retry_enabled DatadogProvider#http_client_retry_enabled}
        :param http_client_retry_timeout: The HTTP request retry timeout period. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#http_client_retry_timeout DatadogProvider#http_client_retry_timeout}
        :param validate: Enables validation of the provided API and APP keys during provider initialization. Default is true. When false, api_key and app_key won't be checked. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#validate DatadogProvider#validate}
        '''
        config = DatadogProviderConfig(
            alias=alias,
            api_key=api_key,
            api_url=api_url,
            app_key=app_key,
            http_client_retry_enabled=http_client_retry_enabled,
            http_client_retry_timeout=http_client_retry_timeout,
            validate=validate,
        )

        jsii.create(DatadogProvider, self, [scope, id, config])

    @jsii.member(jsii_name="resetAlias")
    def reset_alias(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlias", []))

    @jsii.member(jsii_name="resetApiKey")
    def reset_api_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetApiKey", []))

    @jsii.member(jsii_name="resetApiUrl")
    def reset_api_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetApiUrl", []))

    @jsii.member(jsii_name="resetAppKey")
    def reset_app_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAppKey", []))

    @jsii.member(jsii_name="resetHttpClientRetryEnabled")
    def reset_http_client_retry_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpClientRetryEnabled", []))

    @jsii.member(jsii_name="resetHttpClientRetryTimeout")
    def reset_http_client_retry_timeout(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHttpClientRetryTimeout", []))

    @jsii.member(jsii_name="resetValidate")
    def reset_validate(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValidate", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="aliasInput")
    def alias_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "aliasInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apiKeyInput")
    def api_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiKeyInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apiUrlInput")
    def api_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiUrlInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="appKeyInput")
    def app_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "appKeyInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="httpClientRetryEnabledInput")
    def http_client_retry_enabled_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "httpClientRetryEnabledInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="httpClientRetryTimeoutInput")
    def http_client_retry_timeout_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "httpClientRetryTimeoutInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="validateInput")
    def validate_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "validateInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="alias")
    def alias(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "alias"))

    @alias.setter
    def alias(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "alias", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apiKey")
    def api_key(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiKey"))

    @api_key.setter
    def api_key(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "apiKey", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apiUrl")
    def api_url(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiUrl"))

    @api_url.setter
    def api_url(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "apiUrl", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="appKey")
    def app_key(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "appKey"))

    @app_key.setter
    def app_key(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "appKey", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="httpClientRetryEnabled")
    def http_client_retry_enabled(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "httpClientRetryEnabled"))

    @http_client_retry_enabled.setter
    def http_client_retry_enabled(self, value: typing.Optional[builtins.bool]) -> None:
        jsii.set(self, "httpClientRetryEnabled", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="httpClientRetryTimeout")
    def http_client_retry_timeout(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "httpClientRetryTimeout"))

    @http_client_retry_timeout.setter
    def http_client_retry_timeout(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "httpClientRetryTimeout", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="validate")
    def validate(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "validate"))

    @validate.setter
    def validate(self, value: typing.Optional[builtins.bool]) -> None:
        jsii.set(self, "validate", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DatadogProviderConfig",
    jsii_struct_bases=[],
    name_mapping={
        "alias": "alias",
        "api_key": "apiKey",
        "api_url": "apiUrl",
        "app_key": "appKey",
        "http_client_retry_enabled": "httpClientRetryEnabled",
        "http_client_retry_timeout": "httpClientRetryTimeout",
        "validate": "validate",
    },
)
class DatadogProviderConfig:
    def __init__(
        self,
        *,
        alias: typing.Optional[builtins.str] = None,
        api_key: typing.Optional[builtins.str] = None,
        api_url: typing.Optional[builtins.str] = None,
        app_key: typing.Optional[builtins.str] = None,
        http_client_retry_enabled: typing.Optional[builtins.bool] = None,
        http_client_retry_timeout: typing.Optional[jsii.Number] = None,
        validate: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param alias: Alias name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#alias DatadogProvider#alias}
        :param api_key: (Required unless validate is false) Datadog API key. This can also be set via the DD_API_KEY environment variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#api_key DatadogProvider#api_key}
        :param api_url: The API URL. This can also be set via the DD_HOST environment variable. Note that this URL must not end with the /api/ path. For example, https://api.datadoghq.com/ is a correct value, while https://api.datadoghq.com/api/ is not. And if you're working with "EU" version of Datadog, use https://api.datadoghq.eu/. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#api_url DatadogProvider#api_url}
        :param app_key: (Required unless validate is false) Datadog APP key. This can also be set via the DD_APP_KEY environment variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#app_key DatadogProvider#app_key}
        :param http_client_retry_enabled: Enables request retries on HTTP status codes 429 and 5xx. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#http_client_retry_enabled DatadogProvider#http_client_retry_enabled}
        :param http_client_retry_timeout: The HTTP request retry timeout period. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#http_client_retry_timeout DatadogProvider#http_client_retry_timeout}
        :param validate: Enables validation of the provided API and APP keys during provider initialization. Default is true. When false, api_key and app_key won't be checked. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#validate DatadogProvider#validate}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if alias is not None:
            self._values["alias"] = alias
        if api_key is not None:
            self._values["api_key"] = api_key
        if api_url is not None:
            self._values["api_url"] = api_url
        if app_key is not None:
            self._values["app_key"] = app_key
        if http_client_retry_enabled is not None:
            self._values["http_client_retry_enabled"] = http_client_retry_enabled
        if http_client_retry_timeout is not None:
            self._values["http_client_retry_timeout"] = http_client_retry_timeout
        if validate is not None:
            self._values["validate"] = validate

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''Alias name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#alias DatadogProvider#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def api_key(self) -> typing.Optional[builtins.str]:
        '''(Required unless validate is false) Datadog API key. This can also be set via the DD_API_KEY environment variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#api_key DatadogProvider#api_key}
        '''
        result = self._values.get("api_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def api_url(self) -> typing.Optional[builtins.str]:
        '''The API URL.

        This can also be set via the DD_HOST environment variable. Note that this URL must not end with the /api/ path. For example, https://api.datadoghq.com/ is a correct value, while https://api.datadoghq.com/api/ is not. And if you're working with "EU" version of Datadog, use https://api.datadoghq.eu/.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#api_url DatadogProvider#api_url}
        '''
        result = self._values.get("api_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def app_key(self) -> typing.Optional[builtins.str]:
        '''(Required unless validate is false) Datadog APP key. This can also be set via the DD_APP_KEY environment variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#app_key DatadogProvider#app_key}
        '''
        result = self._values.get("app_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_client_retry_enabled(self) -> typing.Optional[builtins.bool]:
        '''Enables request retries on HTTP status codes 429 and 5xx.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#http_client_retry_enabled DatadogProvider#http_client_retry_enabled}
        '''
        result = self._values.get("http_client_retry_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def http_client_retry_timeout(self) -> typing.Optional[jsii.Number]:
        '''The HTTP request retry timeout period.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#http_client_retry_timeout DatadogProvider#http_client_retry_timeout}
        '''
        result = self._values.get("http_client_retry_timeout")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def validate(self) -> typing.Optional[builtins.bool]:
        '''Enables validation of the provided API and APP keys during provider initialization.

        Default is true. When false, api_key and app_key won't be checked.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog#validate DatadogProvider#validate}
        '''
        result = self._values.get("validate")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatadogProviderConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Downtime(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.Downtime",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html datadog_downtime}.'''

    def __init__(
        self,
        scope_: constructs.Construct,
        id: builtins.str,
        *,
        scope: typing.Sequence[builtins.str],
        end: typing.Optional[jsii.Number] = None,
        end_date: typing.Optional[builtins.str] = None,
        message: typing.Optional[builtins.str] = None,
        monitor_id: typing.Optional[jsii.Number] = None,
        monitor_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        recurrence: typing.Optional[typing.Sequence["DowntimeRecurrence"]] = None,
        start: typing.Optional[jsii.Number] = None,
        start_date: typing.Optional[builtins.str] = None,
        timezone: typing.Optional[builtins.str] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html datadog_downtime} Resource.

        :param scope_: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param scope: specify the group scope to which this downtime applies. For everything use '*'. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#scope Downtime#scope}
        :param end: Optionally specify an end date when this downtime should expire. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#end Downtime#end}
        :param end_date: String representing date and time to end the downtime in RFC3339 format. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#end_date Downtime#end_date}
        :param message: An optional message to provide when creating the downtime, can include notification handles. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#message Downtime#message}
        :param monitor_id: When specified, this downtime will only apply to this monitor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#monitor_id Downtime#monitor_id}
        :param monitor_tags: A list of monitor tags (up to 25), i.e. tags that are applied directly to monitors to which the downtime applies. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#monitor_tags Downtime#monitor_tags}
        :param recurrence: recurrence block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#recurrence Downtime#recurrence}
        :param start: Specify when this downtime should start. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#start Downtime#start}
        :param start_date: String representing date and time to start the downtime in RFC3339 format. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#start_date Downtime#start_date}
        :param timezone: The timezone for the downtime, default UTC. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#timezone Downtime#timezone}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = DowntimeConfig(
            scope=scope,
            end=end,
            end_date=end_date,
            message=message,
            monitor_id=monitor_id,
            monitor_tags=monitor_tags,
            recurrence=recurrence,
            start=start,
            start_date=start_date,
            timezone=timezone,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(Downtime, self, [scope_, id, config])

    @jsii.member(jsii_name="resetEnd")
    def reset_end(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnd", []))

    @jsii.member(jsii_name="resetEndDate")
    def reset_end_date(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndDate", []))

    @jsii.member(jsii_name="resetMessage")
    def reset_message(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMessage", []))

    @jsii.member(jsii_name="resetMonitorId")
    def reset_monitor_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMonitorId", []))

    @jsii.member(jsii_name="resetMonitorTags")
    def reset_monitor_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMonitorTags", []))

    @jsii.member(jsii_name="resetRecurrence")
    def reset_recurrence(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRecurrence", []))

    @jsii.member(jsii_name="resetStart")
    def reset_start(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStart", []))

    @jsii.member(jsii_name="resetStartDate")
    def reset_start_date(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStartDate", []))

    @jsii.member(jsii_name="resetTimezone")
    def reset_timezone(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimezone", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="active")
    def active(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "active"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="activeChildId")
    def active_child_id(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "activeChildId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "disabled"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="scopeInput")
    def scope_input(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "scopeInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="endDateInput")
    def end_date_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endDateInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="endInput")
    def end_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "endInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="messageInput")
    def message_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "messageInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorIdInput")
    def monitor_id_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "monitorIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorTagsInput")
    def monitor_tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "monitorTagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="recurrenceInput")
    def recurrence_input(self) -> typing.Optional[typing.List["DowntimeRecurrence"]]:
        return typing.cast(typing.Optional[typing.List["DowntimeRecurrence"]], jsii.get(self, "recurrenceInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="startDateInput")
    def start_date_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "startDateInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="startInput")
    def start_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "startInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="timezoneInput")
    def timezone_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timezoneInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="end")
    def end(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "end"))

    @end.setter
    def end(self, value: jsii.Number) -> None:
        jsii.set(self, "end", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="endDate")
    def end_date(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "endDate"))

    @end_date.setter
    def end_date(self, value: builtins.str) -> None:
        jsii.set(self, "endDate", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="message")
    def message(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "message"))

    @message.setter
    def message(self, value: builtins.str) -> None:
        jsii.set(self, "message", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorId")
    def monitor_id(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "monitorId"))

    @monitor_id.setter
    def monitor_id(self, value: jsii.Number) -> None:
        jsii.set(self, "monitorId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorTags")
    def monitor_tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "monitorTags"))

    @monitor_tags.setter
    def monitor_tags(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "monitorTags", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="recurrence")
    def recurrence(self) -> typing.List["DowntimeRecurrence"]:
        return typing.cast(typing.List["DowntimeRecurrence"], jsii.get(self, "recurrence"))

    @recurrence.setter
    def recurrence(self, value: typing.List["DowntimeRecurrence"]) -> None:
        jsii.set(self, "recurrence", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="scope")
    def scope(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "scope"))

    @scope.setter
    def scope(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "scope", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="start")
    def start(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "start"))

    @start.setter
    def start(self, value: jsii.Number) -> None:
        jsii.set(self, "start", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="startDate")
    def start_date(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "startDate"))

    @start_date.setter
    def start_date(self, value: builtins.str) -> None:
        jsii.set(self, "startDate", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="timezone")
    def timezone(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "timezone"))

    @timezone.setter
    def timezone(self, value: builtins.str) -> None:
        jsii.set(self, "timezone", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DowntimeConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "scope": "scope",
        "end": "end",
        "end_date": "endDate",
        "message": "message",
        "monitor_id": "monitorId",
        "monitor_tags": "monitorTags",
        "recurrence": "recurrence",
        "start": "start",
        "start_date": "startDate",
        "timezone": "timezone",
    },
)
class DowntimeConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        scope: typing.Sequence[builtins.str],
        end: typing.Optional[jsii.Number] = None,
        end_date: typing.Optional[builtins.str] = None,
        message: typing.Optional[builtins.str] = None,
        monitor_id: typing.Optional[jsii.Number] = None,
        monitor_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        recurrence: typing.Optional[typing.Sequence["DowntimeRecurrence"]] = None,
        start: typing.Optional[jsii.Number] = None,
        start_date: typing.Optional[builtins.str] = None,
        timezone: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param scope: specify the group scope to which this downtime applies. For everything use '*'. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#scope Downtime#scope}
        :param end: Optionally specify an end date when this downtime should expire. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#end Downtime#end}
        :param end_date: String representing date and time to end the downtime in RFC3339 format. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#end_date Downtime#end_date}
        :param message: An optional message to provide when creating the downtime, can include notification handles. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#message Downtime#message}
        :param monitor_id: When specified, this downtime will only apply to this monitor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#monitor_id Downtime#monitor_id}
        :param monitor_tags: A list of monitor tags (up to 25), i.e. tags that are applied directly to monitors to which the downtime applies. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#monitor_tags Downtime#monitor_tags}
        :param recurrence: recurrence block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#recurrence Downtime#recurrence}
        :param start: Specify when this downtime should start. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#start Downtime#start}
        :param start_date: String representing date and time to start the downtime in RFC3339 format. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#start_date Downtime#start_date}
        :param timezone: The timezone for the downtime, default UTC. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#timezone Downtime#timezone}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "scope": scope,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if end is not None:
            self._values["end"] = end
        if end_date is not None:
            self._values["end_date"] = end_date
        if message is not None:
            self._values["message"] = message
        if monitor_id is not None:
            self._values["monitor_id"] = monitor_id
        if monitor_tags is not None:
            self._values["monitor_tags"] = monitor_tags
        if recurrence is not None:
            self._values["recurrence"] = recurrence
        if start is not None:
            self._values["start"] = start
        if start_date is not None:
            self._values["start_date"] = start_date
        if timezone is not None:
            self._values["timezone"] = timezone

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def scope(self) -> typing.List[builtins.str]:
        '''specify the group scope to which this downtime applies. For everything use '*'.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#scope Downtime#scope}
        '''
        result = self._values.get("scope")
        assert result is not None, "Required property 'scope' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def end(self) -> typing.Optional[jsii.Number]:
        '''Optionally specify an end date when this downtime should expire.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#end Downtime#end}
        '''
        result = self._values.get("end")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def end_date(self) -> typing.Optional[builtins.str]:
        '''String representing date and time to end the downtime in RFC3339 format.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#end_date Downtime#end_date}
        '''
        result = self._values.get("end_date")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def message(self) -> typing.Optional[builtins.str]:
        '''An optional message to provide when creating the downtime, can include notification handles.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#message Downtime#message}
        '''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitor_id(self) -> typing.Optional[jsii.Number]:
        '''When specified, this downtime will only apply to this monitor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#monitor_id Downtime#monitor_id}
        '''
        result = self._values.get("monitor_id")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitor_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of monitor tags (up to 25), i.e. tags that are applied directly to monitors to which the downtime applies.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#monitor_tags Downtime#monitor_tags}
        '''
        result = self._values.get("monitor_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def recurrence(self) -> typing.Optional[typing.List["DowntimeRecurrence"]]:
        '''recurrence block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#recurrence Downtime#recurrence}
        '''
        result = self._values.get("recurrence")
        return typing.cast(typing.Optional[typing.List["DowntimeRecurrence"]], result)

    @builtins.property
    def start(self) -> typing.Optional[jsii.Number]:
        '''Specify when this downtime should start.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#start Downtime#start}
        '''
        result = self._values.get("start")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def start_date(self) -> typing.Optional[builtins.str]:
        '''String representing date and time to start the downtime in RFC3339 format.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#start_date Downtime#start_date}
        '''
        result = self._values.get("start_date")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timezone(self) -> typing.Optional[builtins.str]:
        '''The timezone for the downtime, default UTC.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#timezone Downtime#timezone}
        '''
        result = self._values.get("timezone")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DowntimeConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.DowntimeRecurrence",
    jsii_struct_bases=[],
    name_mapping={
        "type": "type",
        "period": "period",
        "rrule": "rrule",
        "until_date": "untilDate",
        "until_occurrences": "untilOccurrences",
        "week_days": "weekDays",
    },
)
class DowntimeRecurrence:
    def __init__(
        self,
        *,
        type: builtins.str,
        period: typing.Optional[jsii.Number] = None,
        rrule: typing.Optional[builtins.str] = None,
        until_date: typing.Optional[jsii.Number] = None,
        until_occurrences: typing.Optional[jsii.Number] = None,
        week_days: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param type: One of ``days``, ``weeks``, ``months``, or ``years``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#type Downtime#type}
        :param period: How often to repeat as an integer. For example to repeat every 3 days, select a ``type`` of ``days`` and a ``period`` of ``3``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#period Downtime#period}
        :param rrule: The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use ``FREQ=MONTHLY;INTERVAL=1``. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, ``DTSTART``, ``DTEND``, ``DURATION``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#rrule Downtime#rrule}
        :param until_date: The date at which the recurrence should end as a POSIX timestamp. ``until_occurrences`` and ``until_date`` are mutually exclusive. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#until_date Downtime#until_date}
        :param until_occurrences: How many times the downtime will be rescheduled. ``until_occurrences`` and ``until_date`` are mutually exclusive. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#until_occurrences Downtime#until_occurrences}
        :param week_days: A list of week days to repeat on. Choose from: ``Mon``, ``Tue``, ``Wed``, ``Thu``, ``Fri``, ``Sat`` or ``Sun``. Only applicable when ``type`` is ``weeks``. First letter must be capitalized. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#week_days Downtime#week_days}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if period is not None:
            self._values["period"] = period
        if rrule is not None:
            self._values["rrule"] = rrule
        if until_date is not None:
            self._values["until_date"] = until_date
        if until_occurrences is not None:
            self._values["until_occurrences"] = until_occurrences
        if week_days is not None:
            self._values["week_days"] = week_days

    @builtins.property
    def type(self) -> builtins.str:
        '''One of ``days``, ``weeks``, ``months``, or ``years``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#type Downtime#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def period(self) -> typing.Optional[jsii.Number]:
        '''How often to repeat as an integer.

        For example to repeat every 3 days, select a ``type`` of ``days`` and a ``period`` of ``3``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#period Downtime#period}
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def rrule(self) -> typing.Optional[builtins.str]:
        '''The RRULE standard for defining recurring events.

        For example, to have a recurring event on the first day of each month, use ``FREQ=MONTHLY;INTERVAL=1``. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, ``DTSTART``, ``DTEND``, ``DURATION``).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#rrule Downtime#rrule}
        '''
        result = self._values.get("rrule")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def until_date(self) -> typing.Optional[jsii.Number]:
        '''The date at which the recurrence should end as a POSIX timestamp. ``until_occurrences`` and ``until_date`` are mutually exclusive.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#until_date Downtime#until_date}
        '''
        result = self._values.get("until_date")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def until_occurrences(self) -> typing.Optional[jsii.Number]:
        '''How many times the downtime will be rescheduled. ``until_occurrences`` and ``until_date`` are mutually exclusive.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#until_occurrences Downtime#until_occurrences}
        '''
        result = self._values.get("until_occurrences")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def week_days(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of week days to repeat on.

        Choose from: ``Mon``, ``Tue``, ``Wed``, ``Thu``, ``Fri``, ``Sat`` or ``Sun``. Only applicable when ``type`` is ``weeks``. First letter must be capitalized.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/downtime.html#week_days Downtime#week_days}
        '''
        result = self._values.get("week_days")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DowntimeRecurrence(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IntegrationAws(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.IntegrationAws",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html datadog_integration_aws}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        access_key_id: typing.Optional[builtins.str] = None,
        account_id: typing.Optional[builtins.str] = None,
        account_specific_namespace_rules: typing.Optional[typing.Mapping[builtins.str, builtins.bool]] = None,
        excluded_regions: typing.Optional[typing.Sequence[builtins.str]] = None,
        filter_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        host_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        role_name: typing.Optional[builtins.str] = None,
        secret_access_key: typing.Optional[builtins.str] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html datadog_integration_aws} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param access_key_id: Your AWS access key ID. Only required if your AWS account is a GovCloud or China account. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#access_key_id IntegrationAws#access_key_id}
        :param account_id: Your AWS Account ID without dashes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#account_id IntegrationAws#account_id}
        :param account_specific_namespace_rules: Enables or disables metric collection for specific AWS namespaces for this AWS account only. A list of namespaces can be found at the `available namespace rules API endpoint <https://docs.datadoghq.com/api/v1/aws-integration/#list-namespace-rules>`_. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#account_specific_namespace_rules IntegrationAws#account_specific_namespace_rules}
        :param excluded_regions: An array of AWS regions to exclude from metrics collection. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#excluded_regions IntegrationAws#excluded_regions}
        :param filter_tags: Array of EC2 tags (in the form ``key:value``) defines a filter that Datadog uses when collecting metrics from EC2. Wildcards, such as ``?`` (for single characters) and ``*`` (for multiple characters) can also be used. Only hosts that match one of the defined tags will be imported into Datadog. The rest will be ignored. Host matching a given tag can also be excluded by adding ``!`` before the tag. e.x. ``env:production,instance-type:c1.*,!region:us-east-1``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#filter_tags IntegrationAws#filter_tags}
        :param host_tags: Array of tags (in the form ``key:value``) to add to all hosts and metrics reporting through this integration. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#host_tags IntegrationAws#host_tags}
        :param role_name: Your Datadog role delegation name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#role_name IntegrationAws#role_name}
        :param secret_access_key: Your AWS secret access key. Only required if your AWS account is a GovCloud or China account. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#secret_access_key IntegrationAws#secret_access_key}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = IntegrationAwsConfig(
            access_key_id=access_key_id,
            account_id=account_id,
            account_specific_namespace_rules=account_specific_namespace_rules,
            excluded_regions=excluded_regions,
            filter_tags=filter_tags,
            host_tags=host_tags,
            role_name=role_name,
            secret_access_key=secret_access_key,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(IntegrationAws, self, [scope, id, config])

    @jsii.member(jsii_name="resetAccessKeyId")
    def reset_access_key_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAccessKeyId", []))

    @jsii.member(jsii_name="resetAccountId")
    def reset_account_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAccountId", []))

    @jsii.member(jsii_name="resetAccountSpecificNamespaceRules")
    def reset_account_specific_namespace_rules(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAccountSpecificNamespaceRules", []))

    @jsii.member(jsii_name="resetExcludedRegions")
    def reset_excluded_regions(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExcludedRegions", []))

    @jsii.member(jsii_name="resetFilterTags")
    def reset_filter_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFilterTags", []))

    @jsii.member(jsii_name="resetHostTags")
    def reset_host_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostTags", []))

    @jsii.member(jsii_name="resetRoleName")
    def reset_role_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRoleName", []))

    @jsii.member(jsii_name="resetSecretAccessKey")
    def reset_secret_access_key(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecretAccessKey", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="externalId")
    def external_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "externalId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accessKeyIdInput")
    def access_key_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "accessKeyIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountIdInput")
    def account_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "accountIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountSpecificNamespaceRulesInput")
    def account_specific_namespace_rules_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.bool]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.bool]], jsii.get(self, "accountSpecificNamespaceRulesInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="excludedRegionsInput")
    def excluded_regions_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "excludedRegionsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filterTagsInput")
    def filter_tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "filterTagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hostTagsInput")
    def host_tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "hostTagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="roleNameInput")
    def role_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "roleNameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="secretAccessKeyInput")
    def secret_access_key_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "secretAccessKeyInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accessKeyId")
    def access_key_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "accessKeyId"))

    @access_key_id.setter
    def access_key_id(self, value: builtins.str) -> None:
        jsii.set(self, "accessKeyId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountId")
    def account_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "accountId"))

    @account_id.setter
    def account_id(self, value: builtins.str) -> None:
        jsii.set(self, "accountId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountSpecificNamespaceRules")
    def account_specific_namespace_rules(
        self,
    ) -> typing.Mapping[builtins.str, builtins.bool]:
        return typing.cast(typing.Mapping[builtins.str, builtins.bool], jsii.get(self, "accountSpecificNamespaceRules"))

    @account_specific_namespace_rules.setter
    def account_specific_namespace_rules(
        self,
        value: typing.Mapping[builtins.str, builtins.bool],
    ) -> None:
        jsii.set(self, "accountSpecificNamespaceRules", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="excludedRegions")
    def excluded_regions(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "excludedRegions"))

    @excluded_regions.setter
    def excluded_regions(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "excludedRegions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filterTags")
    def filter_tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "filterTags"))

    @filter_tags.setter
    def filter_tags(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "filterTags", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hostTags")
    def host_tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "hostTags"))

    @host_tags.setter
    def host_tags(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "hostTags", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="roleName")
    def role_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "roleName"))

    @role_name.setter
    def role_name(self, value: builtins.str) -> None:
        jsii.set(self, "roleName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="secretAccessKey")
    def secret_access_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "secretAccessKey"))

    @secret_access_key.setter
    def secret_access_key(self, value: builtins.str) -> None:
        jsii.set(self, "secretAccessKey", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.IntegrationAwsConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "access_key_id": "accessKeyId",
        "account_id": "accountId",
        "account_specific_namespace_rules": "accountSpecificNamespaceRules",
        "excluded_regions": "excludedRegions",
        "filter_tags": "filterTags",
        "host_tags": "hostTags",
        "role_name": "roleName",
        "secret_access_key": "secretAccessKey",
    },
)
class IntegrationAwsConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        access_key_id: typing.Optional[builtins.str] = None,
        account_id: typing.Optional[builtins.str] = None,
        account_specific_namespace_rules: typing.Optional[typing.Mapping[builtins.str, builtins.bool]] = None,
        excluded_regions: typing.Optional[typing.Sequence[builtins.str]] = None,
        filter_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        host_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        role_name: typing.Optional[builtins.str] = None,
        secret_access_key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param access_key_id: Your AWS access key ID. Only required if your AWS account is a GovCloud or China account. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#access_key_id IntegrationAws#access_key_id}
        :param account_id: Your AWS Account ID without dashes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#account_id IntegrationAws#account_id}
        :param account_specific_namespace_rules: Enables or disables metric collection for specific AWS namespaces for this AWS account only. A list of namespaces can be found at the `available namespace rules API endpoint <https://docs.datadoghq.com/api/v1/aws-integration/#list-namespace-rules>`_. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#account_specific_namespace_rules IntegrationAws#account_specific_namespace_rules}
        :param excluded_regions: An array of AWS regions to exclude from metrics collection. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#excluded_regions IntegrationAws#excluded_regions}
        :param filter_tags: Array of EC2 tags (in the form ``key:value``) defines a filter that Datadog uses when collecting metrics from EC2. Wildcards, such as ``?`` (for single characters) and ``*`` (for multiple characters) can also be used. Only hosts that match one of the defined tags will be imported into Datadog. The rest will be ignored. Host matching a given tag can also be excluded by adding ``!`` before the tag. e.x. ``env:production,instance-type:c1.*,!region:us-east-1``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#filter_tags IntegrationAws#filter_tags}
        :param host_tags: Array of tags (in the form ``key:value``) to add to all hosts and metrics reporting through this integration. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#host_tags IntegrationAws#host_tags}
        :param role_name: Your Datadog role delegation name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#role_name IntegrationAws#role_name}
        :param secret_access_key: Your AWS secret access key. Only required if your AWS account is a GovCloud or China account. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#secret_access_key IntegrationAws#secret_access_key}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if access_key_id is not None:
            self._values["access_key_id"] = access_key_id
        if account_id is not None:
            self._values["account_id"] = account_id
        if account_specific_namespace_rules is not None:
            self._values["account_specific_namespace_rules"] = account_specific_namespace_rules
        if excluded_regions is not None:
            self._values["excluded_regions"] = excluded_regions
        if filter_tags is not None:
            self._values["filter_tags"] = filter_tags
        if host_tags is not None:
            self._values["host_tags"] = host_tags
        if role_name is not None:
            self._values["role_name"] = role_name
        if secret_access_key is not None:
            self._values["secret_access_key"] = secret_access_key

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def access_key_id(self) -> typing.Optional[builtins.str]:
        '''Your AWS access key ID. Only required if your AWS account is a GovCloud or China account.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#access_key_id IntegrationAws#access_key_id}
        '''
        result = self._values.get("access_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def account_id(self) -> typing.Optional[builtins.str]:
        '''Your AWS Account ID without dashes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#account_id IntegrationAws#account_id}
        '''
        result = self._values.get("account_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def account_specific_namespace_rules(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.bool]]:
        '''Enables or disables metric collection for specific AWS namespaces for this AWS account only.

        A list of namespaces can be found at the `available namespace rules API endpoint <https://docs.datadoghq.com/api/v1/aws-integration/#list-namespace-rules>`_.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#account_specific_namespace_rules IntegrationAws#account_specific_namespace_rules}
        '''
        result = self._values.get("account_specific_namespace_rules")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.bool]], result)

    @builtins.property
    def excluded_regions(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of AWS regions to exclude from metrics collection.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#excluded_regions IntegrationAws#excluded_regions}
        '''
        result = self._values.get("excluded_regions")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def filter_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of EC2 tags (in the form ``key:value``) defines a filter that Datadog uses when collecting metrics from EC2.

        Wildcards, such as ``?`` (for single characters) and ``*`` (for multiple characters) can also be used. Only hosts that match one of the defined tags will be imported into Datadog. The rest will be ignored. Host matching a given tag can also be excluded by adding ``!`` before the tag. e.x. ``env:production,instance-type:c1.*,!region:us-east-1``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#filter_tags IntegrationAws#filter_tags}
        '''
        result = self._values.get("filter_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def host_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of tags (in the form ``key:value``) to add to all hosts and metrics reporting through this integration.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#host_tags IntegrationAws#host_tags}
        '''
        result = self._values.get("host_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def role_name(self) -> typing.Optional[builtins.str]:
        '''Your Datadog role delegation name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#role_name IntegrationAws#role_name}
        '''
        result = self._values.get("role_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_access_key(self) -> typing.Optional[builtins.str]:
        '''Your AWS secret access key. Only required if your AWS account is a GovCloud or China account.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws.html#secret_access_key IntegrationAws#secret_access_key}
        '''
        result = self._values.get("secret_access_key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IntegrationAwsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IntegrationAwsLambdaArn(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.IntegrationAwsLambdaArn",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_lambda_arn.html datadog_integration_aws_lambda_arn}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        account_id: builtins.str,
        lambda_arn: builtins.str,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_lambda_arn.html datadog_integration_aws_lambda_arn} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param account_id: Your AWS Account ID without dashes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_lambda_arn.html#account_id IntegrationAwsLambdaArn#account_id}
        :param lambda_arn: The ARN of the Datadog forwarder Lambda. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_lambda_arn.html#lambda_arn IntegrationAwsLambdaArn#lambda_arn}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = IntegrationAwsLambdaArnConfig(
            account_id=account_id,
            lambda_arn=lambda_arn,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(IntegrationAwsLambdaArn, self, [scope, id, config])

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountIdInput")
    def account_id_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "accountIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="lambdaArnInput")
    def lambda_arn_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "lambdaArnInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountId")
    def account_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "accountId"))

    @account_id.setter
    def account_id(self, value: builtins.str) -> None:
        jsii.set(self, "accountId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="lambdaArn")
    def lambda_arn(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "lambdaArn"))

    @lambda_arn.setter
    def lambda_arn(self, value: builtins.str) -> None:
        jsii.set(self, "lambdaArn", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.IntegrationAwsLambdaArnConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "account_id": "accountId",
        "lambda_arn": "lambdaArn",
    },
)
class IntegrationAwsLambdaArnConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        account_id: builtins.str,
        lambda_arn: builtins.str,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param account_id: Your AWS Account ID without dashes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_lambda_arn.html#account_id IntegrationAwsLambdaArn#account_id}
        :param lambda_arn: The ARN of the Datadog forwarder Lambda. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_lambda_arn.html#lambda_arn IntegrationAwsLambdaArn#lambda_arn}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "account_id": account_id,
            "lambda_arn": lambda_arn,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def account_id(self) -> builtins.str:
        '''Your AWS Account ID without dashes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_lambda_arn.html#account_id IntegrationAwsLambdaArn#account_id}
        '''
        result = self._values.get("account_id")
        assert result is not None, "Required property 'account_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def lambda_arn(self) -> builtins.str:
        '''The ARN of the Datadog forwarder Lambda.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_lambda_arn.html#lambda_arn IntegrationAwsLambdaArn#lambda_arn}
        '''
        result = self._values.get("lambda_arn")
        assert result is not None, "Required property 'lambda_arn' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IntegrationAwsLambdaArnConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IntegrationAwsLogCollection(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.IntegrationAwsLogCollection",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_log_collection.html datadog_integration_aws_log_collection}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        account_id: builtins.str,
        services: typing.Sequence[builtins.str],
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_log_collection.html datadog_integration_aws_log_collection} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param account_id: Your AWS Account ID without dashes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_log_collection.html#account_id IntegrationAwsLogCollection#account_id}
        :param services: A list of services to collect logs from. See the `api docs <https://docs.datadoghq.com/api/v1/aws-logs-integration/#get-list-of-aws-log-ready-services>`_ for more details on which services are supported. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_log_collection.html#services IntegrationAwsLogCollection#services}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = IntegrationAwsLogCollectionConfig(
            account_id=account_id,
            services=services,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(IntegrationAwsLogCollection, self, [scope, id, config])

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountIdInput")
    def account_id_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "accountIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="servicesInput")
    def services_input(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "servicesInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountId")
    def account_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "accountId"))

    @account_id.setter
    def account_id(self, value: builtins.str) -> None:
        jsii.set(self, "accountId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="services")
    def services(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "services"))

    @services.setter
    def services(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "services", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.IntegrationAwsLogCollectionConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "account_id": "accountId",
        "services": "services",
    },
)
class IntegrationAwsLogCollectionConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        account_id: builtins.str,
        services: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param account_id: Your AWS Account ID without dashes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_log_collection.html#account_id IntegrationAwsLogCollection#account_id}
        :param services: A list of services to collect logs from. See the `api docs <https://docs.datadoghq.com/api/v1/aws-logs-integration/#get-list-of-aws-log-ready-services>`_ for more details on which services are supported. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_log_collection.html#services IntegrationAwsLogCollection#services}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "account_id": account_id,
            "services": services,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def account_id(self) -> builtins.str:
        '''Your AWS Account ID without dashes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_log_collection.html#account_id IntegrationAwsLogCollection#account_id}
        '''
        result = self._values.get("account_id")
        assert result is not None, "Required property 'account_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def services(self) -> typing.List[builtins.str]:
        '''A list of services to collect logs from.

        See the `api docs <https://docs.datadoghq.com/api/v1/aws-logs-integration/#get-list-of-aws-log-ready-services>`_ for more details on which services are supported.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_log_collection.html#services IntegrationAwsLogCollection#services}
        '''
        result = self._values.get("services")
        assert result is not None, "Required property 'services' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IntegrationAwsLogCollectionConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IntegrationAwsTagFilter(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.IntegrationAwsTagFilter",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_tag_filter.html datadog_integration_aws_tag_filter}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        account_id: builtins.str,
        namespace: builtins.str,
        tag_filter_str: builtins.str,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_tag_filter.html datadog_integration_aws_tag_filter} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param account_id: Your AWS Account ID without dashes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_tag_filter.html#account_id IntegrationAwsTagFilter#account_id}
        :param namespace: The namespace associated with the tag filter entry. Valid values are ``elb``, ``application_elb``, ``sqs``, ``rds``, ``custom``, ``network_elb``, ``lambda``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_tag_filter.html#namespace IntegrationAwsTagFilter#namespace}
        :param tag_filter_str: The tag filter string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_tag_filter.html#tag_filter_str IntegrationAwsTagFilter#tag_filter_str}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = IntegrationAwsTagFilterConfig(
            account_id=account_id,
            namespace=namespace,
            tag_filter_str=tag_filter_str,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(IntegrationAwsTagFilter, self, [scope, id, config])

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountIdInput")
    def account_id_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "accountIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="namespaceInput")
    def namespace_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "namespaceInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagFilterStrInput")
    def tag_filter_str_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tagFilterStrInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountId")
    def account_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "accountId"))

    @account_id.setter
    def account_id(self, value: builtins.str) -> None:
        jsii.set(self, "accountId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="namespace")
    def namespace(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "namespace"))

    @namespace.setter
    def namespace(self, value: builtins.str) -> None:
        jsii.set(self, "namespace", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagFilterStr")
    def tag_filter_str(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tagFilterStr"))

    @tag_filter_str.setter
    def tag_filter_str(self, value: builtins.str) -> None:
        jsii.set(self, "tagFilterStr", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.IntegrationAwsTagFilterConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "account_id": "accountId",
        "namespace": "namespace",
        "tag_filter_str": "tagFilterStr",
    },
)
class IntegrationAwsTagFilterConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        account_id: builtins.str,
        namespace: builtins.str,
        tag_filter_str: builtins.str,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param account_id: Your AWS Account ID without dashes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_tag_filter.html#account_id IntegrationAwsTagFilter#account_id}
        :param namespace: The namespace associated with the tag filter entry. Valid values are ``elb``, ``application_elb``, ``sqs``, ``rds``, ``custom``, ``network_elb``, ``lambda``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_tag_filter.html#namespace IntegrationAwsTagFilter#namespace}
        :param tag_filter_str: The tag filter string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_tag_filter.html#tag_filter_str IntegrationAwsTagFilter#tag_filter_str}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "account_id": account_id,
            "namespace": namespace,
            "tag_filter_str": tag_filter_str,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def account_id(self) -> builtins.str:
        '''Your AWS Account ID without dashes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_tag_filter.html#account_id IntegrationAwsTagFilter#account_id}
        '''
        result = self._values.get("account_id")
        assert result is not None, "Required property 'account_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def namespace(self) -> builtins.str:
        '''The namespace associated with the tag filter entry. Valid values are ``elb``, ``application_elb``, ``sqs``, ``rds``, ``custom``, ``network_elb``, ``lambda``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_tag_filter.html#namespace IntegrationAwsTagFilter#namespace}
        '''
        result = self._values.get("namespace")
        assert result is not None, "Required property 'namespace' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tag_filter_str(self) -> builtins.str:
        '''The tag filter string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_aws_tag_filter.html#tag_filter_str IntegrationAwsTagFilter#tag_filter_str}
        '''
        result = self._values.get("tag_filter_str")
        assert result is not None, "Required property 'tag_filter_str' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IntegrationAwsTagFilterConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IntegrationAzure(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.IntegrationAzure",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html datadog_integration_azure}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        client_id: builtins.str,
        client_secret: builtins.str,
        tenant_name: builtins.str,
        host_filters: typing.Optional[builtins.str] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html datadog_integration_azure} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param client_id: Your Azure web application ID. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#client_id IntegrationAzure#client_id}
        :param client_secret: (Required for Initial Creation) Your Azure web application secret key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#client_secret IntegrationAzure#client_secret}
        :param tenant_name: Your Azure Active Directory ID. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#tenant_name IntegrationAzure#tenant_name}
        :param host_filters: String of host tag(s) (in the form ``key:value,key:value``) defines a filter that Datadog will use when collecting metrics from Azure. Limit the Azure instances that are pulled into Datadog by using tags. Only hosts that match one of the defined tags are imported into Datadog. e.x. ``env:production,deploymentgroup:red`` Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#host_filters IntegrationAzure#host_filters}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = IntegrationAzureConfig(
            client_id=client_id,
            client_secret=client_secret,
            tenant_name=tenant_name,
            host_filters=host_filters,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(IntegrationAzure, self, [scope, id, config])

    @jsii.member(jsii_name="resetHostFilters")
    def reset_host_filters(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostFilters", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientIdInput")
    def client_id_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clientIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientSecretInput")
    def client_secret_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clientSecretInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tenantNameInput")
    def tenant_name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tenantNameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hostFiltersInput")
    def host_filters_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostFiltersInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientId")
    def client_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clientId"))

    @client_id.setter
    def client_id(self, value: builtins.str) -> None:
        jsii.set(self, "clientId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientSecret")
    def client_secret(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clientSecret"))

    @client_secret.setter
    def client_secret(self, value: builtins.str) -> None:
        jsii.set(self, "clientSecret", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hostFilters")
    def host_filters(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "hostFilters"))

    @host_filters.setter
    def host_filters(self, value: builtins.str) -> None:
        jsii.set(self, "hostFilters", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tenantName")
    def tenant_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tenantName"))

    @tenant_name.setter
    def tenant_name(self, value: builtins.str) -> None:
        jsii.set(self, "tenantName", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.IntegrationAzureConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "client_id": "clientId",
        "client_secret": "clientSecret",
        "tenant_name": "tenantName",
        "host_filters": "hostFilters",
    },
)
class IntegrationAzureConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        client_id: builtins.str,
        client_secret: builtins.str,
        tenant_name: builtins.str,
        host_filters: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param client_id: Your Azure web application ID. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#client_id IntegrationAzure#client_id}
        :param client_secret: (Required for Initial Creation) Your Azure web application secret key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#client_secret IntegrationAzure#client_secret}
        :param tenant_name: Your Azure Active Directory ID. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#tenant_name IntegrationAzure#tenant_name}
        :param host_filters: String of host tag(s) (in the form ``key:value,key:value``) defines a filter that Datadog will use when collecting metrics from Azure. Limit the Azure instances that are pulled into Datadog by using tags. Only hosts that match one of the defined tags are imported into Datadog. e.x. ``env:production,deploymentgroup:red`` Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#host_filters IntegrationAzure#host_filters}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "client_id": client_id,
            "client_secret": client_secret,
            "tenant_name": tenant_name,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if host_filters is not None:
            self._values["host_filters"] = host_filters

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def client_id(self) -> builtins.str:
        '''Your Azure web application ID.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#client_id IntegrationAzure#client_id}
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_secret(self) -> builtins.str:
        '''(Required for Initial Creation) Your Azure web application secret key.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#client_secret IntegrationAzure#client_secret}
        '''
        result = self._values.get("client_secret")
        assert result is not None, "Required property 'client_secret' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tenant_name(self) -> builtins.str:
        '''Your Azure Active Directory ID.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#tenant_name IntegrationAzure#tenant_name}
        '''
        result = self._values.get("tenant_name")
        assert result is not None, "Required property 'tenant_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def host_filters(self) -> typing.Optional[builtins.str]:
        '''String of host tag(s) (in the form ``key:value,key:value``) defines a filter that Datadog will use when collecting metrics from Azure.

        Limit the Azure instances that are pulled into Datadog by using tags. Only hosts that match one of the defined tags are imported into Datadog. e.x. ``env:production,deploymentgroup:red``

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_azure.html#host_filters IntegrationAzure#host_filters}
        '''
        result = self._values.get("host_filters")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IntegrationAzureConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IntegrationGcp(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.IntegrationGcp",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html datadog_integration_gcp}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        client_email: builtins.str,
        client_id: builtins.str,
        private_key: builtins.str,
        private_key_id: builtins.str,
        project_id: builtins.str,
        automute: typing.Optional[builtins.bool] = None,
        host_filters: typing.Optional[builtins.str] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html datadog_integration_gcp} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param client_email: Your email found in your JSON service account key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#client_email IntegrationGcp#client_email}
        :param client_id: Your ID found in your JSON service account key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#client_id IntegrationGcp#client_id}
        :param private_key: Your private key name found in your JSON service account key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#private_key IntegrationGcp#private_key}
        :param private_key_id: Your private key ID found in your JSON service account key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#private_key_id IntegrationGcp#private_key_id}
        :param project_id: Your Google Cloud project ID found in your JSON service account key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#project_id IntegrationGcp#project_id}
        :param automute: Silence monitors for expected GCE instance shutdowns. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#automute IntegrationGcp#automute}
        :param host_filters: Limit the GCE instances that are pulled into Datadog by using tags. Only hosts that match one of the defined tags are imported into Datadog. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#host_filters IntegrationGcp#host_filters}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = IntegrationGcpConfig(
            client_email=client_email,
            client_id=client_id,
            private_key=private_key,
            private_key_id=private_key_id,
            project_id=project_id,
            automute=automute,
            host_filters=host_filters,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(IntegrationGcp, self, [scope, id, config])

    @jsii.member(jsii_name="resetAutomute")
    def reset_automute(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAutomute", []))

    @jsii.member(jsii_name="resetHostFilters")
    def reset_host_filters(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHostFilters", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientEmailInput")
    def client_email_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clientEmailInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientIdInput")
    def client_id_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clientIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateKeyIdInput")
    def private_key_id_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "privateKeyIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateKeyInput")
    def private_key_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "privateKeyInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="projectIdInput")
    def project_id_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "projectIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="automuteInput")
    def automute_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "automuteInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hostFiltersInput")
    def host_filters_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostFiltersInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="automute")
    def automute(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "automute"))

    @automute.setter
    def automute(self, value: builtins.bool) -> None:
        jsii.set(self, "automute", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientEmail")
    def client_email(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clientEmail"))

    @client_email.setter
    def client_email(self, value: builtins.str) -> None:
        jsii.set(self, "clientEmail", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientId")
    def client_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "clientId"))

    @client_id.setter
    def client_id(self, value: builtins.str) -> None:
        jsii.set(self, "clientId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hostFilters")
    def host_filters(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "hostFilters"))

    @host_filters.setter
    def host_filters(self, value: builtins.str) -> None:
        jsii.set(self, "hostFilters", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateKey")
    def private_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "privateKey"))

    @private_key.setter
    def private_key(self, value: builtins.str) -> None:
        jsii.set(self, "privateKey", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateKeyId")
    def private_key_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "privateKeyId"))

    @private_key_id.setter
    def private_key_id(self, value: builtins.str) -> None:
        jsii.set(self, "privateKeyId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="projectId")
    def project_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "projectId"))

    @project_id.setter
    def project_id(self, value: builtins.str) -> None:
        jsii.set(self, "projectId", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.IntegrationGcpConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "client_email": "clientEmail",
        "client_id": "clientId",
        "private_key": "privateKey",
        "private_key_id": "privateKeyId",
        "project_id": "projectId",
        "automute": "automute",
        "host_filters": "hostFilters",
    },
)
class IntegrationGcpConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        client_email: builtins.str,
        client_id: builtins.str,
        private_key: builtins.str,
        private_key_id: builtins.str,
        project_id: builtins.str,
        automute: typing.Optional[builtins.bool] = None,
        host_filters: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param client_email: Your email found in your JSON service account key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#client_email IntegrationGcp#client_email}
        :param client_id: Your ID found in your JSON service account key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#client_id IntegrationGcp#client_id}
        :param private_key: Your private key name found in your JSON service account key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#private_key IntegrationGcp#private_key}
        :param private_key_id: Your private key ID found in your JSON service account key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#private_key_id IntegrationGcp#private_key_id}
        :param project_id: Your Google Cloud project ID found in your JSON service account key. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#project_id IntegrationGcp#project_id}
        :param automute: Silence monitors for expected GCE instance shutdowns. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#automute IntegrationGcp#automute}
        :param host_filters: Limit the GCE instances that are pulled into Datadog by using tags. Only hosts that match one of the defined tags are imported into Datadog. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#host_filters IntegrationGcp#host_filters}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "client_email": client_email,
            "client_id": client_id,
            "private_key": private_key,
            "private_key_id": private_key_id,
            "project_id": project_id,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if automute is not None:
            self._values["automute"] = automute
        if host_filters is not None:
            self._values["host_filters"] = host_filters

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def client_email(self) -> builtins.str:
        '''Your email found in your JSON service account key.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#client_email IntegrationGcp#client_email}
        '''
        result = self._values.get("client_email")
        assert result is not None, "Required property 'client_email' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_id(self) -> builtins.str:
        '''Your ID found in your JSON service account key.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#client_id IntegrationGcp#client_id}
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def private_key(self) -> builtins.str:
        '''Your private key name found in your JSON service account key.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#private_key IntegrationGcp#private_key}
        '''
        result = self._values.get("private_key")
        assert result is not None, "Required property 'private_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def private_key_id(self) -> builtins.str:
        '''Your private key ID found in your JSON service account key.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#private_key_id IntegrationGcp#private_key_id}
        '''
        result = self._values.get("private_key_id")
        assert result is not None, "Required property 'private_key_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def project_id(self) -> builtins.str:
        '''Your Google Cloud project ID found in your JSON service account key.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#project_id IntegrationGcp#project_id}
        '''
        result = self._values.get("project_id")
        assert result is not None, "Required property 'project_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def automute(self) -> typing.Optional[builtins.bool]:
        '''Silence monitors for expected GCE instance shutdowns.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#automute IntegrationGcp#automute}
        '''
        result = self._values.get("automute")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def host_filters(self) -> typing.Optional[builtins.str]:
        '''Limit the GCE instances that are pulled into Datadog by using tags.

        Only hosts that match one of the defined tags are imported into Datadog.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_gcp.html#host_filters IntegrationGcp#host_filters}
        '''
        result = self._values.get("host_filters")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IntegrationGcpConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IntegrationPagerduty(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.IntegrationPagerduty",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty.html datadog_integration_pagerduty}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        subdomain: builtins.str,
        api_token: typing.Optional[builtins.str] = None,
        schedules: typing.Optional[typing.Sequence[builtins.str]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty.html datadog_integration_pagerduty} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param subdomain: Your PagerDuty accounts personalized subdomain name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty.html#subdomain IntegrationPagerduty#subdomain}
        :param api_token: Your PagerDuty API token. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty.html#api_token IntegrationPagerduty#api_token}
        :param schedules: Array of your schedule URLs. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty.html#schedules IntegrationPagerduty#schedules}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = IntegrationPagerdutyConfig(
            subdomain=subdomain,
            api_token=api_token,
            schedules=schedules,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(IntegrationPagerduty, self, [scope, id, config])

    @jsii.member(jsii_name="resetApiToken")
    def reset_api_token(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetApiToken", []))

    @jsii.member(jsii_name="resetSchedules")
    def reset_schedules(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSchedules", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subdomainInput")
    def subdomain_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subdomainInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apiTokenInput")
    def api_token_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "apiTokenInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="schedulesInput")
    def schedules_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "schedulesInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apiToken")
    def api_token(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "apiToken"))

    @api_token.setter
    def api_token(self, value: builtins.str) -> None:
        jsii.set(self, "apiToken", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="schedules")
    def schedules(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "schedules"))

    @schedules.setter
    def schedules(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "schedules", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subdomain")
    def subdomain(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subdomain"))

    @subdomain.setter
    def subdomain(self, value: builtins.str) -> None:
        jsii.set(self, "subdomain", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.IntegrationPagerdutyConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "subdomain": "subdomain",
        "api_token": "apiToken",
        "schedules": "schedules",
    },
)
class IntegrationPagerdutyConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        subdomain: builtins.str,
        api_token: typing.Optional[builtins.str] = None,
        schedules: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param subdomain: Your PagerDuty accounts personalized subdomain name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty.html#subdomain IntegrationPagerduty#subdomain}
        :param api_token: Your PagerDuty API token. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty.html#api_token IntegrationPagerduty#api_token}
        :param schedules: Array of your schedule URLs. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty.html#schedules IntegrationPagerduty#schedules}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "subdomain": subdomain,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if api_token is not None:
            self._values["api_token"] = api_token
        if schedules is not None:
            self._values["schedules"] = schedules

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def subdomain(self) -> builtins.str:
        '''Your PagerDuty accounts personalized subdomain name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty.html#subdomain IntegrationPagerduty#subdomain}
        '''
        result = self._values.get("subdomain")
        assert result is not None, "Required property 'subdomain' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_token(self) -> typing.Optional[builtins.str]:
        '''Your PagerDuty API token.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty.html#api_token IntegrationPagerduty#api_token}
        '''
        result = self._values.get("api_token")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def schedules(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of your schedule URLs.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty.html#schedules IntegrationPagerduty#schedules}
        '''
        result = self._values.get("schedules")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IntegrationPagerdutyConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IntegrationPagerdutyServiceObject(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.IntegrationPagerdutyServiceObject",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty_service_object.html datadog_integration_pagerduty_service_object}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        service_key: builtins.str,
        service_name: builtins.str,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty_service_object.html datadog_integration_pagerduty_service_object} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param service_key: Your Service name associated service key in PagerDuty. Note: Since the Datadog API never returns service keys, it is impossible to detect `drifts <https://www.hashicorp.com/blog/detecting-and-managing-drift-with-terraform>`_. The best way to solve a drift is to manually mark the Service Object resource with `terraform taint <https://www.terraform.io/docs/commands/taint.html>`_ to have it destroyed and recreated. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty_service_object.html#service_key IntegrationPagerdutyServiceObject#service_key}
        :param service_name: Your Service name in PagerDuty. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty_service_object.html#service_name IntegrationPagerdutyServiceObject#service_name}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = IntegrationPagerdutyServiceObjectConfig(
            service_key=service_key,
            service_name=service_name,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(IntegrationPagerdutyServiceObject, self, [scope, id, config])

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="serviceKeyInput")
    def service_key_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "serviceKeyInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="serviceNameInput")
    def service_name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "serviceNameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="serviceKey")
    def service_key(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "serviceKey"))

    @service_key.setter
    def service_key(self, value: builtins.str) -> None:
        jsii.set(self, "serviceKey", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="serviceName")
    def service_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "serviceName"))

    @service_name.setter
    def service_name(self, value: builtins.str) -> None:
        jsii.set(self, "serviceName", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.IntegrationPagerdutyServiceObjectConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "service_key": "serviceKey",
        "service_name": "serviceName",
    },
)
class IntegrationPagerdutyServiceObjectConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        service_key: builtins.str,
        service_name: builtins.str,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param service_key: Your Service name associated service key in PagerDuty. Note: Since the Datadog API never returns service keys, it is impossible to detect `drifts <https://www.hashicorp.com/blog/detecting-and-managing-drift-with-terraform>`_. The best way to solve a drift is to manually mark the Service Object resource with `terraform taint <https://www.terraform.io/docs/commands/taint.html>`_ to have it destroyed and recreated. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty_service_object.html#service_key IntegrationPagerdutyServiceObject#service_key}
        :param service_name: Your Service name in PagerDuty. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty_service_object.html#service_name IntegrationPagerdutyServiceObject#service_name}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "service_key": service_key,
            "service_name": service_name,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def service_key(self) -> builtins.str:
        '''Your Service name associated service key in PagerDuty.

        Note: Since the Datadog API never returns service keys, it is impossible to detect `drifts <https://www.hashicorp.com/blog/detecting-and-managing-drift-with-terraform>`_. The best way to solve a drift is to manually mark the Service Object resource with `terraform taint <https://www.terraform.io/docs/commands/taint.html>`_ to have it destroyed and recreated.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty_service_object.html#service_key IntegrationPagerdutyServiceObject#service_key}
        '''
        result = self._values.get("service_key")
        assert result is not None, "Required property 'service_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_name(self) -> builtins.str:
        '''Your Service name in PagerDuty.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_pagerduty_service_object.html#service_name IntegrationPagerdutyServiceObject#service_name}
        '''
        result = self._values.get("service_name")
        assert result is not None, "Required property 'service_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IntegrationPagerdutyServiceObjectConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IntegrationSlackChannel(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.IntegrationSlackChannel",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html datadog_integration_slack_channel}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        account_name: builtins.str,
        channel_name: builtins.str,
        display: typing.Sequence["IntegrationSlackChannelDisplay"],
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html datadog_integration_slack_channel} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param account_name: Slack account name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#account_name IntegrationSlackChannel#account_name}
        :param channel_name: Slack channel name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#channel_name IntegrationSlackChannel#channel_name}
        :param display: display block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#display IntegrationSlackChannel#display}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = IntegrationSlackChannelConfig(
            account_name=account_name,
            channel_name=channel_name,
            display=display,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(IntegrationSlackChannel, self, [scope, id, config])

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountNameInput")
    def account_name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "accountNameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="channelNameInput")
    def channel_name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "channelNameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="displayInput")
    def display_input(self) -> typing.List["IntegrationSlackChannelDisplay"]:
        return typing.cast(typing.List["IntegrationSlackChannelDisplay"], jsii.get(self, "displayInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accountName")
    def account_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "accountName"))

    @account_name.setter
    def account_name(self, value: builtins.str) -> None:
        jsii.set(self, "accountName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="channelName")
    def channel_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "channelName"))

    @channel_name.setter
    def channel_name(self, value: builtins.str) -> None:
        jsii.set(self, "channelName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="display")
    def display(self) -> typing.List["IntegrationSlackChannelDisplay"]:
        return typing.cast(typing.List["IntegrationSlackChannelDisplay"], jsii.get(self, "display"))

    @display.setter
    def display(self, value: typing.List["IntegrationSlackChannelDisplay"]) -> None:
        jsii.set(self, "display", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.IntegrationSlackChannelConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "account_name": "accountName",
        "channel_name": "channelName",
        "display": "display",
    },
)
class IntegrationSlackChannelConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        account_name: builtins.str,
        channel_name: builtins.str,
        display: typing.Sequence["IntegrationSlackChannelDisplay"],
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param account_name: Slack account name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#account_name IntegrationSlackChannel#account_name}
        :param channel_name: Slack channel name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#channel_name IntegrationSlackChannel#channel_name}
        :param display: display block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#display IntegrationSlackChannel#display}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "account_name": account_name,
            "channel_name": channel_name,
            "display": display,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def account_name(self) -> builtins.str:
        '''Slack account name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#account_name IntegrationSlackChannel#account_name}
        '''
        result = self._values.get("account_name")
        assert result is not None, "Required property 'account_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def channel_name(self) -> builtins.str:
        '''Slack channel name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#channel_name IntegrationSlackChannel#channel_name}
        '''
        result = self._values.get("channel_name")
        assert result is not None, "Required property 'channel_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def display(self) -> typing.List["IntegrationSlackChannelDisplay"]:
        '''display block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#display IntegrationSlackChannel#display}
        '''
        result = self._values.get("display")
        assert result is not None, "Required property 'display' is missing"
        return typing.cast(typing.List["IntegrationSlackChannelDisplay"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IntegrationSlackChannelConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.IntegrationSlackChannelDisplay",
    jsii_struct_bases=[],
    name_mapping={
        "message": "message",
        "notified": "notified",
        "snapshot": "snapshot",
        "tags": "tags",
    },
)
class IntegrationSlackChannelDisplay:
    def __init__(
        self,
        *,
        message: typing.Optional[builtins.bool] = None,
        notified: typing.Optional[builtins.bool] = None,
        snapshot: typing.Optional[builtins.bool] = None,
        tags: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param message: Show the main body of the alert event. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#message IntegrationSlackChannel#message}
        :param notified: Show the list of @-handles in the alert event. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#notified IntegrationSlackChannel#notified}
        :param snapshot: Show the alert event's snapshot image. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#snapshot IntegrationSlackChannel#snapshot}
        :param tags: Show the scopes on which the monitor alerted. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#tags IntegrationSlackChannel#tags}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if message is not None:
            self._values["message"] = message
        if notified is not None:
            self._values["notified"] = notified
        if snapshot is not None:
            self._values["snapshot"] = snapshot
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def message(self) -> typing.Optional[builtins.bool]:
        '''Show the main body of the alert event.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#message IntegrationSlackChannel#message}
        '''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def notified(self) -> typing.Optional[builtins.bool]:
        '''Show the list of @-handles in the alert event.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#notified IntegrationSlackChannel#notified}
        '''
        result = self._values.get("notified")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def snapshot(self) -> typing.Optional[builtins.bool]:
        '''Show the alert event's snapshot image.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#snapshot IntegrationSlackChannel#snapshot}
        '''
        result = self._values.get("snapshot")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def tags(self) -> typing.Optional[builtins.bool]:
        '''Show the scopes on which the monitor alerted.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/integration_slack_channel.html#tags IntegrationSlackChannel#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IntegrationSlackChannelDisplay(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LogsArchive(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.LogsArchive",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html datadog_logs_archive}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        name: builtins.str,
        query: builtins.str,
        azure_archive: typing.Optional[typing.Sequence["LogsArchiveAzureArchive"]] = None,
        gcs_archive: typing.Optional[typing.Sequence["LogsArchiveGcsArchive"]] = None,
        include_tags: typing.Optional[builtins.bool] = None,
        rehydration_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        s3_archive: typing.Optional[typing.Sequence["LogsArchiveS3Archive"]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html datadog_logs_archive} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param name: Your archive name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#name LogsArchive#name}
        :param query: The archive query/filter. Logs matching this query are included in the archive. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#query LogsArchive#query}
        :param azure_archive: azure_archive block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#azure_archive LogsArchive#azure_archive}
        :param gcs_archive: gcs_archive block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#gcs_archive LogsArchive#gcs_archive}
        :param include_tags: To store the tags in the archive, set the value ``true``. If it is set to ``false``, the tags will be dropped when the logs are sent to the archive. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#include_tags LogsArchive#include_tags}
        :param rehydration_tags: An array of tags to add to rehydrated logs from an archive. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#rehydration_tags LogsArchive#rehydration_tags}
        :param s3_archive: s3_archive block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#s3_archive LogsArchive#s3_archive}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = LogsArchiveConfig(
            name=name,
            query=query,
            azure_archive=azure_archive,
            gcs_archive=gcs_archive,
            include_tags=include_tags,
            rehydration_tags=rehydration_tags,
            s3_archive=s3_archive,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(LogsArchive, self, [scope, id, config])

    @jsii.member(jsii_name="resetAzureArchive")
    def reset_azure_archive(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAzureArchive", []))

    @jsii.member(jsii_name="resetGcsArchive")
    def reset_gcs_archive(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGcsArchive", []))

    @jsii.member(jsii_name="resetIncludeTags")
    def reset_include_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIncludeTags", []))

    @jsii.member(jsii_name="resetRehydrationTags")
    def reset_rehydration_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRehydrationTags", []))

    @jsii.member(jsii_name="resetS3Archive")
    def reset_s3_archive(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetS3Archive", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="queryInput")
    def query_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "queryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="azureArchiveInput")
    def azure_archive_input(
        self,
    ) -> typing.Optional[typing.List["LogsArchiveAzureArchive"]]:
        return typing.cast(typing.Optional[typing.List["LogsArchiveAzureArchive"]], jsii.get(self, "azureArchiveInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="gcsArchiveInput")
    def gcs_archive_input(
        self,
    ) -> typing.Optional[typing.List["LogsArchiveGcsArchive"]]:
        return typing.cast(typing.Optional[typing.List["LogsArchiveGcsArchive"]], jsii.get(self, "gcsArchiveInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="includeTagsInput")
    def include_tags_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "includeTagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="rehydrationTagsInput")
    def rehydration_tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "rehydrationTagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="s3ArchiveInput")
    def s3_archive_input(self) -> typing.Optional[typing.List["LogsArchiveS3Archive"]]:
        return typing.cast(typing.Optional[typing.List["LogsArchiveS3Archive"]], jsii.get(self, "s3ArchiveInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="azureArchive")
    def azure_archive(self) -> typing.List["LogsArchiveAzureArchive"]:
        return typing.cast(typing.List["LogsArchiveAzureArchive"], jsii.get(self, "azureArchive"))

    @azure_archive.setter
    def azure_archive(self, value: typing.List["LogsArchiveAzureArchive"]) -> None:
        jsii.set(self, "azureArchive", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="gcsArchive")
    def gcs_archive(self) -> typing.List["LogsArchiveGcsArchive"]:
        return typing.cast(typing.List["LogsArchiveGcsArchive"], jsii.get(self, "gcsArchive"))

    @gcs_archive.setter
    def gcs_archive(self, value: typing.List["LogsArchiveGcsArchive"]) -> None:
        jsii.set(self, "gcsArchive", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="includeTags")
    def include_tags(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "includeTags"))

    @include_tags.setter
    def include_tags(self, value: builtins.bool) -> None:
        jsii.set(self, "includeTags", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="query")
    def query(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "query"))

    @query.setter
    def query(self, value: builtins.str) -> None:
        jsii.set(self, "query", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="rehydrationTags")
    def rehydration_tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "rehydrationTags"))

    @rehydration_tags.setter
    def rehydration_tags(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "rehydrationTags", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="s3Archive")
    def s3_archive(self) -> typing.List["LogsArchiveS3Archive"]:
        return typing.cast(typing.List["LogsArchiveS3Archive"], jsii.get(self, "s3Archive"))

    @s3_archive.setter
    def s3_archive(self, value: typing.List["LogsArchiveS3Archive"]) -> None:
        jsii.set(self, "s3Archive", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsArchiveAzureArchive",
    jsii_struct_bases=[],
    name_mapping={
        "client_id": "clientId",
        "container": "container",
        "storage_account": "storageAccount",
        "tenant_id": "tenantId",
        "path": "path",
    },
)
class LogsArchiveAzureArchive:
    def __init__(
        self,
        *,
        client_id: builtins.str,
        container: builtins.str,
        storage_account: builtins.str,
        tenant_id: builtins.str,
        path: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param client_id: Your client id. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#client_id LogsArchive#client_id}
        :param container: The container where the archive will be stored. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#container LogsArchive#container}
        :param storage_account: The associated storage account. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#storage_account LogsArchive#storage_account}
        :param tenant_id: Your tenant id. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#tenant_id LogsArchive#tenant_id}
        :param path: The path where the archive will be stored. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#path LogsArchive#path}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "client_id": client_id,
            "container": container,
            "storage_account": storage_account,
            "tenant_id": tenant_id,
        }
        if path is not None:
            self._values["path"] = path

    @builtins.property
    def client_id(self) -> builtins.str:
        '''Your client id.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#client_id LogsArchive#client_id}
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def container(self) -> builtins.str:
        '''The container where the archive will be stored.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#container LogsArchive#container}
        '''
        result = self._values.get("container")
        assert result is not None, "Required property 'container' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def storage_account(self) -> builtins.str:
        '''The associated storage account.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#storage_account LogsArchive#storage_account}
        '''
        result = self._values.get("storage_account")
        assert result is not None, "Required property 'storage_account' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tenant_id(self) -> builtins.str:
        '''Your tenant id.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#tenant_id LogsArchive#tenant_id}
        '''
        result = self._values.get("tenant_id")
        assert result is not None, "Required property 'tenant_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''The path where the archive will be stored.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#path LogsArchive#path}
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsArchiveAzureArchive(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsArchiveConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "name": "name",
        "query": "query",
        "azure_archive": "azureArchive",
        "gcs_archive": "gcsArchive",
        "include_tags": "includeTags",
        "rehydration_tags": "rehydrationTags",
        "s3_archive": "s3Archive",
    },
)
class LogsArchiveConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        name: builtins.str,
        query: builtins.str,
        azure_archive: typing.Optional[typing.Sequence[LogsArchiveAzureArchive]] = None,
        gcs_archive: typing.Optional[typing.Sequence["LogsArchiveGcsArchive"]] = None,
        include_tags: typing.Optional[builtins.bool] = None,
        rehydration_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        s3_archive: typing.Optional[typing.Sequence["LogsArchiveS3Archive"]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param name: Your archive name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#name LogsArchive#name}
        :param query: The archive query/filter. Logs matching this query are included in the archive. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#query LogsArchive#query}
        :param azure_archive: azure_archive block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#azure_archive LogsArchive#azure_archive}
        :param gcs_archive: gcs_archive block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#gcs_archive LogsArchive#gcs_archive}
        :param include_tags: To store the tags in the archive, set the value ``true``. If it is set to ``false``, the tags will be dropped when the logs are sent to the archive. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#include_tags LogsArchive#include_tags}
        :param rehydration_tags: An array of tags to add to rehydrated logs from an archive. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#rehydration_tags LogsArchive#rehydration_tags}
        :param s3_archive: s3_archive block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#s3_archive LogsArchive#s3_archive}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "query": query,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if azure_archive is not None:
            self._values["azure_archive"] = azure_archive
        if gcs_archive is not None:
            self._values["gcs_archive"] = gcs_archive
        if include_tags is not None:
            self._values["include_tags"] = include_tags
        if rehydration_tags is not None:
            self._values["rehydration_tags"] = rehydration_tags
        if s3_archive is not None:
            self._values["s3_archive"] = s3_archive

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Your archive name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#name LogsArchive#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''The archive query/filter. Logs matching this query are included in the archive.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#query LogsArchive#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def azure_archive(self) -> typing.Optional[typing.List[LogsArchiveAzureArchive]]:
        '''azure_archive block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#azure_archive LogsArchive#azure_archive}
        '''
        result = self._values.get("azure_archive")
        return typing.cast(typing.Optional[typing.List[LogsArchiveAzureArchive]], result)

    @builtins.property
    def gcs_archive(self) -> typing.Optional[typing.List["LogsArchiveGcsArchive"]]:
        '''gcs_archive block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#gcs_archive LogsArchive#gcs_archive}
        '''
        result = self._values.get("gcs_archive")
        return typing.cast(typing.Optional[typing.List["LogsArchiveGcsArchive"]], result)

    @builtins.property
    def include_tags(self) -> typing.Optional[builtins.bool]:
        '''To store the tags in the archive, set the value ``true``.

        If it is set to ``false``, the tags will be dropped when the logs are sent to the archive.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#include_tags LogsArchive#include_tags}
        '''
        result = self._values.get("include_tags")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rehydration_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of tags to add to rehydrated logs from an archive.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#rehydration_tags LogsArchive#rehydration_tags}
        '''
        result = self._values.get("rehydration_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def s3_archive(self) -> typing.Optional[typing.List["LogsArchiveS3Archive"]]:
        '''s3_archive block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#s3_archive LogsArchive#s3_archive}
        '''
        result = self._values.get("s3_archive")
        return typing.cast(typing.Optional[typing.List["LogsArchiveS3Archive"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsArchiveConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsArchiveGcsArchive",
    jsii_struct_bases=[],
    name_mapping={
        "bucket": "bucket",
        "client_email": "clientEmail",
        "path": "path",
        "project_id": "projectId",
    },
)
class LogsArchiveGcsArchive:
    def __init__(
        self,
        *,
        bucket: builtins.str,
        client_email: builtins.str,
        path: builtins.str,
        project_id: builtins.str,
    ) -> None:
        '''
        :param bucket: Name of your GCS bucket. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#bucket LogsArchive#bucket}
        :param client_email: Your client email. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#client_email LogsArchive#client_email}
        :param path: Path where the archive will be stored. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#path LogsArchive#path}
        :param project_id: Your project id. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#project_id LogsArchive#project_id}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "bucket": bucket,
            "client_email": client_email,
            "path": path,
            "project_id": project_id,
        }

    @builtins.property
    def bucket(self) -> builtins.str:
        '''Name of your GCS bucket.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#bucket LogsArchive#bucket}
        '''
        result = self._values.get("bucket")
        assert result is not None, "Required property 'bucket' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_email(self) -> builtins.str:
        '''Your client email.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#client_email LogsArchive#client_email}
        '''
        result = self._values.get("client_email")
        assert result is not None, "Required property 'client_email' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the archive will be stored.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#path LogsArchive#path}
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def project_id(self) -> builtins.str:
        '''Your project id.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#project_id LogsArchive#project_id}
        '''
        result = self._values.get("project_id")
        assert result is not None, "Required property 'project_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsArchiveGcsArchive(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LogsArchiveOrder(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.LogsArchiveOrder",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive_order.html datadog_logs_archive_order}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        archive_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive_order.html datadog_logs_archive_order} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param archive_ids: The archive IDs list. The order of archive IDs in this attribute defines the overall archive order for logs. If ``archive_ids`` is empty or not specified, it will import the actual archive order, and create the resource. Otherwise, it will try to update the order. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive_order.html#archive_ids LogsArchiveOrder#archive_ids}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = LogsArchiveOrderConfig(
            archive_ids=archive_ids,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(LogsArchiveOrder, self, [scope, id, config])

    @jsii.member(jsii_name="resetArchiveIds")
    def reset_archive_ids(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetArchiveIds", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="archiveIdsInput")
    def archive_ids_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "archiveIdsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="archiveIds")
    def archive_ids(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "archiveIds"))

    @archive_ids.setter
    def archive_ids(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "archiveIds", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsArchiveOrderConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "archive_ids": "archiveIds",
    },
)
class LogsArchiveOrderConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        archive_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param archive_ids: The archive IDs list. The order of archive IDs in this attribute defines the overall archive order for logs. If ``archive_ids`` is empty or not specified, it will import the actual archive order, and create the resource. Otherwise, it will try to update the order. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive_order.html#archive_ids LogsArchiveOrder#archive_ids}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if archive_ids is not None:
            self._values["archive_ids"] = archive_ids

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def archive_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The archive IDs list.

        The order of archive IDs in this attribute defines the overall archive order for logs. If ``archive_ids`` is empty or not specified, it will import the actual archive order, and create the resource. Otherwise, it will try to update the order.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive_order.html#archive_ids LogsArchiveOrder#archive_ids}
        '''
        result = self._values.get("archive_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsArchiveOrderConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsArchiveS3Archive",
    jsii_struct_bases=[],
    name_mapping={
        "account_id": "accountId",
        "bucket": "bucket",
        "path": "path",
        "role_name": "roleName",
    },
)
class LogsArchiveS3Archive:
    def __init__(
        self,
        *,
        account_id: builtins.str,
        bucket: builtins.str,
        path: builtins.str,
        role_name: builtins.str,
    ) -> None:
        '''
        :param account_id: Your AWS account id. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#account_id LogsArchive#account_id}
        :param bucket: Name of your s3 bucket. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#bucket LogsArchive#bucket}
        :param path: Path where the archive will be stored. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#path LogsArchive#path}
        :param role_name: Your AWS role name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#role_name LogsArchive#role_name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "account_id": account_id,
            "bucket": bucket,
            "path": path,
            "role_name": role_name,
        }

    @builtins.property
    def account_id(self) -> builtins.str:
        '''Your AWS account id.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#account_id LogsArchive#account_id}
        '''
        result = self._values.get("account_id")
        assert result is not None, "Required property 'account_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def bucket(self) -> builtins.str:
        '''Name of your s3 bucket.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#bucket LogsArchive#bucket}
        '''
        result = self._values.get("bucket")
        assert result is not None, "Required property 'bucket' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the archive will be stored.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#path LogsArchive#path}
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_name(self) -> builtins.str:
        '''Your AWS role name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_archive.html#role_name LogsArchive#role_name}
        '''
        result = self._values.get("role_name")
        assert result is not None, "Required property 'role_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsArchiveS3Archive(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LogsCustomPipeline(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.LogsCustomPipeline",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html datadog_logs_custom_pipeline}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        filter: typing.Sequence["LogsCustomPipelineFilter"],
        name: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        processor: typing.Optional[typing.Sequence["LogsCustomPipelineProcessor"]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html datadog_logs_custom_pipeline} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#filter LogsCustomPipeline#filter}
        :param name: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}.
        :param is_enabled: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}.
        :param processor: processor block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#processor LogsCustomPipeline#processor}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = LogsCustomPipelineConfig(
            filter=filter,
            name=name,
            is_enabled=is_enabled,
            processor=processor,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(LogsCustomPipeline, self, [scope, id, config])

    @jsii.member(jsii_name="resetIsEnabled")
    def reset_is_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIsEnabled", []))

    @jsii.member(jsii_name="resetProcessor")
    def reset_processor(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetProcessor", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filterInput")
    def filter_input(self) -> typing.List["LogsCustomPipelineFilter"]:
        return typing.cast(typing.List["LogsCustomPipelineFilter"], jsii.get(self, "filterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="isEnabledInput")
    def is_enabled_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "isEnabledInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="processorInput")
    def processor_input(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessor"]]:
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessor"]], jsii.get(self, "processorInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filter")
    def filter(self) -> typing.List["LogsCustomPipelineFilter"]:
        return typing.cast(typing.List["LogsCustomPipelineFilter"], jsii.get(self, "filter"))

    @filter.setter
    def filter(self, value: typing.List["LogsCustomPipelineFilter"]) -> None:
        jsii.set(self, "filter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="isEnabled")
    def is_enabled(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "isEnabled"))

    @is_enabled.setter
    def is_enabled(self, value: builtins.bool) -> None:
        jsii.set(self, "isEnabled", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="processor")
    def processor(self) -> typing.List["LogsCustomPipelineProcessor"]:
        return typing.cast(typing.List["LogsCustomPipelineProcessor"], jsii.get(self, "processor"))

    @processor.setter
    def processor(self, value: typing.List["LogsCustomPipelineProcessor"]) -> None:
        jsii.set(self, "processor", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "filter": "filter",
        "name": "name",
        "is_enabled": "isEnabled",
        "processor": "processor",
    },
)
class LogsCustomPipelineConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        filter: typing.Sequence["LogsCustomPipelineFilter"],
        name: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        processor: typing.Optional[typing.Sequence["LogsCustomPipelineProcessor"]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#filter LogsCustomPipeline#filter}
        :param name: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}.
        :param is_enabled: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}.
        :param processor: processor block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#processor LogsCustomPipeline#processor}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "filter": filter,
            "name": name,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if processor is not None:
            self._values["processor"] = processor

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def filter(self) -> typing.List["LogsCustomPipelineFilter"]:
        '''filter block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#filter LogsCustomPipeline#filter}
        '''
        result = self._values.get("filter")
        assert result is not None, "Required property 'filter' is missing"
        return typing.cast(typing.List["LogsCustomPipelineFilter"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}.'''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def processor(self) -> typing.Optional[typing.List["LogsCustomPipelineProcessor"]]:
        '''processor block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#processor LogsCustomPipeline#processor}
        '''
        result = self._values.get("processor")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessor"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineFilter",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class LogsCustomPipelineFilter:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Filter criteria of the category. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#query LogsCustomPipeline#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Filter criteria of the category.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#query LogsCustomPipeline#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessor",
    jsii_struct_bases=[],
    name_mapping={
        "arithmetic_processor": "arithmeticProcessor",
        "attribute_remapper": "attributeRemapper",
        "category_processor": "categoryProcessor",
        "date_remapper": "dateRemapper",
        "geo_ip_parser": "geoIpParser",
        "grok_parser": "grokParser",
        "lookup_processor": "lookupProcessor",
        "message_remapper": "messageRemapper",
        "pipeline": "pipeline",
        "service_remapper": "serviceRemapper",
        "status_remapper": "statusRemapper",
        "string_builder_processor": "stringBuilderProcessor",
        "trace_id_remapper": "traceIdRemapper",
        "url_parser": "urlParser",
        "user_agent_parser": "userAgentParser",
    },
)
class LogsCustomPipelineProcessor:
    def __init__(
        self,
        *,
        arithmetic_processor: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorArithmeticProcessor"]] = None,
        attribute_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorAttributeRemapper"]] = None,
        category_processor: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorCategoryProcessor"]] = None,
        date_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorDateRemapper"]] = None,
        geo_ip_parser: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorGeoIpParser"]] = None,
        grok_parser: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorGrokParser"]] = None,
        lookup_processor: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorLookupProcessor"]] = None,
        message_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorMessageRemapper"]] = None,
        pipeline: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipeline"]] = None,
        service_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorServiceRemapper"]] = None,
        status_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorStatusRemapper"]] = None,
        string_builder_processor: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorStringBuilderProcessor"]] = None,
        trace_id_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorTraceIdRemapper"]] = None,
        url_parser: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorUrlParser"]] = None,
        user_agent_parser: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorUserAgentParser"]] = None,
    ) -> None:
        '''
        :param arithmetic_processor: arithmetic_processor block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#arithmetic_processor LogsCustomPipeline#arithmetic_processor}
        :param attribute_remapper: attribute_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#attribute_remapper LogsCustomPipeline#attribute_remapper}
        :param category_processor: category_processor block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#category_processor LogsCustomPipeline#category_processor}
        :param date_remapper: date_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#date_remapper LogsCustomPipeline#date_remapper}
        :param geo_ip_parser: geo_ip_parser block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#geo_ip_parser LogsCustomPipeline#geo_ip_parser}
        :param grok_parser: grok_parser block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#grok_parser LogsCustomPipeline#grok_parser}
        :param lookup_processor: lookup_processor block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#lookup_processor LogsCustomPipeline#lookup_processor}
        :param message_remapper: message_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#message_remapper LogsCustomPipeline#message_remapper}
        :param pipeline: pipeline block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#pipeline LogsCustomPipeline#pipeline}
        :param service_remapper: service_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#service_remapper LogsCustomPipeline#service_remapper}
        :param status_remapper: status_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#status_remapper LogsCustomPipeline#status_remapper}
        :param string_builder_processor: string_builder_processor block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#string_builder_processor LogsCustomPipeline#string_builder_processor}
        :param trace_id_remapper: trace_id_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#trace_id_remapper LogsCustomPipeline#trace_id_remapper}
        :param url_parser: url_parser block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#url_parser LogsCustomPipeline#url_parser}
        :param user_agent_parser: user_agent_parser block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#user_agent_parser LogsCustomPipeline#user_agent_parser}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if arithmetic_processor is not None:
            self._values["arithmetic_processor"] = arithmetic_processor
        if attribute_remapper is not None:
            self._values["attribute_remapper"] = attribute_remapper
        if category_processor is not None:
            self._values["category_processor"] = category_processor
        if date_remapper is not None:
            self._values["date_remapper"] = date_remapper
        if geo_ip_parser is not None:
            self._values["geo_ip_parser"] = geo_ip_parser
        if grok_parser is not None:
            self._values["grok_parser"] = grok_parser
        if lookup_processor is not None:
            self._values["lookup_processor"] = lookup_processor
        if message_remapper is not None:
            self._values["message_remapper"] = message_remapper
        if pipeline is not None:
            self._values["pipeline"] = pipeline
        if service_remapper is not None:
            self._values["service_remapper"] = service_remapper
        if status_remapper is not None:
            self._values["status_remapper"] = status_remapper
        if string_builder_processor is not None:
            self._values["string_builder_processor"] = string_builder_processor
        if trace_id_remapper is not None:
            self._values["trace_id_remapper"] = trace_id_remapper
        if url_parser is not None:
            self._values["url_parser"] = url_parser
        if user_agent_parser is not None:
            self._values["user_agent_parser"] = user_agent_parser

    @builtins.property
    def arithmetic_processor(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorArithmeticProcessor"]]:
        '''arithmetic_processor block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#arithmetic_processor LogsCustomPipeline#arithmetic_processor}
        '''
        result = self._values.get("arithmetic_processor")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorArithmeticProcessor"]], result)

    @builtins.property
    def attribute_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorAttributeRemapper"]]:
        '''attribute_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#attribute_remapper LogsCustomPipeline#attribute_remapper}
        '''
        result = self._values.get("attribute_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorAttributeRemapper"]], result)

    @builtins.property
    def category_processor(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorCategoryProcessor"]]:
        '''category_processor block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#category_processor LogsCustomPipeline#category_processor}
        '''
        result = self._values.get("category_processor")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorCategoryProcessor"]], result)

    @builtins.property
    def date_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorDateRemapper"]]:
        '''date_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#date_remapper LogsCustomPipeline#date_remapper}
        '''
        result = self._values.get("date_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorDateRemapper"]], result)

    @builtins.property
    def geo_ip_parser(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorGeoIpParser"]]:
        '''geo_ip_parser block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#geo_ip_parser LogsCustomPipeline#geo_ip_parser}
        '''
        result = self._values.get("geo_ip_parser")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorGeoIpParser"]], result)

    @builtins.property
    def grok_parser(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorGrokParser"]]:
        '''grok_parser block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#grok_parser LogsCustomPipeline#grok_parser}
        '''
        result = self._values.get("grok_parser")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorGrokParser"]], result)

    @builtins.property
    def lookup_processor(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorLookupProcessor"]]:
        '''lookup_processor block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#lookup_processor LogsCustomPipeline#lookup_processor}
        '''
        result = self._values.get("lookup_processor")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorLookupProcessor"]], result)

    @builtins.property
    def message_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorMessageRemapper"]]:
        '''message_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#message_remapper LogsCustomPipeline#message_remapper}
        '''
        result = self._values.get("message_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorMessageRemapper"]], result)

    @builtins.property
    def pipeline(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipeline"]]:
        '''pipeline block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#pipeline LogsCustomPipeline#pipeline}
        '''
        result = self._values.get("pipeline")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipeline"]], result)

    @builtins.property
    def service_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorServiceRemapper"]]:
        '''service_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#service_remapper LogsCustomPipeline#service_remapper}
        '''
        result = self._values.get("service_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorServiceRemapper"]], result)

    @builtins.property
    def status_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorStatusRemapper"]]:
        '''status_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#status_remapper LogsCustomPipeline#status_remapper}
        '''
        result = self._values.get("status_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorStatusRemapper"]], result)

    @builtins.property
    def string_builder_processor(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorStringBuilderProcessor"]]:
        '''string_builder_processor block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#string_builder_processor LogsCustomPipeline#string_builder_processor}
        '''
        result = self._values.get("string_builder_processor")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorStringBuilderProcessor"]], result)

    @builtins.property
    def trace_id_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorTraceIdRemapper"]]:
        '''trace_id_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#trace_id_remapper LogsCustomPipeline#trace_id_remapper}
        '''
        result = self._values.get("trace_id_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorTraceIdRemapper"]], result)

    @builtins.property
    def url_parser(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorUrlParser"]]:
        '''url_parser block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#url_parser LogsCustomPipeline#url_parser}
        '''
        result = self._values.get("url_parser")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorUrlParser"]], result)

    @builtins.property
    def user_agent_parser(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorUserAgentParser"]]:
        '''user_agent_parser block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#user_agent_parser LogsCustomPipeline#user_agent_parser}
        '''
        result = self._values.get("user_agent_parser")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorUserAgentParser"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessor(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorArithmeticProcessor",
    jsii_struct_bases=[],
    name_mapping={
        "expression": "expression",
        "target": "target",
        "is_enabled": "isEnabled",
        "is_replace_missing": "isReplaceMissing",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorArithmeticProcessor:
    def __init__(
        self,
        *,
        expression: builtins.str,
        target: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        is_replace_missing: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param expression: Arithmetic operation between one or more log attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#expression LogsCustomPipeline#expression}
        :param target: Name of the attribute that contains the result of the arithmetic operation. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param is_enabled: Boolean value to enable your pipeline. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param is_replace_missing: If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_replace_missing LogsCustomPipeline#is_replace_missing}
        :param name: Your pipeline name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "expression": expression,
            "target": target,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if is_replace_missing is not None:
            self._values["is_replace_missing"] = is_replace_missing
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def expression(self) -> builtins.str:
        '''Arithmetic operation between one or more log attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#expression LogsCustomPipeline#expression}
        '''
        result = self._values.get("expression")
        assert result is not None, "Required property 'expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the attribute that contains the result of the arithmetic operation.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''Boolean value to enable your pipeline.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def is_replace_missing(self) -> typing.Optional[builtins.bool]:
        '''If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_replace_missing LogsCustomPipeline#is_replace_missing}
        '''
        result = self._values.get("is_replace_missing")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Your pipeline name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorArithmeticProcessor(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorAttributeRemapper",
    jsii_struct_bases=[],
    name_mapping={
        "sources": "sources",
        "source_type": "sourceType",
        "target": "target",
        "target_type": "targetType",
        "is_enabled": "isEnabled",
        "name": "name",
        "override_on_conflict": "overrideOnConflict",
        "preserve_source": "preserveSource",
        "target_format": "targetFormat",
    },
)
class LogsCustomPipelineProcessorAttributeRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        source_type: builtins.str,
        target: builtins.str,
        target_type: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        override_on_conflict: typing.Optional[builtins.bool] = None,
        preserve_source: typing.Optional[builtins.bool] = None,
        target_format: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes or tags. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param source_type: Defines where the sources are from (log ``attribute`` or ``tag``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source_type LogsCustomPipeline#source_type}
        :param target: Final attribute or tag name to remap the sources. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param target_type: Defines if the target is a log ``attribute`` or ``tag``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target_type LogsCustomPipeline#target_type}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        :param override_on_conflict: Override the target element if already set. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#override_on_conflict LogsCustomPipeline#override_on_conflict}
        :param preserve_source: Remove or preserve the remapped source element. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#preserve_source LogsCustomPipeline#preserve_source}
        :param target_format: If the ``target_type`` of the remapper is ``attribute``, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. ``string``, ``integer``, or ``double`` are the possible types. If the ``target_type`` is ``tag``, this parameter may not be specified. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target_format LogsCustomPipeline#target_format}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
            "source_type": source_type,
            "target": target,
            "target_type": target_type,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name
        if override_on_conflict is not None:
            self._values["override_on_conflict"] = override_on_conflict
        if preserve_source is not None:
            self._values["preserve_source"] = preserve_source
        if target_format is not None:
            self._values["target_format"] = target_format

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes or tags.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def source_type(self) -> builtins.str:
        '''Defines where the sources are from (log ``attribute`` or ``tag``).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source_type LogsCustomPipeline#source_type}
        '''
        result = self._values.get("source_type")
        assert result is not None, "Required property 'source_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Final attribute or tag name to remap the sources.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_type(self) -> builtins.str:
        '''Defines if the target is a log ``attribute`` or ``tag``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target_type LogsCustomPipeline#target_type}
        '''
        result = self._values.get("target_type")
        assert result is not None, "Required property 'target_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_on_conflict(self) -> typing.Optional[builtins.bool]:
        '''Override the target element if already set.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#override_on_conflict LogsCustomPipeline#override_on_conflict}
        '''
        result = self._values.get("override_on_conflict")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def preserve_source(self) -> typing.Optional[builtins.bool]:
        '''Remove or preserve the remapped source element.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#preserve_source LogsCustomPipeline#preserve_source}
        '''
        result = self._values.get("preserve_source")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def target_format(self) -> typing.Optional[builtins.str]:
        '''If the ``target_type`` of the remapper is ``attribute``, try to cast the value to a new specific type.

        If the cast is not possible, the original type is kept. ``string``, ``integer``, or ``double`` are the possible types. If the ``target_type`` is ``tag``, this parameter may not be specified.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target_format LogsCustomPipeline#target_format}
        '''
        result = self._values.get("target_format")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorAttributeRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorCategoryProcessor",
    jsii_struct_bases=[],
    name_mapping={
        "category": "category",
        "target": "target",
        "is_enabled": "isEnabled",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorCategoryProcessor:
    def __init__(
        self,
        *,
        category: typing.Sequence["LogsCustomPipelineProcessorCategoryProcessorCategory"],
        target: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param category: category block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#category LogsCustomPipeline#category}
        :param target: Name of the target attribute whose value is defined by the matching category. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the category. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "category": category,
            "target": target,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def category(
        self,
    ) -> typing.List["LogsCustomPipelineProcessorCategoryProcessorCategory"]:
        '''category block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#category LogsCustomPipeline#category}
        '''
        result = self._values.get("category")
        assert result is not None, "Required property 'category' is missing"
        return typing.cast(typing.List["LogsCustomPipelineProcessorCategoryProcessorCategory"], result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the target attribute whose value is defined by the matching category.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the category.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorCategoryProcessor(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorCategoryProcessorCategory",
    jsii_struct_bases=[],
    name_mapping={"filter": "filter", "name": "name"},
)
class LogsCustomPipelineProcessorCategoryProcessorCategory:
    def __init__(
        self,
        *,
        filter: typing.Sequence["LogsCustomPipelineProcessorCategoryProcessorCategoryFilter"],
        name: builtins.str,
    ) -> None:
        '''
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#filter LogsCustomPipeline#filter}
        :param name: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}.
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "filter": filter,
            "name": name,
        }

    @builtins.property
    def filter(
        self,
    ) -> typing.List["LogsCustomPipelineProcessorCategoryProcessorCategoryFilter"]:
        '''filter block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#filter LogsCustomPipeline#filter}
        '''
        result = self._values.get("filter")
        assert result is not None, "Required property 'filter' is missing"
        return typing.cast(typing.List["LogsCustomPipelineProcessorCategoryProcessorCategoryFilter"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorCategoryProcessorCategory(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class LogsCustomPipelineProcessorCategoryProcessorCategoryFilter:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Filter criteria of the category. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#query LogsCustomPipeline#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Filter criteria of the category.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#query LogsCustomPipeline#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorCategoryProcessorCategoryFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorDateRemapper",
    jsii_struct_bases=[],
    name_mapping={"sources": "sources", "is_enabled": "isEnabled", "name": "name"},
)
class LogsCustomPipelineProcessorDateRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorDateRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorGeoIpParser",
    jsii_struct_bases=[],
    name_mapping={
        "sources": "sources",
        "target": "target",
        "is_enabled": "isEnabled",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorGeoIpParser:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        target: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param target: Name of the parent attribute that contains all the extracted details from the sources. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
            "target": target,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the parent attribute that contains all the extracted details from the sources.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorGeoIpParser(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorGrokParser",
    jsii_struct_bases=[],
    name_mapping={
        "grok": "grok",
        "source": "source",
        "is_enabled": "isEnabled",
        "name": "name",
        "samples": "samples",
    },
)
class LogsCustomPipelineProcessorGrokParser:
    def __init__(
        self,
        *,
        grok: typing.Sequence["LogsCustomPipelineProcessorGrokParserGrok"],
        source: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        samples: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param grok: grok block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#grok LogsCustomPipeline#grok}
        :param source: Name of the log attribute to parse. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source LogsCustomPipeline#source}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        :param samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#samples LogsCustomPipeline#samples}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "grok": grok,
            "source": source,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name
        if samples is not None:
            self._values["samples"] = samples

    @builtins.property
    def grok(self) -> typing.List["LogsCustomPipelineProcessorGrokParserGrok"]:
        '''grok block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#grok LogsCustomPipeline#grok}
        '''
        result = self._values.get("grok")
        assert result is not None, "Required property 'grok' is missing"
        return typing.cast(typing.List["LogsCustomPipelineProcessorGrokParserGrok"], result)

    @builtins.property
    def source(self) -> builtins.str:
        '''Name of the log attribute to parse.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source LogsCustomPipeline#source}
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def samples(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of sample logs for this parser.

        It can save up to 5 samples. Each sample takes up to 5000 characters.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#samples LogsCustomPipeline#samples}
        '''
        result = self._values.get("samples")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorGrokParser(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorGrokParserGrok",
    jsii_struct_bases=[],
    name_mapping={"match_rules": "matchRules", "support_rules": "supportRules"},
)
class LogsCustomPipelineProcessorGrokParserGrok:
    def __init__(
        self,
        *,
        match_rules: builtins.str,
        support_rules: builtins.str,
    ) -> None:
        '''
        :param match_rules: Match rules for your grok parser. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#match_rules LogsCustomPipeline#match_rules}
        :param support_rules: Support rules for your grok parser. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#support_rules LogsCustomPipeline#support_rules}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "match_rules": match_rules,
            "support_rules": support_rules,
        }

    @builtins.property
    def match_rules(self) -> builtins.str:
        '''Match rules for your grok parser.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#match_rules LogsCustomPipeline#match_rules}
        '''
        result = self._values.get("match_rules")
        assert result is not None, "Required property 'match_rules' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def support_rules(self) -> builtins.str:
        '''Support rules for your grok parser.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#support_rules LogsCustomPipeline#support_rules}
        '''
        result = self._values.get("support_rules")
        assert result is not None, "Required property 'support_rules' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorGrokParserGrok(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorLookupProcessor",
    jsii_struct_bases=[],
    name_mapping={
        "lookup_table": "lookupTable",
        "source": "source",
        "target": "target",
        "default_lookup": "defaultLookup",
        "is_enabled": "isEnabled",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorLookupProcessor:
    def __init__(
        self,
        *,
        lookup_table: typing.Sequence[builtins.str],
        source: builtins.str,
        target: builtins.str,
        default_lookup: typing.Optional[builtins.str] = None,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param lookup_table: List of entries of the lookup table using ``key,value`` format. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#lookup_table LogsCustomPipeline#lookup_table}
        :param source: Name of the source attribute used to do the lookup. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source LogsCustomPipeline#source}
        :param target: Name of the attribute that contains the result of the lookup. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#default_lookup LogsCustomPipeline#default_lookup}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "lookup_table": lookup_table,
            "source": source,
            "target": target,
        }
        if default_lookup is not None:
            self._values["default_lookup"] = default_lookup
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def lookup_table(self) -> typing.List[builtins.str]:
        '''List of entries of the lookup table using ``key,value`` format.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#lookup_table LogsCustomPipeline#lookup_table}
        '''
        result = self._values.get("lookup_table")
        assert result is not None, "Required property 'lookup_table' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def source(self) -> builtins.str:
        '''Name of the source attribute used to do the lookup.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source LogsCustomPipeline#source}
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the attribute that contains the result of the lookup.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def default_lookup(self) -> typing.Optional[builtins.str]:
        '''Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#default_lookup LogsCustomPipeline#default_lookup}
        '''
        result = self._values.get("default_lookup")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorLookupProcessor(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorMessageRemapper",
    jsii_struct_bases=[],
    name_mapping={"sources": "sources", "is_enabled": "isEnabled", "name": "name"},
)
class LogsCustomPipelineProcessorMessageRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorMessageRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipeline",
    jsii_struct_bases=[],
    name_mapping={
        "filter": "filter",
        "name": "name",
        "is_enabled": "isEnabled",
        "processor": "processor",
    },
)
class LogsCustomPipelineProcessorPipeline:
    def __init__(
        self,
        *,
        filter: typing.Sequence["LogsCustomPipelineProcessorPipelineFilter"],
        name: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        processor: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessor"]] = None,
    ) -> None:
        '''
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#filter LogsCustomPipeline#filter}
        :param name: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}.
        :param is_enabled: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}.
        :param processor: processor block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#processor LogsCustomPipeline#processor}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "filter": filter,
            "name": name,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if processor is not None:
            self._values["processor"] = processor

    @builtins.property
    def filter(self) -> typing.List["LogsCustomPipelineProcessorPipelineFilter"]:
        '''filter block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#filter LogsCustomPipeline#filter}
        '''
        result = self._values.get("filter")
        assert result is not None, "Required property 'filter' is missing"
        return typing.cast(typing.List["LogsCustomPipelineProcessorPipelineFilter"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}.'''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def processor(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessor"]]:
        '''processor block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#processor LogsCustomPipeline#processor}
        '''
        result = self._values.get("processor")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessor"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipeline(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineFilter",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class LogsCustomPipelineProcessorPipelineFilter:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Filter criteria of the category. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#query LogsCustomPipeline#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Filter criteria of the category.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#query LogsCustomPipeline#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessor",
    jsii_struct_bases=[],
    name_mapping={
        "arithmetic_processor": "arithmeticProcessor",
        "attribute_remapper": "attributeRemapper",
        "category_processor": "categoryProcessor",
        "date_remapper": "dateRemapper",
        "geo_ip_parser": "geoIpParser",
        "grok_parser": "grokParser",
        "lookup_processor": "lookupProcessor",
        "message_remapper": "messageRemapper",
        "service_remapper": "serviceRemapper",
        "status_remapper": "statusRemapper",
        "string_builder_processor": "stringBuilderProcessor",
        "trace_id_remapper": "traceIdRemapper",
        "url_parser": "urlParser",
        "user_agent_parser": "userAgentParser",
    },
)
class LogsCustomPipelineProcessorPipelineProcessor:
    def __init__(
        self,
        *,
        arithmetic_processor: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor"]] = None,
        attribute_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper"]] = None,
        category_processor: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor"]] = None,
        date_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorDateRemapper"]] = None,
        geo_ip_parser: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorGeoIpParser"]] = None,
        grok_parser: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorGrokParser"]] = None,
        lookup_processor: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorLookupProcessor"]] = None,
        message_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorMessageRemapper"]] = None,
        service_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorServiceRemapper"]] = None,
        status_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorStatusRemapper"]] = None,
        string_builder_processor: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor"]] = None,
        trace_id_remapper: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper"]] = None,
        url_parser: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorUrlParser"]] = None,
        user_agent_parser: typing.Optional[typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorUserAgentParser"]] = None,
    ) -> None:
        '''
        :param arithmetic_processor: arithmetic_processor block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#arithmetic_processor LogsCustomPipeline#arithmetic_processor}
        :param attribute_remapper: attribute_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#attribute_remapper LogsCustomPipeline#attribute_remapper}
        :param category_processor: category_processor block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#category_processor LogsCustomPipeline#category_processor}
        :param date_remapper: date_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#date_remapper LogsCustomPipeline#date_remapper}
        :param geo_ip_parser: geo_ip_parser block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#geo_ip_parser LogsCustomPipeline#geo_ip_parser}
        :param grok_parser: grok_parser block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#grok_parser LogsCustomPipeline#grok_parser}
        :param lookup_processor: lookup_processor block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#lookup_processor LogsCustomPipeline#lookup_processor}
        :param message_remapper: message_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#message_remapper LogsCustomPipeline#message_remapper}
        :param service_remapper: service_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#service_remapper LogsCustomPipeline#service_remapper}
        :param status_remapper: status_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#status_remapper LogsCustomPipeline#status_remapper}
        :param string_builder_processor: string_builder_processor block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#string_builder_processor LogsCustomPipeline#string_builder_processor}
        :param trace_id_remapper: trace_id_remapper block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#trace_id_remapper LogsCustomPipeline#trace_id_remapper}
        :param url_parser: url_parser block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#url_parser LogsCustomPipeline#url_parser}
        :param user_agent_parser: user_agent_parser block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#user_agent_parser LogsCustomPipeline#user_agent_parser}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if arithmetic_processor is not None:
            self._values["arithmetic_processor"] = arithmetic_processor
        if attribute_remapper is not None:
            self._values["attribute_remapper"] = attribute_remapper
        if category_processor is not None:
            self._values["category_processor"] = category_processor
        if date_remapper is not None:
            self._values["date_remapper"] = date_remapper
        if geo_ip_parser is not None:
            self._values["geo_ip_parser"] = geo_ip_parser
        if grok_parser is not None:
            self._values["grok_parser"] = grok_parser
        if lookup_processor is not None:
            self._values["lookup_processor"] = lookup_processor
        if message_remapper is not None:
            self._values["message_remapper"] = message_remapper
        if service_remapper is not None:
            self._values["service_remapper"] = service_remapper
        if status_remapper is not None:
            self._values["status_remapper"] = status_remapper
        if string_builder_processor is not None:
            self._values["string_builder_processor"] = string_builder_processor
        if trace_id_remapper is not None:
            self._values["trace_id_remapper"] = trace_id_remapper
        if url_parser is not None:
            self._values["url_parser"] = url_parser
        if user_agent_parser is not None:
            self._values["user_agent_parser"] = user_agent_parser

    @builtins.property
    def arithmetic_processor(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor"]]:
        '''arithmetic_processor block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#arithmetic_processor LogsCustomPipeline#arithmetic_processor}
        '''
        result = self._values.get("arithmetic_processor")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor"]], result)

    @builtins.property
    def attribute_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper"]]:
        '''attribute_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#attribute_remapper LogsCustomPipeline#attribute_remapper}
        '''
        result = self._values.get("attribute_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper"]], result)

    @builtins.property
    def category_processor(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor"]]:
        '''category_processor block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#category_processor LogsCustomPipeline#category_processor}
        '''
        result = self._values.get("category_processor")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor"]], result)

    @builtins.property
    def date_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorDateRemapper"]]:
        '''date_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#date_remapper LogsCustomPipeline#date_remapper}
        '''
        result = self._values.get("date_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorDateRemapper"]], result)

    @builtins.property
    def geo_ip_parser(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorGeoIpParser"]]:
        '''geo_ip_parser block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#geo_ip_parser LogsCustomPipeline#geo_ip_parser}
        '''
        result = self._values.get("geo_ip_parser")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorGeoIpParser"]], result)

    @builtins.property
    def grok_parser(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorGrokParser"]]:
        '''grok_parser block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#grok_parser LogsCustomPipeline#grok_parser}
        '''
        result = self._values.get("grok_parser")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorGrokParser"]], result)

    @builtins.property
    def lookup_processor(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorLookupProcessor"]]:
        '''lookup_processor block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#lookup_processor LogsCustomPipeline#lookup_processor}
        '''
        result = self._values.get("lookup_processor")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorLookupProcessor"]], result)

    @builtins.property
    def message_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorMessageRemapper"]]:
        '''message_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#message_remapper LogsCustomPipeline#message_remapper}
        '''
        result = self._values.get("message_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorMessageRemapper"]], result)

    @builtins.property
    def service_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorServiceRemapper"]]:
        '''service_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#service_remapper LogsCustomPipeline#service_remapper}
        '''
        result = self._values.get("service_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorServiceRemapper"]], result)

    @builtins.property
    def status_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorStatusRemapper"]]:
        '''status_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#status_remapper LogsCustomPipeline#status_remapper}
        '''
        result = self._values.get("status_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorStatusRemapper"]], result)

    @builtins.property
    def string_builder_processor(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor"]]:
        '''string_builder_processor block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#string_builder_processor LogsCustomPipeline#string_builder_processor}
        '''
        result = self._values.get("string_builder_processor")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor"]], result)

    @builtins.property
    def trace_id_remapper(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper"]]:
        '''trace_id_remapper block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#trace_id_remapper LogsCustomPipeline#trace_id_remapper}
        '''
        result = self._values.get("trace_id_remapper")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper"]], result)

    @builtins.property
    def url_parser(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorUrlParser"]]:
        '''url_parser block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#url_parser LogsCustomPipeline#url_parser}
        '''
        result = self._values.get("url_parser")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorUrlParser"]], result)

    @builtins.property
    def user_agent_parser(
        self,
    ) -> typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorUserAgentParser"]]:
        '''user_agent_parser block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#user_agent_parser LogsCustomPipeline#user_agent_parser}
        '''
        result = self._values.get("user_agent_parser")
        return typing.cast(typing.Optional[typing.List["LogsCustomPipelineProcessorPipelineProcessorUserAgentParser"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessor(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor",
    jsii_struct_bases=[],
    name_mapping={
        "expression": "expression",
        "target": "target",
        "is_enabled": "isEnabled",
        "is_replace_missing": "isReplaceMissing",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor:
    def __init__(
        self,
        *,
        expression: builtins.str,
        target: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        is_replace_missing: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param expression: Arithmetic operation between one or more log attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#expression LogsCustomPipeline#expression}
        :param target: Name of the attribute that contains the result of the arithmetic operation. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param is_enabled: Boolean value to enable your pipeline. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param is_replace_missing: If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_replace_missing LogsCustomPipeline#is_replace_missing}
        :param name: Your pipeline name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "expression": expression,
            "target": target,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if is_replace_missing is not None:
            self._values["is_replace_missing"] = is_replace_missing
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def expression(self) -> builtins.str:
        '''Arithmetic operation between one or more log attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#expression LogsCustomPipeline#expression}
        '''
        result = self._values.get("expression")
        assert result is not None, "Required property 'expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the attribute that contains the result of the arithmetic operation.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''Boolean value to enable your pipeline.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def is_replace_missing(self) -> typing.Optional[builtins.bool]:
        '''If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_replace_missing LogsCustomPipeline#is_replace_missing}
        '''
        result = self._values.get("is_replace_missing")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Your pipeline name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper",
    jsii_struct_bases=[],
    name_mapping={
        "sources": "sources",
        "source_type": "sourceType",
        "target": "target",
        "target_type": "targetType",
        "is_enabled": "isEnabled",
        "name": "name",
        "override_on_conflict": "overrideOnConflict",
        "preserve_source": "preserveSource",
        "target_format": "targetFormat",
    },
)
class LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        source_type: builtins.str,
        target: builtins.str,
        target_type: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        override_on_conflict: typing.Optional[builtins.bool] = None,
        preserve_source: typing.Optional[builtins.bool] = None,
        target_format: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes or tags. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param source_type: Defines where the sources are from (log ``attribute`` or ``tag``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source_type LogsCustomPipeline#source_type}
        :param target: Final attribute or tag name to remap the sources. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param target_type: Defines if the target is a log ``attribute`` or ``tag``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target_type LogsCustomPipeline#target_type}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        :param override_on_conflict: Override the target element if already set. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#override_on_conflict LogsCustomPipeline#override_on_conflict}
        :param preserve_source: Remove or preserve the remapped source element. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#preserve_source LogsCustomPipeline#preserve_source}
        :param target_format: If the ``target_type`` of the remapper is ``attribute``, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. ``string``, ``integer``, or ``double`` are the possible types. If the ``target_type`` is ``tag``, this parameter may not be specified. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target_format LogsCustomPipeline#target_format}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
            "source_type": source_type,
            "target": target,
            "target_type": target_type,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name
        if override_on_conflict is not None:
            self._values["override_on_conflict"] = override_on_conflict
        if preserve_source is not None:
            self._values["preserve_source"] = preserve_source
        if target_format is not None:
            self._values["target_format"] = target_format

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes or tags.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def source_type(self) -> builtins.str:
        '''Defines where the sources are from (log ``attribute`` or ``tag``).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source_type LogsCustomPipeline#source_type}
        '''
        result = self._values.get("source_type")
        assert result is not None, "Required property 'source_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Final attribute or tag name to remap the sources.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_type(self) -> builtins.str:
        '''Defines if the target is a log ``attribute`` or ``tag``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target_type LogsCustomPipeline#target_type}
        '''
        result = self._values.get("target_type")
        assert result is not None, "Required property 'target_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_on_conflict(self) -> typing.Optional[builtins.bool]:
        '''Override the target element if already set.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#override_on_conflict LogsCustomPipeline#override_on_conflict}
        '''
        result = self._values.get("override_on_conflict")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def preserve_source(self) -> typing.Optional[builtins.bool]:
        '''Remove or preserve the remapped source element.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#preserve_source LogsCustomPipeline#preserve_source}
        '''
        result = self._values.get("preserve_source")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def target_format(self) -> typing.Optional[builtins.str]:
        '''If the ``target_type`` of the remapper is ``attribute``, try to cast the value to a new specific type.

        If the cast is not possible, the original type is kept. ``string``, ``integer``, or ``double`` are the possible types. If the ``target_type`` is ``tag``, this parameter may not be specified.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target_format LogsCustomPipeline#target_format}
        '''
        result = self._values.get("target_format")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor",
    jsii_struct_bases=[],
    name_mapping={
        "category": "category",
        "target": "target",
        "is_enabled": "isEnabled",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor:
    def __init__(
        self,
        *,
        category: typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory"],
        target: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param category: category block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#category LogsCustomPipeline#category}
        :param target: Name of the target attribute whose value is defined by the matching category. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the category. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "category": category,
            "target": target,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def category(
        self,
    ) -> typing.List["LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory"]:
        '''category block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#category LogsCustomPipeline#category}
        '''
        result = self._values.get("category")
        assert result is not None, "Required property 'category' is missing"
        return typing.cast(typing.List["LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory"], result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the target attribute whose value is defined by the matching category.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the category.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory",
    jsii_struct_bases=[],
    name_mapping={"filter": "filter", "name": "name"},
)
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory:
    def __init__(
        self,
        *,
        filter: typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter"],
        name: builtins.str,
    ) -> None:
        '''
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#filter LogsCustomPipeline#filter}
        :param name: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}.
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "filter": filter,
            "name": name,
        }

    @builtins.property
    def filter(
        self,
    ) -> typing.List["LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter"]:
        '''filter block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#filter LogsCustomPipeline#filter}
        '''
        result = self._values.get("filter")
        assert result is not None, "Required property 'filter' is missing"
        return typing.cast(typing.List["LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Filter criteria of the category. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#query LogsCustomPipeline#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Filter criteria of the category.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#query LogsCustomPipeline#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorDateRemapper",
    jsii_struct_bases=[],
    name_mapping={"sources": "sources", "is_enabled": "isEnabled", "name": "name"},
)
class LogsCustomPipelineProcessorPipelineProcessorDateRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorDateRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser",
    jsii_struct_bases=[],
    name_mapping={
        "sources": "sources",
        "target": "target",
        "is_enabled": "isEnabled",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorPipelineProcessorGeoIpParser:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        target: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param target: Name of the parent attribute that contains all the extracted details from the sources. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
            "target": target,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the parent attribute that contains all the extracted details from the sources.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorGeoIpParser(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorGrokParser",
    jsii_struct_bases=[],
    name_mapping={
        "grok": "grok",
        "source": "source",
        "is_enabled": "isEnabled",
        "name": "name",
        "samples": "samples",
    },
)
class LogsCustomPipelineProcessorPipelineProcessorGrokParser:
    def __init__(
        self,
        *,
        grok: typing.Sequence["LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok"],
        source: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        samples: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param grok: grok block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#grok LogsCustomPipeline#grok}
        :param source: Name of the log attribute to parse. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source LogsCustomPipeline#source}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        :param samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#samples LogsCustomPipeline#samples}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "grok": grok,
            "source": source,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name
        if samples is not None:
            self._values["samples"] = samples

    @builtins.property
    def grok(
        self,
    ) -> typing.List["LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok"]:
        '''grok block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#grok LogsCustomPipeline#grok}
        '''
        result = self._values.get("grok")
        assert result is not None, "Required property 'grok' is missing"
        return typing.cast(typing.List["LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok"], result)

    @builtins.property
    def source(self) -> builtins.str:
        '''Name of the log attribute to parse.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source LogsCustomPipeline#source}
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def samples(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of sample logs for this parser.

        It can save up to 5 samples. Each sample takes up to 5000 characters.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#samples LogsCustomPipeline#samples}
        '''
        result = self._values.get("samples")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorGrokParser(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok",
    jsii_struct_bases=[],
    name_mapping={"match_rules": "matchRules", "support_rules": "supportRules"},
)
class LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok:
    def __init__(
        self,
        *,
        match_rules: builtins.str,
        support_rules: builtins.str,
    ) -> None:
        '''
        :param match_rules: Match rules for your grok parser. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#match_rules LogsCustomPipeline#match_rules}
        :param support_rules: Support rules for your grok parser. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#support_rules LogsCustomPipeline#support_rules}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "match_rules": match_rules,
            "support_rules": support_rules,
        }

    @builtins.property
    def match_rules(self) -> builtins.str:
        '''Match rules for your grok parser.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#match_rules LogsCustomPipeline#match_rules}
        '''
        result = self._values.get("match_rules")
        assert result is not None, "Required property 'match_rules' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def support_rules(self) -> builtins.str:
        '''Support rules for your grok parser.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#support_rules LogsCustomPipeline#support_rules}
        '''
        result = self._values.get("support_rules")
        assert result is not None, "Required property 'support_rules' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor",
    jsii_struct_bases=[],
    name_mapping={
        "lookup_table": "lookupTable",
        "source": "source",
        "target": "target",
        "default_lookup": "defaultLookup",
        "is_enabled": "isEnabled",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorPipelineProcessorLookupProcessor:
    def __init__(
        self,
        *,
        lookup_table: typing.Sequence[builtins.str],
        source: builtins.str,
        target: builtins.str,
        default_lookup: typing.Optional[builtins.str] = None,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param lookup_table: List of entries of the lookup table using ``key,value`` format. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#lookup_table LogsCustomPipeline#lookup_table}
        :param source: Name of the source attribute used to do the lookup. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source LogsCustomPipeline#source}
        :param target: Name of the attribute that contains the result of the lookup. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#default_lookup LogsCustomPipeline#default_lookup}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "lookup_table": lookup_table,
            "source": source,
            "target": target,
        }
        if default_lookup is not None:
            self._values["default_lookup"] = default_lookup
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def lookup_table(self) -> typing.List[builtins.str]:
        '''List of entries of the lookup table using ``key,value`` format.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#lookup_table LogsCustomPipeline#lookup_table}
        '''
        result = self._values.get("lookup_table")
        assert result is not None, "Required property 'lookup_table' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def source(self) -> builtins.str:
        '''Name of the source attribute used to do the lookup.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#source LogsCustomPipeline#source}
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the attribute that contains the result of the lookup.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def default_lookup(self) -> typing.Optional[builtins.str]:
        '''Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#default_lookup LogsCustomPipeline#default_lookup}
        '''
        result = self._values.get("default_lookup")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorLookupProcessor(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper",
    jsii_struct_bases=[],
    name_mapping={"sources": "sources", "is_enabled": "isEnabled", "name": "name"},
)
class LogsCustomPipelineProcessorPipelineProcessorMessageRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorMessageRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper",
    jsii_struct_bases=[],
    name_mapping={"sources": "sources", "is_enabled": "isEnabled", "name": "name"},
)
class LogsCustomPipelineProcessorPipelineProcessorServiceRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorServiceRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper",
    jsii_struct_bases=[],
    name_mapping={"sources": "sources", "is_enabled": "isEnabled", "name": "name"},
)
class LogsCustomPipelineProcessorPipelineProcessorStatusRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorStatusRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor",
    jsii_struct_bases=[],
    name_mapping={
        "target": "target",
        "template": "template",
        "is_enabled": "isEnabled",
        "is_replace_missing": "isReplaceMissing",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor:
    def __init__(
        self,
        *,
        target: builtins.str,
        template: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        is_replace_missing: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param target: The name of the attribute that contains the result of the template. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param template: The formula with one or more attributes and raw text. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#template LogsCustomPipeline#template}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param is_replace_missing: If it replaces all missing attributes of template by an empty string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_replace_missing LogsCustomPipeline#is_replace_missing}
        :param name: The name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "target": target,
            "template": template,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if is_replace_missing is not None:
            self._values["is_replace_missing"] = is_replace_missing
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def target(self) -> builtins.str:
        '''The name of the attribute that contains the result of the template.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def template(self) -> builtins.str:
        '''The formula with one or more attributes and raw text.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#template LogsCustomPipeline#template}
        '''
        result = self._values.get("template")
        assert result is not None, "Required property 'template' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def is_replace_missing(self) -> typing.Optional[builtins.bool]:
        '''If it replaces all missing attributes of template by an empty string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_replace_missing LogsCustomPipeline#is_replace_missing}
        '''
        result = self._values.get("is_replace_missing")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper",
    jsii_struct_bases=[],
    name_mapping={"sources": "sources", "is_enabled": "isEnabled", "name": "name"},
)
class LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorUrlParser",
    jsii_struct_bases=[],
    name_mapping={
        "sources": "sources",
        "target": "target",
        "is_enabled": "isEnabled",
        "name": "name",
        "normalize_ending_slashes": "normalizeEndingSlashes",
    },
)
class LogsCustomPipelineProcessorPipelineProcessorUrlParser:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        target: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        normalize_ending_slashes: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param target: Name of the parent attribute that contains all the extracted details from the sources. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        :param normalize_ending_slashes: Normalize the ending slashes or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#normalize_ending_slashes LogsCustomPipeline#normalize_ending_slashes}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
            "target": target,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name
        if normalize_ending_slashes is not None:
            self._values["normalize_ending_slashes"] = normalize_ending_slashes

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the parent attribute that contains all the extracted details from the sources.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def normalize_ending_slashes(self) -> typing.Optional[builtins.bool]:
        '''Normalize the ending slashes or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#normalize_ending_slashes LogsCustomPipeline#normalize_ending_slashes}
        '''
        result = self._values.get("normalize_ending_slashes")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorUrlParser(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser",
    jsii_struct_bases=[],
    name_mapping={
        "sources": "sources",
        "target": "target",
        "is_enabled": "isEnabled",
        "is_encoded": "isEncoded",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorPipelineProcessorUserAgentParser:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        target: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        is_encoded: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param target: Name of the parent attribute that contains all the extracted details from the sources. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param is_encoded: If the source attribute is URL encoded or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_encoded LogsCustomPipeline#is_encoded}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
            "target": target,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if is_encoded is not None:
            self._values["is_encoded"] = is_encoded
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the parent attribute that contains all the extracted details from the sources.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def is_encoded(self) -> typing.Optional[builtins.bool]:
        '''If the source attribute is URL encoded or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_encoded LogsCustomPipeline#is_encoded}
        '''
        result = self._values.get("is_encoded")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorPipelineProcessorUserAgentParser(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorServiceRemapper",
    jsii_struct_bases=[],
    name_mapping={"sources": "sources", "is_enabled": "isEnabled", "name": "name"},
)
class LogsCustomPipelineProcessorServiceRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorServiceRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorStatusRemapper",
    jsii_struct_bases=[],
    name_mapping={"sources": "sources", "is_enabled": "isEnabled", "name": "name"},
)
class LogsCustomPipelineProcessorStatusRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorStatusRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorStringBuilderProcessor",
    jsii_struct_bases=[],
    name_mapping={
        "target": "target",
        "template": "template",
        "is_enabled": "isEnabled",
        "is_replace_missing": "isReplaceMissing",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorStringBuilderProcessor:
    def __init__(
        self,
        *,
        target: builtins.str,
        template: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        is_replace_missing: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param target: The name of the attribute that contains the result of the template. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param template: The formula with one or more attributes and raw text. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#template LogsCustomPipeline#template}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param is_replace_missing: If it replaces all missing attributes of template by an empty string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_replace_missing LogsCustomPipeline#is_replace_missing}
        :param name: The name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "target": target,
            "template": template,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if is_replace_missing is not None:
            self._values["is_replace_missing"] = is_replace_missing
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def target(self) -> builtins.str:
        '''The name of the attribute that contains the result of the template.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def template(self) -> builtins.str:
        '''The formula with one or more attributes and raw text.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#template LogsCustomPipeline#template}
        '''
        result = self._values.get("template")
        assert result is not None, "Required property 'template' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def is_replace_missing(self) -> typing.Optional[builtins.bool]:
        '''If it replaces all missing attributes of template by an empty string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_replace_missing LogsCustomPipeline#is_replace_missing}
        '''
        result = self._values.get("is_replace_missing")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorStringBuilderProcessor(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorTraceIdRemapper",
    jsii_struct_bases=[],
    name_mapping={"sources": "sources", "is_enabled": "isEnabled", "name": "name"},
)
class LogsCustomPipelineProcessorTraceIdRemapper:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorTraceIdRemapper(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorUrlParser",
    jsii_struct_bases=[],
    name_mapping={
        "sources": "sources",
        "target": "target",
        "is_enabled": "isEnabled",
        "name": "name",
        "normalize_ending_slashes": "normalizeEndingSlashes",
    },
)
class LogsCustomPipelineProcessorUrlParser:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        target: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        normalize_ending_slashes: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param target: Name of the parent attribute that contains all the extracted details from the sources. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        :param normalize_ending_slashes: Normalize the ending slashes or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#normalize_ending_slashes LogsCustomPipeline#normalize_ending_slashes}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
            "target": target,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name
        if normalize_ending_slashes is not None:
            self._values["normalize_ending_slashes"] = normalize_ending_slashes

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the parent attribute that contains all the extracted details from the sources.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def normalize_ending_slashes(self) -> typing.Optional[builtins.bool]:
        '''Normalize the ending slashes or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#normalize_ending_slashes LogsCustomPipeline#normalize_ending_slashes}
        '''
        result = self._values.get("normalize_ending_slashes")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorUrlParser(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsCustomPipelineProcessorUserAgentParser",
    jsii_struct_bases=[],
    name_mapping={
        "sources": "sources",
        "target": "target",
        "is_enabled": "isEnabled",
        "is_encoded": "isEncoded",
        "name": "name",
    },
)
class LogsCustomPipelineProcessorUserAgentParser:
    def __init__(
        self,
        *,
        sources: typing.Sequence[builtins.str],
        target: builtins.str,
        is_enabled: typing.Optional[builtins.bool] = None,
        is_encoded: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param sources: List of source attributes. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        :param target: Name of the parent attribute that contains all the extracted details from the sources. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        :param is_enabled: If the processor is enabled or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        :param is_encoded: If the source attribute is URL encoded or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_encoded LogsCustomPipeline#is_encoded}
        :param name: Name of the processor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "sources": sources,
            "target": target,
        }
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if is_encoded is not None:
            self._values["is_encoded"] = is_encoded
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def sources(self) -> typing.List[builtins.str]:
        '''List of source attributes.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#sources LogsCustomPipeline#sources}
        '''
        result = self._values.get("sources")
        assert result is not None, "Required property 'sources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Name of the parent attribute that contains all the extracted details from the sources.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#target LogsCustomPipeline#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''If the processor is enabled or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_enabled LogsCustomPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def is_encoded(self) -> typing.Optional[builtins.bool]:
        '''If the source attribute is URL encoded or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#is_encoded LogsCustomPipeline#is_encoded}
        '''
        result = self._values.get("is_encoded")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the processor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_custom_pipeline.html#name LogsCustomPipeline#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsCustomPipelineProcessorUserAgentParser(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LogsIndex(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.LogsIndex",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html datadog_logs_index}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        filter: typing.Sequence["LogsIndexFilter"],
        name: builtins.str,
        daily_limit: typing.Optional[jsii.Number] = None,
        disable_daily_limit: typing.Optional[builtins.bool] = None,
        exclusion_filter: typing.Optional[typing.Sequence["LogsIndexExclusionFilter"]] = None,
        retention_days: typing.Optional[jsii.Number] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html datadog_logs_index} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#filter LogsIndex#filter}
        :param name: The name of the index. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#name LogsIndex#name}
        :param daily_limit: The number of log events you can send in this index per day before you are rate-limited. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#daily_limit LogsIndex#daily_limit}
        :param disable_daily_limit: If true, sets the daily_limit value to null and the index is not limited on a daily basis (any specified daily_limit value in the request is ignored). If false or omitted, the index's current daily_limit is maintained. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#disable_daily_limit LogsIndex#disable_daily_limit}
        :param exclusion_filter: exclusion_filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#exclusion_filter LogsIndex#exclusion_filter}
        :param retention_days: The number of days before logs are deleted from this index. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#retention_days LogsIndex#retention_days}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = LogsIndexConfig(
            filter=filter,
            name=name,
            daily_limit=daily_limit,
            disable_daily_limit=disable_daily_limit,
            exclusion_filter=exclusion_filter,
            retention_days=retention_days,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(LogsIndex, self, [scope, id, config])

    @jsii.member(jsii_name="resetDailyLimit")
    def reset_daily_limit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDailyLimit", []))

    @jsii.member(jsii_name="resetDisableDailyLimit")
    def reset_disable_daily_limit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisableDailyLimit", []))

    @jsii.member(jsii_name="resetExclusionFilter")
    def reset_exclusion_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetExclusionFilter", []))

    @jsii.member(jsii_name="resetRetentionDays")
    def reset_retention_days(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRetentionDays", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filterInput")
    def filter_input(self) -> typing.List["LogsIndexFilter"]:
        return typing.cast(typing.List["LogsIndexFilter"], jsii.get(self, "filterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dailyLimitInput")
    def daily_limit_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "dailyLimitInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="disableDailyLimitInput")
    def disable_daily_limit_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "disableDailyLimitInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="exclusionFilterInput")
    def exclusion_filter_input(
        self,
    ) -> typing.Optional[typing.List["LogsIndexExclusionFilter"]]:
        return typing.cast(typing.Optional[typing.List["LogsIndexExclusionFilter"]], jsii.get(self, "exclusionFilterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="retentionDaysInput")
    def retention_days_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "retentionDaysInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dailyLimit")
    def daily_limit(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "dailyLimit"))

    @daily_limit.setter
    def daily_limit(self, value: jsii.Number) -> None:
        jsii.set(self, "dailyLimit", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="disableDailyLimit")
    def disable_daily_limit(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "disableDailyLimit"))

    @disable_daily_limit.setter
    def disable_daily_limit(self, value: builtins.bool) -> None:
        jsii.set(self, "disableDailyLimit", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="exclusionFilter")
    def exclusion_filter(self) -> typing.List["LogsIndexExclusionFilter"]:
        return typing.cast(typing.List["LogsIndexExclusionFilter"], jsii.get(self, "exclusionFilter"))

    @exclusion_filter.setter
    def exclusion_filter(self, value: typing.List["LogsIndexExclusionFilter"]) -> None:
        jsii.set(self, "exclusionFilter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filter")
    def filter(self) -> typing.List["LogsIndexFilter"]:
        return typing.cast(typing.List["LogsIndexFilter"], jsii.get(self, "filter"))

    @filter.setter
    def filter(self, value: typing.List["LogsIndexFilter"]) -> None:
        jsii.set(self, "filter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="retentionDays")
    def retention_days(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "retentionDays"))

    @retention_days.setter
    def retention_days(self, value: jsii.Number) -> None:
        jsii.set(self, "retentionDays", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsIndexConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "filter": "filter",
        "name": "name",
        "daily_limit": "dailyLimit",
        "disable_daily_limit": "disableDailyLimit",
        "exclusion_filter": "exclusionFilter",
        "retention_days": "retentionDays",
    },
)
class LogsIndexConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        filter: typing.Sequence["LogsIndexFilter"],
        name: builtins.str,
        daily_limit: typing.Optional[jsii.Number] = None,
        disable_daily_limit: typing.Optional[builtins.bool] = None,
        exclusion_filter: typing.Optional[typing.Sequence["LogsIndexExclusionFilter"]] = None,
        retention_days: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#filter LogsIndex#filter}
        :param name: The name of the index. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#name LogsIndex#name}
        :param daily_limit: The number of log events you can send in this index per day before you are rate-limited. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#daily_limit LogsIndex#daily_limit}
        :param disable_daily_limit: If true, sets the daily_limit value to null and the index is not limited on a daily basis (any specified daily_limit value in the request is ignored). If false or omitted, the index's current daily_limit is maintained. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#disable_daily_limit LogsIndex#disable_daily_limit}
        :param exclusion_filter: exclusion_filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#exclusion_filter LogsIndex#exclusion_filter}
        :param retention_days: The number of days before logs are deleted from this index. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#retention_days LogsIndex#retention_days}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "filter": filter,
            "name": name,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if daily_limit is not None:
            self._values["daily_limit"] = daily_limit
        if disable_daily_limit is not None:
            self._values["disable_daily_limit"] = disable_daily_limit
        if exclusion_filter is not None:
            self._values["exclusion_filter"] = exclusion_filter
        if retention_days is not None:
            self._values["retention_days"] = retention_days

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def filter(self) -> typing.List["LogsIndexFilter"]:
        '''filter block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#filter LogsIndex#filter}
        '''
        result = self._values.get("filter")
        assert result is not None, "Required property 'filter' is missing"
        return typing.cast(typing.List["LogsIndexFilter"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the index.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#name LogsIndex#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def daily_limit(self) -> typing.Optional[jsii.Number]:
        '''The number of log events you can send in this index per day before you are rate-limited.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#daily_limit LogsIndex#daily_limit}
        '''
        result = self._values.get("daily_limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def disable_daily_limit(self) -> typing.Optional[builtins.bool]:
        '''If true, sets the daily_limit value to null and the index is not limited on a daily basis (any specified daily_limit value in the request is ignored).

        If false or omitted, the index's current daily_limit is maintained.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#disable_daily_limit LogsIndex#disable_daily_limit}
        '''
        result = self._values.get("disable_daily_limit")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exclusion_filter(
        self,
    ) -> typing.Optional[typing.List["LogsIndexExclusionFilter"]]:
        '''exclusion_filter block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#exclusion_filter LogsIndex#exclusion_filter}
        '''
        result = self._values.get("exclusion_filter")
        return typing.cast(typing.Optional[typing.List["LogsIndexExclusionFilter"]], result)

    @builtins.property
    def retention_days(self) -> typing.Optional[jsii.Number]:
        '''The number of days before logs are deleted from this index.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#retention_days LogsIndex#retention_days}
        '''
        result = self._values.get("retention_days")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsIndexConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsIndexExclusionFilter",
    jsii_struct_bases=[],
    name_mapping={"filter": "filter", "is_enabled": "isEnabled", "name": "name"},
)
class LogsIndexExclusionFilter:
    def __init__(
        self,
        *,
        filter: typing.Optional[typing.Sequence["LogsIndexExclusionFilterFilter"]] = None,
        is_enabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#filter LogsIndex#filter}
        :param is_enabled: A boolean stating if the exclusion is active or not. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#is_enabled LogsIndex#is_enabled}
        :param name: The name of the exclusion filter. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#name LogsIndex#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if filter is not None:
            self._values["filter"] = filter
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def filter(self) -> typing.Optional[typing.List["LogsIndexExclusionFilterFilter"]]:
        '''filter block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#filter LogsIndex#filter}
        '''
        result = self._values.get("filter")
        return typing.cast(typing.Optional[typing.List["LogsIndexExclusionFilterFilter"]], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''A boolean stating if the exclusion is active or not.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#is_enabled LogsIndex#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the exclusion filter.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#name LogsIndex#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsIndexExclusionFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsIndexExclusionFilterFilter",
    jsii_struct_bases=[],
    name_mapping={"query": "query", "sample_rate": "sampleRate"},
)
class LogsIndexExclusionFilterFilter:
    def __init__(
        self,
        *,
        query: typing.Optional[builtins.str] = None,
        sample_rate: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param query: Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#query LogsIndex#query}
        :param sample_rate: The fraction of logs excluded by the exclusion filter, when active. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#sample_rate LogsIndex#sample_rate}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if query is not None:
            self._values["query"] = query
        if sample_rate is not None:
            self._values["sample_rate"] = sample_rate

    @builtins.property
    def query(self) -> typing.Optional[builtins.str]:
        '''Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#query LogsIndex#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sample_rate(self) -> typing.Optional[jsii.Number]:
        '''The fraction of logs excluded by the exclusion filter, when active.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#sample_rate LogsIndex#sample_rate}
        '''
        result = self._values.get("sample_rate")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsIndexExclusionFilterFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsIndexFilter",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class LogsIndexFilter:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: Logs filter criteria. Only logs matching this filter criteria are considered for this index. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#query LogsIndex#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''Logs filter criteria. Only logs matching this filter criteria are considered for this index.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index.html#query LogsIndex#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsIndexFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LogsIndexOrder(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.LogsIndexOrder",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/logs_index_order.html datadog_logs_index_order}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        indexes: typing.Sequence[builtins.str],
        name: builtins.str,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/logs_index_order.html datadog_logs_index_order} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param indexes: The index resource list. Logs are tested against the query filter of each index one by one following the order of the list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index_order.html#indexes LogsIndexOrder#indexes}
        :param name: The unique name of the index order resource. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index_order.html#name LogsIndexOrder#name}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = LogsIndexOrderConfig(
            indexes=indexes,
            name=name,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(LogsIndexOrder, self, [scope, id, config])

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="indexesInput")
    def indexes_input(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "indexesInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="indexes")
    def indexes(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "indexes"))

    @indexes.setter
    def indexes(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "indexes", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsIndexOrderConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "indexes": "indexes",
        "name": "name",
    },
)
class LogsIndexOrderConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        indexes: typing.Sequence[builtins.str],
        name: builtins.str,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param indexes: The index resource list. Logs are tested against the query filter of each index one by one following the order of the list. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index_order.html#indexes LogsIndexOrder#indexes}
        :param name: The unique name of the index order resource. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index_order.html#name LogsIndexOrder#name}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "indexes": indexes,
            "name": name,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def indexes(self) -> typing.List[builtins.str]:
        '''The index resource list.

        Logs are tested against the query filter of each index one by one following the order of the list.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index_order.html#indexes LogsIndexOrder#indexes}
        '''
        result = self._values.get("indexes")
        assert result is not None, "Required property 'indexes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The unique name of the index order resource.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_index_order.html#name LogsIndexOrder#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsIndexOrderConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LogsIntegrationPipeline(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.LogsIntegrationPipeline",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/logs_integration_pipeline.html datadog_logs_integration_pipeline}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        is_enabled: typing.Optional[builtins.bool] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/logs_integration_pipeline.html datadog_logs_integration_pipeline} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param is_enabled: Boolean value to enable your pipeline. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_integration_pipeline.html#is_enabled LogsIntegrationPipeline#is_enabled}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = LogsIntegrationPipelineConfig(
            is_enabled=is_enabled,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(LogsIntegrationPipeline, self, [scope, id, config])

    @jsii.member(jsii_name="resetIsEnabled")
    def reset_is_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIsEnabled", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="isEnabledInput")
    def is_enabled_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "isEnabledInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="isEnabled")
    def is_enabled(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "isEnabled"))

    @is_enabled.setter
    def is_enabled(self, value: builtins.bool) -> None:
        jsii.set(self, "isEnabled", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsIntegrationPipelineConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "is_enabled": "isEnabled",
    },
)
class LogsIntegrationPipelineConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        is_enabled: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param is_enabled: Boolean value to enable your pipeline. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_integration_pipeline.html#is_enabled LogsIntegrationPipeline#is_enabled}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if is_enabled is not None:
            self._values["is_enabled"] = is_enabled

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def is_enabled(self) -> typing.Optional[builtins.bool]:
        '''Boolean value to enable your pipeline.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_integration_pipeline.html#is_enabled LogsIntegrationPipeline#is_enabled}
        '''
        result = self._values.get("is_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsIntegrationPipelineConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LogsMetric(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.LogsMetric",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html datadog_logs_metric}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        compute: typing.Sequence["LogsMetricCompute"],
        filter: typing.Sequence["LogsMetricFilter"],
        name: builtins.str,
        group_by: typing.Optional[typing.Sequence["LogsMetricGroupBy"]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html datadog_logs_metric} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param compute: compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#compute LogsMetric#compute}
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#filter LogsMetric#filter}
        :param name: The name of the log-based metric. This field can't be updated after creation. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#name LogsMetric#name}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#group_by LogsMetric#group_by}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = LogsMetricConfig(
            compute=compute,
            filter=filter,
            name=name,
            group_by=group_by,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(LogsMetric, self, [scope, id, config])

    @jsii.member(jsii_name="resetGroupBy")
    def reset_group_by(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGroupBy", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="computeInput")
    def compute_input(self) -> typing.List["LogsMetricCompute"]:
        return typing.cast(typing.List["LogsMetricCompute"], jsii.get(self, "computeInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filterInput")
    def filter_input(self) -> typing.List["LogsMetricFilter"]:
        return typing.cast(typing.List["LogsMetricFilter"], jsii.get(self, "filterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupByInput")
    def group_by_input(self) -> typing.Optional[typing.List["LogsMetricGroupBy"]]:
        return typing.cast(typing.Optional[typing.List["LogsMetricGroupBy"]], jsii.get(self, "groupByInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="compute")
    def compute(self) -> typing.List["LogsMetricCompute"]:
        return typing.cast(typing.List["LogsMetricCompute"], jsii.get(self, "compute"))

    @compute.setter
    def compute(self, value: typing.List["LogsMetricCompute"]) -> None:
        jsii.set(self, "compute", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filter")
    def filter(self) -> typing.List["LogsMetricFilter"]:
        return typing.cast(typing.List["LogsMetricFilter"], jsii.get(self, "filter"))

    @filter.setter
    def filter(self, value: typing.List["LogsMetricFilter"]) -> None:
        jsii.set(self, "filter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupBy")
    def group_by(self) -> typing.List["LogsMetricGroupBy"]:
        return typing.cast(typing.List["LogsMetricGroupBy"], jsii.get(self, "groupBy"))

    @group_by.setter
    def group_by(self, value: typing.List["LogsMetricGroupBy"]) -> None:
        jsii.set(self, "groupBy", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsMetricCompute",
    jsii_struct_bases=[],
    name_mapping={"aggregation_type": "aggregationType", "path": "path"},
)
class LogsMetricCompute:
    def __init__(
        self,
        *,
        aggregation_type: builtins.str,
        path: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param aggregation_type: The type of aggregation to use. This field can't be updated after creation. Valid values are ``count``, ``distribution``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#aggregation_type LogsMetric#aggregation_type}
        :param path: The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#path LogsMetric#path}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aggregation_type": aggregation_type,
        }
        if path is not None:
            self._values["path"] = path

    @builtins.property
    def aggregation_type(self) -> builtins.str:
        '''The type of aggregation to use. This field can't be updated after creation. Valid values are ``count``, ``distribution``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#aggregation_type LogsMetric#aggregation_type}
        '''
        result = self._values.get("aggregation_type")
        assert result is not None, "Required property 'aggregation_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution").

        This field can't be updated after creation.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#path LogsMetric#path}
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsMetricCompute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsMetricConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "compute": "compute",
        "filter": "filter",
        "name": "name",
        "group_by": "groupBy",
    },
)
class LogsMetricConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        compute: typing.Sequence[LogsMetricCompute],
        filter: typing.Sequence["LogsMetricFilter"],
        name: builtins.str,
        group_by: typing.Optional[typing.Sequence["LogsMetricGroupBy"]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param compute: compute block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#compute LogsMetric#compute}
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#filter LogsMetric#filter}
        :param name: The name of the log-based metric. This field can't be updated after creation. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#name LogsMetric#name}
        :param group_by: group_by block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#group_by LogsMetric#group_by}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "compute": compute,
            "filter": filter,
            "name": name,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if group_by is not None:
            self._values["group_by"] = group_by

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def compute(self) -> typing.List[LogsMetricCompute]:
        '''compute block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#compute LogsMetric#compute}
        '''
        result = self._values.get("compute")
        assert result is not None, "Required property 'compute' is missing"
        return typing.cast(typing.List[LogsMetricCompute], result)

    @builtins.property
    def filter(self) -> typing.List["LogsMetricFilter"]:
        '''filter block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#filter LogsMetric#filter}
        '''
        result = self._values.get("filter")
        assert result is not None, "Required property 'filter' is missing"
        return typing.cast(typing.List["LogsMetricFilter"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the log-based metric. This field can't be updated after creation.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#name LogsMetric#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_by(self) -> typing.Optional[typing.List["LogsMetricGroupBy"]]:
        '''group_by block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#group_by LogsMetric#group_by}
        '''
        result = self._values.get("group_by")
        return typing.cast(typing.Optional[typing.List["LogsMetricGroupBy"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsMetricConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsMetricFilter",
    jsii_struct_bases=[],
    name_mapping={"query": "query"},
)
class LogsMetricFilter:
    def __init__(self, *, query: builtins.str) -> None:
        '''
        :param query: The search query - following the log search syntax. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#query LogsMetric#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }

    @builtins.property
    def query(self) -> builtins.str:
        '''The search query - following the log search syntax.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#query LogsMetric#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsMetricFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsMetricGroupBy",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "tag_name": "tagName"},
)
class LogsMetricGroupBy:
    def __init__(self, *, path: builtins.str, tag_name: builtins.str) -> None:
        '''
        :param path: The path to the value the log-based metric will be aggregated over. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#path LogsMetric#path}
        :param tag_name: Name of the tag that gets created. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#tag_name LogsMetric#tag_name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
            "tag_name": tag_name,
        }

    @builtins.property
    def path(self) -> builtins.str:
        '''The path to the value the log-based metric will be aggregated over.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#path LogsMetric#path}
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tag_name(self) -> builtins.str:
        '''Name of the tag that gets created.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_metric.html#tag_name LogsMetric#tag_name}
        '''
        result = self._values.get("tag_name")
        assert result is not None, "Required property 'tag_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsMetricGroupBy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LogsPipelineOrder(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.LogsPipelineOrder",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/logs_pipeline_order.html datadog_logs_pipeline_order}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        name: builtins.str,
        pipelines: typing.Sequence[builtins.str],
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/logs_pipeline_order.html datadog_logs_pipeline_order} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param name: The name attribute in the resource ``datadog_logs_pipeline_order`` needs to be unique. It's recommended to use the same value as the resource name. No related field is available in `Logs Pipeline API <https://docs.datadoghq.com/api/v1/logs-pipelines/#get-pipeline-order>`_. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_pipeline_order.html#name LogsPipelineOrder#name}
        :param pipelines: The pipeline IDs list. The order of pipeline IDs in this attribute defines the overall pipeline order for logs. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_pipeline_order.html#pipelines LogsPipelineOrder#pipelines}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = LogsPipelineOrderConfig(
            name=name,
            pipelines=pipelines,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(LogsPipelineOrder, self, [scope, id, config])

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="pipelinesInput")
    def pipelines_input(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "pipelinesInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="pipelines")
    def pipelines(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "pipelines"))

    @pipelines.setter
    def pipelines(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "pipelines", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.LogsPipelineOrderConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "name": "name",
        "pipelines": "pipelines",
    },
)
class LogsPipelineOrderConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        name: builtins.str,
        pipelines: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param name: The name attribute in the resource ``datadog_logs_pipeline_order`` needs to be unique. It's recommended to use the same value as the resource name. No related field is available in `Logs Pipeline API <https://docs.datadoghq.com/api/v1/logs-pipelines/#get-pipeline-order>`_. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_pipeline_order.html#name LogsPipelineOrder#name}
        :param pipelines: The pipeline IDs list. The order of pipeline IDs in this attribute defines the overall pipeline order for logs. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_pipeline_order.html#pipelines LogsPipelineOrder#pipelines}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "pipelines": pipelines,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name attribute in the resource ``datadog_logs_pipeline_order`` needs to be unique.

        It's recommended to use the same value as the resource name. No related field is available in `Logs Pipeline API <https://docs.datadoghq.com/api/v1/logs-pipelines/#get-pipeline-order>`_.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_pipeline_order.html#name LogsPipelineOrder#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def pipelines(self) -> typing.List[builtins.str]:
        '''The pipeline IDs list. The order of pipeline IDs in this attribute defines the overall pipeline order for logs.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/logs_pipeline_order.html#pipelines LogsPipelineOrder#pipelines}
        '''
        result = self._values.get("pipelines")
        assert result is not None, "Required property 'pipelines' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogsPipelineOrderConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MetricMetadata(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.MetricMetadata",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html datadog_metric_metadata}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        metric: builtins.str,
        description: typing.Optional[builtins.str] = None,
        per_unit: typing.Optional[builtins.str] = None,
        short_name: typing.Optional[builtins.str] = None,
        statsd_interval: typing.Optional[jsii.Number] = None,
        type: typing.Optional[builtins.str] = None,
        unit: typing.Optional[builtins.str] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html datadog_metric_metadata} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param metric: The name of the metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#metric MetricMetadata#metric}
        :param description: A description of the metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#description MetricMetadata#description}
        :param per_unit: Per unit of the metric such as ``second`` in ``bytes per second``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#per_unit MetricMetadata#per_unit}
        :param short_name: A short name of the metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#short_name MetricMetadata#short_name}
        :param statsd_interval: If applicable, statsd flush interval in seconds for the metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#statsd_interval MetricMetadata#statsd_interval}
        :param type: Type of the metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#type MetricMetadata#type}
        :param unit: Primary unit of the metric such as ``byte`` or ``operation``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#unit MetricMetadata#unit}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = MetricMetadataConfig(
            metric=metric,
            description=description,
            per_unit=per_unit,
            short_name=short_name,
            statsd_interval=statsd_interval,
            type=type,
            unit=unit,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(MetricMetadata, self, [scope, id, config])

    @jsii.member(jsii_name="resetDescription")
    def reset_description(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDescription", []))

    @jsii.member(jsii_name="resetPerUnit")
    def reset_per_unit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPerUnit", []))

    @jsii.member(jsii_name="resetShortName")
    def reset_short_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetShortName", []))

    @jsii.member(jsii_name="resetStatsdInterval")
    def reset_statsd_interval(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetStatsdInterval", []))

    @jsii.member(jsii_name="resetType")
    def reset_type(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetType", []))

    @jsii.member(jsii_name="resetUnit")
    def reset_unit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUnit", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="metricInput")
    def metric_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "metricInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="descriptionInput")
    def description_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "descriptionInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="perUnitInput")
    def per_unit_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "perUnitInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="shortNameInput")
    def short_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "shortNameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="statsdIntervalInput")
    def statsd_interval_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "statsdIntervalInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="unitInput")
    def unit_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "unitInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "description"))

    @description.setter
    def description(self, value: builtins.str) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="metric")
    def metric(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "metric"))

    @metric.setter
    def metric(self, value: builtins.str) -> None:
        jsii.set(self, "metric", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="perUnit")
    def per_unit(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "perUnit"))

    @per_unit.setter
    def per_unit(self, value: builtins.str) -> None:
        jsii.set(self, "perUnit", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="shortName")
    def short_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "shortName"))

    @short_name.setter
    def short_name(self, value: builtins.str) -> None:
        jsii.set(self, "shortName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="statsdInterval")
    def statsd_interval(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "statsdInterval"))

    @statsd_interval.setter
    def statsd_interval(self, value: jsii.Number) -> None:
        jsii.set(self, "statsdInterval", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        jsii.set(self, "type", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="unit")
    def unit(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "unit"))

    @unit.setter
    def unit(self, value: builtins.str) -> None:
        jsii.set(self, "unit", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.MetricMetadataConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "metric": "metric",
        "description": "description",
        "per_unit": "perUnit",
        "short_name": "shortName",
        "statsd_interval": "statsdInterval",
        "type": "type",
        "unit": "unit",
    },
)
class MetricMetadataConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        metric: builtins.str,
        description: typing.Optional[builtins.str] = None,
        per_unit: typing.Optional[builtins.str] = None,
        short_name: typing.Optional[builtins.str] = None,
        statsd_interval: typing.Optional[jsii.Number] = None,
        type: typing.Optional[builtins.str] = None,
        unit: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param metric: The name of the metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#metric MetricMetadata#metric}
        :param description: A description of the metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#description MetricMetadata#description}
        :param per_unit: Per unit of the metric such as ``second`` in ``bytes per second``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#per_unit MetricMetadata#per_unit}
        :param short_name: A short name of the metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#short_name MetricMetadata#short_name}
        :param statsd_interval: If applicable, statsd flush interval in seconds for the metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#statsd_interval MetricMetadata#statsd_interval}
        :param type: Type of the metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#type MetricMetadata#type}
        :param unit: Primary unit of the metric such as ``byte`` or ``operation``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#unit MetricMetadata#unit}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "metric": metric,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if description is not None:
            self._values["description"] = description
        if per_unit is not None:
            self._values["per_unit"] = per_unit
        if short_name is not None:
            self._values["short_name"] = short_name
        if statsd_interval is not None:
            self._values["statsd_interval"] = statsd_interval
        if type is not None:
            self._values["type"] = type
        if unit is not None:
            self._values["unit"] = unit

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def metric(self) -> builtins.str:
        '''The name of the metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#metric MetricMetadata#metric}
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description of the metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#description MetricMetadata#description}
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def per_unit(self) -> typing.Optional[builtins.str]:
        '''Per unit of the metric such as ``second`` in ``bytes per second``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#per_unit MetricMetadata#per_unit}
        '''
        result = self._values.get("per_unit")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def short_name(self) -> typing.Optional[builtins.str]:
        '''A short name of the metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#short_name MetricMetadata#short_name}
        '''
        result = self._values.get("short_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def statsd_interval(self) -> typing.Optional[jsii.Number]:
        '''If applicable, statsd flush interval in seconds for the metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#statsd_interval MetricMetadata#statsd_interval}
        '''
        result = self._values.get("statsd_interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''Type of the metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#type MetricMetadata#type}
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def unit(self) -> typing.Optional[builtins.str]:
        '''Primary unit of the metric such as ``byte`` or ``operation``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_metadata.html#unit MetricMetadata#unit}
        '''
        result = self._values.get("unit")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MetricMetadataConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MetricTagConfiguration(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.MetricTagConfiguration",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html datadog_metric_tag_configuration}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        metric_name: builtins.str,
        metric_type: builtins.str,
        tags: typing.Sequence[builtins.str],
        include_percentiles: typing.Optional[builtins.bool] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html datadog_metric_tag_configuration} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param metric_name: The metric name for this resource. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#metric_name MetricTagConfiguration#metric_name}
        :param metric_type: The metric's type. This field can't be updated after creation. Valid values are ``gauge``, ``count``, ``rate``, ``distribution``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#metric_type MetricTagConfiguration#metric_type}
        :param tags: A list of tag keys that will be queryable for your metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#tags MetricTagConfiguration#tags}
        :param include_percentiles: Toggle to include/exclude percentiles for a distribution metric. Defaults to false. Can only be applied to metrics that have a metric_type of distribution. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#include_percentiles MetricTagConfiguration#include_percentiles}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = MetricTagConfigurationConfig(
            metric_name=metric_name,
            metric_type=metric_type,
            tags=tags,
            include_percentiles=include_percentiles,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(MetricTagConfiguration, self, [scope, id, config])

    @jsii.member(jsii_name="resetIncludePercentiles")
    def reset_include_percentiles(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIncludePercentiles", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="metricNameInput")
    def metric_name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "metricNameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="metricTypeInput")
    def metric_type_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "metricTypeInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="includePercentilesInput")
    def include_percentiles_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "includePercentilesInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="includePercentiles")
    def include_percentiles(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "includePercentiles"))

    @include_percentiles.setter
    def include_percentiles(self, value: builtins.bool) -> None:
        jsii.set(self, "includePercentiles", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="metricName")
    def metric_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "metricName"))

    @metric_name.setter
    def metric_name(self, value: builtins.str) -> None:
        jsii.set(self, "metricName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="metricType")
    def metric_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "metricType"))

    @metric_type.setter
    def metric_type(self, value: builtins.str) -> None:
        jsii.set(self, "metricType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "tags", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.MetricTagConfigurationConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "metric_name": "metricName",
        "metric_type": "metricType",
        "tags": "tags",
        "include_percentiles": "includePercentiles",
    },
)
class MetricTagConfigurationConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        metric_name: builtins.str,
        metric_type: builtins.str,
        tags: typing.Sequence[builtins.str],
        include_percentiles: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param metric_name: The metric name for this resource. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#metric_name MetricTagConfiguration#metric_name}
        :param metric_type: The metric's type. This field can't be updated after creation. Valid values are ``gauge``, ``count``, ``rate``, ``distribution``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#metric_type MetricTagConfiguration#metric_type}
        :param tags: A list of tag keys that will be queryable for your metric. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#tags MetricTagConfiguration#tags}
        :param include_percentiles: Toggle to include/exclude percentiles for a distribution metric. Defaults to false. Can only be applied to metrics that have a metric_type of distribution. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#include_percentiles MetricTagConfiguration#include_percentiles}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "metric_name": metric_name,
            "metric_type": metric_type,
            "tags": tags,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if include_percentiles is not None:
            self._values["include_percentiles"] = include_percentiles

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def metric_name(self) -> builtins.str:
        '''The metric name for this resource.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#metric_name MetricTagConfiguration#metric_name}
        '''
        result = self._values.get("metric_name")
        assert result is not None, "Required property 'metric_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric_type(self) -> builtins.str:
        '''The metric's type. This field can't be updated after creation. Valid values are ``gauge``, ``count``, ``rate``, ``distribution``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#metric_type MetricTagConfiguration#metric_type}
        '''
        result = self._values.get("metric_type")
        assert result is not None, "Required property 'metric_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.List[builtins.str]:
        '''A list of tag keys that will be queryable for your metric.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#tags MetricTagConfiguration#tags}
        '''
        result = self._values.get("tags")
        assert result is not None, "Required property 'tags' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def include_percentiles(self) -> typing.Optional[builtins.bool]:
        '''Toggle to include/exclude percentiles for a distribution metric.

        Defaults to false. Can only be applied to metrics that have a metric_type of distribution.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/metric_tag_configuration.html#include_percentiles MetricTagConfiguration#include_percentiles}
        '''
        result = self._values.get("include_percentiles")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MetricTagConfigurationConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Monitor(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.Monitor",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html datadog_monitor}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        message: builtins.str,
        name: builtins.str,
        query: builtins.str,
        type: builtins.str,
        enable_logs_sample: typing.Optional[builtins.bool] = None,
        escalation_message: typing.Optional[builtins.str] = None,
        evaluation_delay: typing.Optional[jsii.Number] = None,
        force_delete: typing.Optional[builtins.bool] = None,
        groupby_simple_monitor: typing.Optional[builtins.bool] = None,
        include_tags: typing.Optional[builtins.bool] = None,
        locked: typing.Optional[builtins.bool] = None,
        monitor_thresholds: typing.Optional[typing.Sequence["MonitorMonitorThresholds"]] = None,
        monitor_threshold_windows: typing.Optional[typing.Sequence["MonitorMonitorThresholdWindows"]] = None,
        new_host_delay: typing.Optional[jsii.Number] = None,
        no_data_timeframe: typing.Optional[jsii.Number] = None,
        notify_audit: typing.Optional[builtins.bool] = None,
        notify_no_data: typing.Optional[builtins.bool] = None,
        priority: typing.Optional[jsii.Number] = None,
        renotify_interval: typing.Optional[jsii.Number] = None,
        require_full_window: typing.Optional[builtins.bool] = None,
        restricted_roles: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        timeout_h: typing.Optional[jsii.Number] = None,
        validate: typing.Optional[builtins.bool] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html datadog_monitor} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param message: A message to include with notifications for this monitor. Email notifications can be sent to specific users by using the same ``@username`` notation as events. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#message Monitor#message}
        :param name: Name of Datadog monitor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#name Monitor#name}
        :param query: The monitor query to notify on. Note this is not the same query you see in the UI and the syntax is different depending on the monitor type, please see the `API Reference <https://docs.datadoghq.com/api/v1/monitors/#create-a-monitor>`_ for details. ``terraform plan`` will validate query contents unless ``validate`` is set to ``false``. *Note:** APM latency data is now available as Distribution Metrics. Existing monitors have been migrated automatically but all terraformed monitors can still use the existing metrics. We strongly recommend updating monitor definitions to query the new metrics. To learn more, or to see examples of how to update your terraform definitions to utilize the new distribution metrics, see the `detailed doc <https://docs.datadoghq.com/tracing/guide/ddsketch_trace_metrics/>`_. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#query Monitor#query}
        :param type: The type of the monitor. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API `documentation page <https://docs.datadoghq.com/api/v1/monitors/#create-a-monitor>`_. Note: The monitor type cannot be changed after a monitor is created. Valid values are ``composite``, ``event alert``, ``log alert``, ``metric alert``, ``process alert``, ``query alert``, ``rum alert``, ``service check``, ``synthetics alert``, ``trace-analytics alert``, ``slo alert``, ``event-v2 alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#type Monitor#type}
        :param enable_logs_sample: A boolean indicating whether or not to include a list of log values which triggered the alert. This is only used by log monitors. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#enable_logs_sample Monitor#enable_logs_sample}
        :param escalation_message: A message to include with a re-notification. Supports the ``@username`` notification allowed elsewhere. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#escalation_message Monitor#escalation_message}
        :param evaluation_delay: (Only applies to metric alert) Time (in seconds) to delay evaluation, as a non-negative integer. For example, if the value is set to ``300`` (5min), the ``timeframe`` is set to ``last_5m`` and the time is 7:00, the monitor will evaluate data from 6:50 to 6:55. This is useful for AWS CloudWatch and other backfilled metrics to ensure the monitor will always have data during evaluation. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#evaluation_delay Monitor#evaluation_delay}
        :param force_delete: A boolean indicating whether this monitor can be deleted even if its referenced by other resources (e.g. SLO, composite monitor). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#force_delete Monitor#force_delete}
        :param groupby_simple_monitor: Whether or not to trigger one alert if any source breaches a threshold. This is only used by log monitors. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#groupby_simple_monitor Monitor#groupby_simple_monitor}
        :param include_tags: A boolean indicating whether notifications from this monitor automatically insert its triggering tags into the title. Defaults to ``true``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#include_tags Monitor#include_tags}
        :param locked: A boolean indicating whether changes to to this monitor should be restricted to the creator or admins. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#locked Monitor#locked}
        :param monitor_thresholds: monitor_thresholds block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#monitor_thresholds Monitor#monitor_thresholds}
        :param monitor_threshold_windows: monitor_threshold_windows block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#monitor_threshold_windows Monitor#monitor_threshold_windows}
        :param new_host_delay: Time (in seconds) to allow a host to boot and applications to fully start before starting the evaluation of monitor results. Should be a non negative integer. Defaults to ``300``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#new_host_delay Monitor#new_host_delay}
        :param no_data_timeframe: The number of minutes before a monitor will notify when data stops reporting. Provider defaults to 10 minutes. We recommend at least 2x the monitor timeframe for metric alerts or 2 minutes for service checks. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#no_data_timeframe Monitor#no_data_timeframe}
        :param notify_audit: A boolean indicating whether tagged users will be notified on changes to this monitor. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#notify_audit Monitor#notify_audit}
        :param notify_no_data: A boolean indicating whether this monitor will notify when data stops reporting. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#notify_no_data Monitor#notify_no_data}
        :param priority: Integer from 1 (high) to 5 (low) indicating alert severity. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#priority Monitor#priority}
        :param renotify_interval: The number of minutes after the last notification before a monitor will re-notify on the current status. It will only re-notify if it's not resolved. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#renotify_interval Monitor#renotify_interval}
        :param require_full_window: A boolean indicating whether this monitor needs a full window of data before it's evaluated. We highly recommend you set this to ``false`` for sparse metrics, otherwise some evaluations will be skipped. Default: ``true`` for ``on average``, ``at all times`` and ``in total`` aggregation. ``false`` otherwise. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#require_full_window Monitor#require_full_window}
        :param restricted_roles: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#restricted_roles Monitor#restricted_roles}.
        :param tags: A list of tags to associate with your monitor. This can help you categorize and filter monitors in the manage monitors page of the UI. Note: it's not currently possible to filter by these tags when querying via the API Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#tags Monitor#tags}
        :param timeout_h: The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#timeout_h Monitor#timeout_h}
        :param validate: If set to ``false``, skip the validation call done during plan. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#validate Monitor#validate}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = MonitorConfig(
            message=message,
            name=name,
            query=query,
            type=type,
            enable_logs_sample=enable_logs_sample,
            escalation_message=escalation_message,
            evaluation_delay=evaluation_delay,
            force_delete=force_delete,
            groupby_simple_monitor=groupby_simple_monitor,
            include_tags=include_tags,
            locked=locked,
            monitor_thresholds=monitor_thresholds,
            monitor_threshold_windows=monitor_threshold_windows,
            new_host_delay=new_host_delay,
            no_data_timeframe=no_data_timeframe,
            notify_audit=notify_audit,
            notify_no_data=notify_no_data,
            priority=priority,
            renotify_interval=renotify_interval,
            require_full_window=require_full_window,
            restricted_roles=restricted_roles,
            tags=tags,
            timeout_h=timeout_h,
            validate=validate,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(Monitor, self, [scope, id, config])

    @jsii.member(jsii_name="resetEnableLogsSample")
    def reset_enable_logs_sample(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnableLogsSample", []))

    @jsii.member(jsii_name="resetEscalationMessage")
    def reset_escalation_message(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEscalationMessage", []))

    @jsii.member(jsii_name="resetEvaluationDelay")
    def reset_evaluation_delay(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEvaluationDelay", []))

    @jsii.member(jsii_name="resetForceDelete")
    def reset_force_delete(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetForceDelete", []))

    @jsii.member(jsii_name="resetGroupbySimpleMonitor")
    def reset_groupby_simple_monitor(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGroupbySimpleMonitor", []))

    @jsii.member(jsii_name="resetIncludeTags")
    def reset_include_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIncludeTags", []))

    @jsii.member(jsii_name="resetLocked")
    def reset_locked(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocked", []))

    @jsii.member(jsii_name="resetMonitorThresholds")
    def reset_monitor_thresholds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMonitorThresholds", []))

    @jsii.member(jsii_name="resetMonitorThresholdWindows")
    def reset_monitor_threshold_windows(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMonitorThresholdWindows", []))

    @jsii.member(jsii_name="resetNewHostDelay")
    def reset_new_host_delay(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNewHostDelay", []))

    @jsii.member(jsii_name="resetNoDataTimeframe")
    def reset_no_data_timeframe(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNoDataTimeframe", []))

    @jsii.member(jsii_name="resetNotifyAudit")
    def reset_notify_audit(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNotifyAudit", []))

    @jsii.member(jsii_name="resetNotifyNoData")
    def reset_notify_no_data(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetNotifyNoData", []))

    @jsii.member(jsii_name="resetPriority")
    def reset_priority(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPriority", []))

    @jsii.member(jsii_name="resetRenotifyInterval")
    def reset_renotify_interval(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRenotifyInterval", []))

    @jsii.member(jsii_name="resetRequireFullWindow")
    def reset_require_full_window(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRequireFullWindow", []))

    @jsii.member(jsii_name="resetRestrictedRoles")
    def reset_restricted_roles(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRestrictedRoles", []))

    @jsii.member(jsii_name="resetTags")
    def reset_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTags", []))

    @jsii.member(jsii_name="resetTimeoutH")
    def reset_timeout_h(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeoutH", []))

    @jsii.member(jsii_name="resetValidate")
    def reset_validate(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValidate", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="messageInput")
    def message_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "messageInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="queryInput")
    def query_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "queryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "typeInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enableLogsSampleInput")
    def enable_logs_sample_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "enableLogsSampleInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="escalationMessageInput")
    def escalation_message_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "escalationMessageInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="evaluationDelayInput")
    def evaluation_delay_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "evaluationDelayInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="forceDeleteInput")
    def force_delete_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "forceDeleteInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupbySimpleMonitorInput")
    def groupby_simple_monitor_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "groupbySimpleMonitorInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="includeTagsInput")
    def include_tags_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "includeTagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="lockedInput")
    def locked_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "lockedInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorThresholdsInput")
    def monitor_thresholds_input(
        self,
    ) -> typing.Optional[typing.List["MonitorMonitorThresholds"]]:
        return typing.cast(typing.Optional[typing.List["MonitorMonitorThresholds"]], jsii.get(self, "monitorThresholdsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorThresholdWindowsInput")
    def monitor_threshold_windows_input(
        self,
    ) -> typing.Optional[typing.List["MonitorMonitorThresholdWindows"]]:
        return typing.cast(typing.Optional[typing.List["MonitorMonitorThresholdWindows"]], jsii.get(self, "monitorThresholdWindowsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="newHostDelayInput")
    def new_host_delay_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "newHostDelayInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="noDataTimeframeInput")
    def no_data_timeframe_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "noDataTimeframeInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="notifyAuditInput")
    def notify_audit_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "notifyAuditInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="notifyNoDataInput")
    def notify_no_data_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "notifyNoDataInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="priorityInput")
    def priority_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "priorityInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="renotifyIntervalInput")
    def renotify_interval_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "renotifyIntervalInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requireFullWindowInput")
    def require_full_window_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "requireFullWindowInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="restrictedRolesInput")
    def restricted_roles_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "restrictedRolesInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="timeoutHInput")
    def timeout_h_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "timeoutHInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="validateInput")
    def validate_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "validateInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enableLogsSample")
    def enable_logs_sample(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enableLogsSample"))

    @enable_logs_sample.setter
    def enable_logs_sample(self, value: builtins.bool) -> None:
        jsii.set(self, "enableLogsSample", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="escalationMessage")
    def escalation_message(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "escalationMessage"))

    @escalation_message.setter
    def escalation_message(self, value: builtins.str) -> None:
        jsii.set(self, "escalationMessage", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="evaluationDelay")
    def evaluation_delay(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "evaluationDelay"))

    @evaluation_delay.setter
    def evaluation_delay(self, value: jsii.Number) -> None:
        jsii.set(self, "evaluationDelay", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="forceDelete")
    def force_delete(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "forceDelete"))

    @force_delete.setter
    def force_delete(self, value: builtins.bool) -> None:
        jsii.set(self, "forceDelete", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupbySimpleMonitor")
    def groupby_simple_monitor(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "groupbySimpleMonitor"))

    @groupby_simple_monitor.setter
    def groupby_simple_monitor(self, value: builtins.bool) -> None:
        jsii.set(self, "groupbySimpleMonitor", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="includeTags")
    def include_tags(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "includeTags"))

    @include_tags.setter
    def include_tags(self, value: builtins.bool) -> None:
        jsii.set(self, "includeTags", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="locked")
    def locked(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "locked"))

    @locked.setter
    def locked(self, value: builtins.bool) -> None:
        jsii.set(self, "locked", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="message")
    def message(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "message"))

    @message.setter
    def message(self, value: builtins.str) -> None:
        jsii.set(self, "message", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorThresholds")
    def monitor_thresholds(self) -> typing.List["MonitorMonitorThresholds"]:
        return typing.cast(typing.List["MonitorMonitorThresholds"], jsii.get(self, "monitorThresholds"))

    @monitor_thresholds.setter
    def monitor_thresholds(
        self,
        value: typing.List["MonitorMonitorThresholds"],
    ) -> None:
        jsii.set(self, "monitorThresholds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorThresholdWindows")
    def monitor_threshold_windows(
        self,
    ) -> typing.List["MonitorMonitorThresholdWindows"]:
        return typing.cast(typing.List["MonitorMonitorThresholdWindows"], jsii.get(self, "monitorThresholdWindows"))

    @monitor_threshold_windows.setter
    def monitor_threshold_windows(
        self,
        value: typing.List["MonitorMonitorThresholdWindows"],
    ) -> None:
        jsii.set(self, "monitorThresholdWindows", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="newHostDelay")
    def new_host_delay(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "newHostDelay"))

    @new_host_delay.setter
    def new_host_delay(self, value: jsii.Number) -> None:
        jsii.set(self, "newHostDelay", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="noDataTimeframe")
    def no_data_timeframe(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "noDataTimeframe"))

    @no_data_timeframe.setter
    def no_data_timeframe(self, value: jsii.Number) -> None:
        jsii.set(self, "noDataTimeframe", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="notifyAudit")
    def notify_audit(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "notifyAudit"))

    @notify_audit.setter
    def notify_audit(self, value: builtins.bool) -> None:
        jsii.set(self, "notifyAudit", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="notifyNoData")
    def notify_no_data(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "notifyNoData"))

    @notify_no_data.setter
    def notify_no_data(self, value: builtins.bool) -> None:
        jsii.set(self, "notifyNoData", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="priority")
    def priority(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "priority"))

    @priority.setter
    def priority(self, value: jsii.Number) -> None:
        jsii.set(self, "priority", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="query")
    def query(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "query"))

    @query.setter
    def query(self, value: builtins.str) -> None:
        jsii.set(self, "query", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="renotifyInterval")
    def renotify_interval(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "renotifyInterval"))

    @renotify_interval.setter
    def renotify_interval(self, value: jsii.Number) -> None:
        jsii.set(self, "renotifyInterval", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requireFullWindow")
    def require_full_window(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "requireFullWindow"))

    @require_full_window.setter
    def require_full_window(self, value: builtins.bool) -> None:
        jsii.set(self, "requireFullWindow", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="restrictedRoles")
    def restricted_roles(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "restrictedRoles"))

    @restricted_roles.setter
    def restricted_roles(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "restrictedRoles", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "tags", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="timeoutH")
    def timeout_h(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timeoutH"))

    @timeout_h.setter
    def timeout_h(self, value: jsii.Number) -> None:
        jsii.set(self, "timeoutH", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        jsii.set(self, "type", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="validate")
    def validate(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "validate"))

    @validate.setter
    def validate(self, value: builtins.bool) -> None:
        jsii.set(self, "validate", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.MonitorConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "message": "message",
        "name": "name",
        "query": "query",
        "type": "type",
        "enable_logs_sample": "enableLogsSample",
        "escalation_message": "escalationMessage",
        "evaluation_delay": "evaluationDelay",
        "force_delete": "forceDelete",
        "groupby_simple_monitor": "groupbySimpleMonitor",
        "include_tags": "includeTags",
        "locked": "locked",
        "monitor_thresholds": "monitorThresholds",
        "monitor_threshold_windows": "monitorThresholdWindows",
        "new_host_delay": "newHostDelay",
        "no_data_timeframe": "noDataTimeframe",
        "notify_audit": "notifyAudit",
        "notify_no_data": "notifyNoData",
        "priority": "priority",
        "renotify_interval": "renotifyInterval",
        "require_full_window": "requireFullWindow",
        "restricted_roles": "restrictedRoles",
        "tags": "tags",
        "timeout_h": "timeoutH",
        "validate": "validate",
    },
)
class MonitorConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        message: builtins.str,
        name: builtins.str,
        query: builtins.str,
        type: builtins.str,
        enable_logs_sample: typing.Optional[builtins.bool] = None,
        escalation_message: typing.Optional[builtins.str] = None,
        evaluation_delay: typing.Optional[jsii.Number] = None,
        force_delete: typing.Optional[builtins.bool] = None,
        groupby_simple_monitor: typing.Optional[builtins.bool] = None,
        include_tags: typing.Optional[builtins.bool] = None,
        locked: typing.Optional[builtins.bool] = None,
        monitor_thresholds: typing.Optional[typing.Sequence["MonitorMonitorThresholds"]] = None,
        monitor_threshold_windows: typing.Optional[typing.Sequence["MonitorMonitorThresholdWindows"]] = None,
        new_host_delay: typing.Optional[jsii.Number] = None,
        no_data_timeframe: typing.Optional[jsii.Number] = None,
        notify_audit: typing.Optional[builtins.bool] = None,
        notify_no_data: typing.Optional[builtins.bool] = None,
        priority: typing.Optional[jsii.Number] = None,
        renotify_interval: typing.Optional[jsii.Number] = None,
        require_full_window: typing.Optional[builtins.bool] = None,
        restricted_roles: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        timeout_h: typing.Optional[jsii.Number] = None,
        validate: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param message: A message to include with notifications for this monitor. Email notifications can be sent to specific users by using the same ``@username`` notation as events. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#message Monitor#message}
        :param name: Name of Datadog monitor. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#name Monitor#name}
        :param query: The monitor query to notify on. Note this is not the same query you see in the UI and the syntax is different depending on the monitor type, please see the `API Reference <https://docs.datadoghq.com/api/v1/monitors/#create-a-monitor>`_ for details. ``terraform plan`` will validate query contents unless ``validate`` is set to ``false``. *Note:** APM latency data is now available as Distribution Metrics. Existing monitors have been migrated automatically but all terraformed monitors can still use the existing metrics. We strongly recommend updating monitor definitions to query the new metrics. To learn more, or to see examples of how to update your terraform definitions to utilize the new distribution metrics, see the `detailed doc <https://docs.datadoghq.com/tracing/guide/ddsketch_trace_metrics/>`_. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#query Monitor#query}
        :param type: The type of the monitor. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API `documentation page <https://docs.datadoghq.com/api/v1/monitors/#create-a-monitor>`_. Note: The monitor type cannot be changed after a monitor is created. Valid values are ``composite``, ``event alert``, ``log alert``, ``metric alert``, ``process alert``, ``query alert``, ``rum alert``, ``service check``, ``synthetics alert``, ``trace-analytics alert``, ``slo alert``, ``event-v2 alert``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#type Monitor#type}
        :param enable_logs_sample: A boolean indicating whether or not to include a list of log values which triggered the alert. This is only used by log monitors. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#enable_logs_sample Monitor#enable_logs_sample}
        :param escalation_message: A message to include with a re-notification. Supports the ``@username`` notification allowed elsewhere. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#escalation_message Monitor#escalation_message}
        :param evaluation_delay: (Only applies to metric alert) Time (in seconds) to delay evaluation, as a non-negative integer. For example, if the value is set to ``300`` (5min), the ``timeframe`` is set to ``last_5m`` and the time is 7:00, the monitor will evaluate data from 6:50 to 6:55. This is useful for AWS CloudWatch and other backfilled metrics to ensure the monitor will always have data during evaluation. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#evaluation_delay Monitor#evaluation_delay}
        :param force_delete: A boolean indicating whether this monitor can be deleted even if its referenced by other resources (e.g. SLO, composite monitor). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#force_delete Monitor#force_delete}
        :param groupby_simple_monitor: Whether or not to trigger one alert if any source breaches a threshold. This is only used by log monitors. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#groupby_simple_monitor Monitor#groupby_simple_monitor}
        :param include_tags: A boolean indicating whether notifications from this monitor automatically insert its triggering tags into the title. Defaults to ``true``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#include_tags Monitor#include_tags}
        :param locked: A boolean indicating whether changes to to this monitor should be restricted to the creator or admins. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#locked Monitor#locked}
        :param monitor_thresholds: monitor_thresholds block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#monitor_thresholds Monitor#monitor_thresholds}
        :param monitor_threshold_windows: monitor_threshold_windows block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#monitor_threshold_windows Monitor#monitor_threshold_windows}
        :param new_host_delay: Time (in seconds) to allow a host to boot and applications to fully start before starting the evaluation of monitor results. Should be a non negative integer. Defaults to ``300``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#new_host_delay Monitor#new_host_delay}
        :param no_data_timeframe: The number of minutes before a monitor will notify when data stops reporting. Provider defaults to 10 minutes. We recommend at least 2x the monitor timeframe for metric alerts or 2 minutes for service checks. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#no_data_timeframe Monitor#no_data_timeframe}
        :param notify_audit: A boolean indicating whether tagged users will be notified on changes to this monitor. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#notify_audit Monitor#notify_audit}
        :param notify_no_data: A boolean indicating whether this monitor will notify when data stops reporting. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#notify_no_data Monitor#notify_no_data}
        :param priority: Integer from 1 (high) to 5 (low) indicating alert severity. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#priority Monitor#priority}
        :param renotify_interval: The number of minutes after the last notification before a monitor will re-notify on the current status. It will only re-notify if it's not resolved. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#renotify_interval Monitor#renotify_interval}
        :param require_full_window: A boolean indicating whether this monitor needs a full window of data before it's evaluated. We highly recommend you set this to ``false`` for sparse metrics, otherwise some evaluations will be skipped. Default: ``true`` for ``on average``, ``at all times`` and ``in total`` aggregation. ``false`` otherwise. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#require_full_window Monitor#require_full_window}
        :param restricted_roles: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#restricted_roles Monitor#restricted_roles}.
        :param tags: A list of tags to associate with your monitor. This can help you categorize and filter monitors in the manage monitors page of the UI. Note: it's not currently possible to filter by these tags when querying via the API Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#tags Monitor#tags}
        :param timeout_h: The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#timeout_h Monitor#timeout_h}
        :param validate: If set to ``false``, skip the validation call done during plan. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#validate Monitor#validate}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "message": message,
            "name": name,
            "query": query,
            "type": type,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if enable_logs_sample is not None:
            self._values["enable_logs_sample"] = enable_logs_sample
        if escalation_message is not None:
            self._values["escalation_message"] = escalation_message
        if evaluation_delay is not None:
            self._values["evaluation_delay"] = evaluation_delay
        if force_delete is not None:
            self._values["force_delete"] = force_delete
        if groupby_simple_monitor is not None:
            self._values["groupby_simple_monitor"] = groupby_simple_monitor
        if include_tags is not None:
            self._values["include_tags"] = include_tags
        if locked is not None:
            self._values["locked"] = locked
        if monitor_thresholds is not None:
            self._values["monitor_thresholds"] = monitor_thresholds
        if monitor_threshold_windows is not None:
            self._values["monitor_threshold_windows"] = monitor_threshold_windows
        if new_host_delay is not None:
            self._values["new_host_delay"] = new_host_delay
        if no_data_timeframe is not None:
            self._values["no_data_timeframe"] = no_data_timeframe
        if notify_audit is not None:
            self._values["notify_audit"] = notify_audit
        if notify_no_data is not None:
            self._values["notify_no_data"] = notify_no_data
        if priority is not None:
            self._values["priority"] = priority
        if renotify_interval is not None:
            self._values["renotify_interval"] = renotify_interval
        if require_full_window is not None:
            self._values["require_full_window"] = require_full_window
        if restricted_roles is not None:
            self._values["restricted_roles"] = restricted_roles
        if tags is not None:
            self._values["tags"] = tags
        if timeout_h is not None:
            self._values["timeout_h"] = timeout_h
        if validate is not None:
            self._values["validate"] = validate

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def message(self) -> builtins.str:
        '''A message to include with notifications for this monitor.

        Email notifications can be sent to specific users by using the same ``@username`` notation as events.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#message Monitor#message}
        '''
        result = self._values.get("message")
        assert result is not None, "Required property 'message' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of Datadog monitor.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#name Monitor#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''The monitor query to notify on.

        Note this is not the same query you see in the UI and the syntax is different depending on the monitor type, please see the `API Reference <https://docs.datadoghq.com/api/v1/monitors/#create-a-monitor>`_ for details. ``terraform plan`` will validate query contents unless ``validate`` is set to ``false``.

        *Note:** APM latency data is now available as Distribution Metrics. Existing monitors have been migrated automatically but all terraformed monitors can still use the existing metrics. We strongly recommend updating monitor definitions to query the new metrics. To learn more, or to see examples of how to update your terraform definitions to utilize the new distribution metrics, see the `detailed doc <https://docs.datadoghq.com/tracing/guide/ddsketch_trace_metrics/>`_.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#query Monitor#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''The type of the monitor.

        The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API `documentation page <https://docs.datadoghq.com/api/v1/monitors/#create-a-monitor>`_. Note: The monitor type cannot be changed after a monitor is created. Valid values are ``composite``, ``event alert``, ``log alert``, ``metric alert``, ``process alert``, ``query alert``, ``rum alert``, ``service check``, ``synthetics alert``, ``trace-analytics alert``, ``slo alert``, ``event-v2 alert``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#type Monitor#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def enable_logs_sample(self) -> typing.Optional[builtins.bool]:
        '''A boolean indicating whether or not to include a list of log values which triggered the alert.

        This is only used by log monitors. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#enable_logs_sample Monitor#enable_logs_sample}
        '''
        result = self._values.get("enable_logs_sample")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def escalation_message(self) -> typing.Optional[builtins.str]:
        '''A message to include with a re-notification. Supports the ``@username`` notification allowed elsewhere.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#escalation_message Monitor#escalation_message}
        '''
        result = self._values.get("escalation_message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluation_delay(self) -> typing.Optional[jsii.Number]:
        '''(Only applies to metric alert) Time (in seconds) to delay evaluation, as a non-negative integer.

        For example, if the value is set to ``300`` (5min), the ``timeframe`` is set to ``last_5m`` and the time is 7:00, the monitor will evaluate data from 6:50 to 6:55. This is useful for AWS CloudWatch and other backfilled metrics to ensure the monitor will always have data during evaluation.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#evaluation_delay Monitor#evaluation_delay}
        '''
        result = self._values.get("evaluation_delay")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def force_delete(self) -> typing.Optional[builtins.bool]:
        '''A boolean indicating whether this monitor can be deleted even if its referenced by other resources (e.g. SLO, composite monitor).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#force_delete Monitor#force_delete}
        '''
        result = self._values.get("force_delete")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def groupby_simple_monitor(self) -> typing.Optional[builtins.bool]:
        '''Whether or not to trigger one alert if any source breaches a threshold.

        This is only used by log monitors. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#groupby_simple_monitor Monitor#groupby_simple_monitor}
        '''
        result = self._values.get("groupby_simple_monitor")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def include_tags(self) -> typing.Optional[builtins.bool]:
        '''A boolean indicating whether notifications from this monitor automatically insert its triggering tags into the title. Defaults to ``true``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#include_tags Monitor#include_tags}
        '''
        result = self._values.get("include_tags")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def locked(self) -> typing.Optional[builtins.bool]:
        '''A boolean indicating whether changes to to this monitor should be restricted to the creator or admins.

        Defaults to ``false``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#locked Monitor#locked}
        '''
        result = self._values.get("locked")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def monitor_thresholds(
        self,
    ) -> typing.Optional[typing.List["MonitorMonitorThresholds"]]:
        '''monitor_thresholds block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#monitor_thresholds Monitor#monitor_thresholds}
        '''
        result = self._values.get("monitor_thresholds")
        return typing.cast(typing.Optional[typing.List["MonitorMonitorThresholds"]], result)

    @builtins.property
    def monitor_threshold_windows(
        self,
    ) -> typing.Optional[typing.List["MonitorMonitorThresholdWindows"]]:
        '''monitor_threshold_windows block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#monitor_threshold_windows Monitor#monitor_threshold_windows}
        '''
        result = self._values.get("monitor_threshold_windows")
        return typing.cast(typing.Optional[typing.List["MonitorMonitorThresholdWindows"]], result)

    @builtins.property
    def new_host_delay(self) -> typing.Optional[jsii.Number]:
        '''Time (in seconds) to allow a host to boot and applications to fully start before starting the evaluation of monitor results.

        Should be a non negative integer. Defaults to ``300``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#new_host_delay Monitor#new_host_delay}
        '''
        result = self._values.get("new_host_delay")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def no_data_timeframe(self) -> typing.Optional[jsii.Number]:
        '''The number of minutes before a monitor will notify when data stops reporting. Provider defaults to 10 minutes.

        We recommend at least 2x the monitor timeframe for metric alerts or 2 minutes for service checks.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#no_data_timeframe Monitor#no_data_timeframe}
        '''
        result = self._values.get("no_data_timeframe")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def notify_audit(self) -> typing.Optional[builtins.bool]:
        '''A boolean indicating whether tagged users will be notified on changes to this monitor. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#notify_audit Monitor#notify_audit}
        '''
        result = self._values.get("notify_audit")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def notify_no_data(self) -> typing.Optional[builtins.bool]:
        '''A boolean indicating whether this monitor will notify when data stops reporting. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#notify_no_data Monitor#notify_no_data}
        '''
        result = self._values.get("notify_no_data")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def priority(self) -> typing.Optional[jsii.Number]:
        '''Integer from 1 (high) to 5 (low) indicating alert severity.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#priority Monitor#priority}
        '''
        result = self._values.get("priority")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def renotify_interval(self) -> typing.Optional[jsii.Number]:
        '''The number of minutes after the last notification before a monitor will re-notify on the current status.

        It will only re-notify if it's not resolved.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#renotify_interval Monitor#renotify_interval}
        '''
        result = self._values.get("renotify_interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def require_full_window(self) -> typing.Optional[builtins.bool]:
        '''A boolean indicating whether this monitor needs a full window of data before it's evaluated.

        We highly recommend you set this to ``false`` for sparse metrics, otherwise some evaluations will be skipped. Default: ``true`` for ``on average``, ``at all times`` and ``in total`` aggregation. ``false`` otherwise.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#require_full_window Monitor#require_full_window}
        '''
        result = self._values.get("require_full_window")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def restricted_roles(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#restricted_roles Monitor#restricted_roles}.'''
        result = self._values.get("restricted_roles")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of tags to associate with your monitor.

        This can help you categorize and filter monitors in the manage monitors page of the UI. Note: it's not currently possible to filter by these tags when querying via the API

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#tags Monitor#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def timeout_h(self) -> typing.Optional[jsii.Number]:
        '''The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#timeout_h Monitor#timeout_h}
        '''
        result = self._values.get("timeout_h")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def validate(self) -> typing.Optional[builtins.bool]:
        '''If set to ``false``, skip the validation call done during plan.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#validate Monitor#validate}
        '''
        result = self._values.get("validate")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MonitorConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.MonitorMonitorThresholdWindows",
    jsii_struct_bases=[],
    name_mapping={
        "recovery_window": "recoveryWindow",
        "trigger_window": "triggerWindow",
    },
)
class MonitorMonitorThresholdWindows:
    def __init__(
        self,
        *,
        recovery_window: typing.Optional[builtins.str] = None,
        trigger_window: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param recovery_window: Describes how long an anomalous metric must be normal before the alert recovers. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#recovery_window Monitor#recovery_window}
        :param trigger_window: Describes how long a metric must be anomalous before an alert triggers. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#trigger_window Monitor#trigger_window}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if recovery_window is not None:
            self._values["recovery_window"] = recovery_window
        if trigger_window is not None:
            self._values["trigger_window"] = trigger_window

    @builtins.property
    def recovery_window(self) -> typing.Optional[builtins.str]:
        '''Describes how long an anomalous metric must be normal before the alert recovers.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#recovery_window Monitor#recovery_window}
        '''
        result = self._values.get("recovery_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def trigger_window(self) -> typing.Optional[builtins.str]:
        '''Describes how long a metric must be anomalous before an alert triggers.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#trigger_window Monitor#trigger_window}
        '''
        result = self._values.get("trigger_window")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MonitorMonitorThresholdWindows(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.MonitorMonitorThresholds",
    jsii_struct_bases=[],
    name_mapping={
        "critical": "critical",
        "critical_recovery": "criticalRecovery",
        "ok": "ok",
        "unknown": "unknown",
        "warning": "warning",
        "warning_recovery": "warningRecovery",
    },
)
class MonitorMonitorThresholds:
    def __init__(
        self,
        *,
        critical: typing.Optional[builtins.str] = None,
        critical_recovery: typing.Optional[builtins.str] = None,
        ok: typing.Optional[builtins.str] = None,
        unknown: typing.Optional[builtins.str] = None,
        warning: typing.Optional[builtins.str] = None,
        warning_recovery: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param critical: The monitor ``CRITICAL`` threshold. Must be a number. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#critical Monitor#critical}
        :param critical_recovery: The monitor ``CRITICAL`` recovery threshold. Must be a number. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#critical_recovery Monitor#critical_recovery}
        :param ok: The monitor ``OK`` threshold. Must be a number. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#ok Monitor#ok}
        :param unknown: The monitor ``UNKNOWN`` threshold. Must be a number. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#unknown Monitor#unknown}
        :param warning: The monitor ``WARNING`` threshold. Must be a number. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#warning Monitor#warning}
        :param warning_recovery: The monitor ``WARNING`` recovery threshold. Must be a number. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#warning_recovery Monitor#warning_recovery}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if critical is not None:
            self._values["critical"] = critical
        if critical_recovery is not None:
            self._values["critical_recovery"] = critical_recovery
        if ok is not None:
            self._values["ok"] = ok
        if unknown is not None:
            self._values["unknown"] = unknown
        if warning is not None:
            self._values["warning"] = warning
        if warning_recovery is not None:
            self._values["warning_recovery"] = warning_recovery

    @builtins.property
    def critical(self) -> typing.Optional[builtins.str]:
        '''The monitor ``CRITICAL`` threshold. Must be a number.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#critical Monitor#critical}
        '''
        result = self._values.get("critical")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def critical_recovery(self) -> typing.Optional[builtins.str]:
        '''The monitor ``CRITICAL`` recovery threshold. Must be a number.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#critical_recovery Monitor#critical_recovery}
        '''
        result = self._values.get("critical_recovery")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ok(self) -> typing.Optional[builtins.str]:
        '''The monitor ``OK`` threshold. Must be a number.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#ok Monitor#ok}
        '''
        result = self._values.get("ok")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def unknown(self) -> typing.Optional[builtins.str]:
        '''The monitor ``UNKNOWN`` threshold. Must be a number.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#unknown Monitor#unknown}
        '''
        result = self._values.get("unknown")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def warning(self) -> typing.Optional[builtins.str]:
        '''The monitor ``WARNING`` threshold. Must be a number.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#warning Monitor#warning}
        '''
        result = self._values.get("warning")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def warning_recovery(self) -> typing.Optional[builtins.str]:
        '''The monitor ``WARNING`` recovery threshold. Must be a number.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/monitor.html#warning_recovery Monitor#warning_recovery}
        '''
        result = self._values.get("warning_recovery")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MonitorMonitorThresholds(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Role(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.Role",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/role.html datadog_role}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        name: builtins.str,
        permission: typing.Optional[typing.Sequence["RolePermission"]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/role.html datadog_role} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param name: Name of the role. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/role.html#name Role#name}
        :param permission: permission block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/role.html#permission Role#permission}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = RoleConfig(
            name=name,
            permission=permission,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(Role, self, [scope, id, config])

    @jsii.member(jsii_name="resetPermission")
    def reset_permission(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPermission", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="userCount")
    def user_count(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "userCount"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="permissionInput")
    def permission_input(self) -> typing.Optional[typing.List["RolePermission"]]:
        return typing.cast(typing.Optional[typing.List["RolePermission"]], jsii.get(self, "permissionInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="permission")
    def permission(self) -> typing.List["RolePermission"]:
        return typing.cast(typing.List["RolePermission"], jsii.get(self, "permission"))

    @permission.setter
    def permission(self, value: typing.List["RolePermission"]) -> None:
        jsii.set(self, "permission", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.RoleConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "name": "name",
        "permission": "permission",
    },
)
class RoleConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        name: builtins.str,
        permission: typing.Optional[typing.Sequence["RolePermission"]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param name: Name of the role. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/role.html#name Role#name}
        :param permission: permission block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/role.html#permission Role#permission}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if permission is not None:
            self._values["permission"] = permission

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the role.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/role.html#name Role#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def permission(self) -> typing.Optional[typing.List["RolePermission"]]:
        '''permission block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/role.html#permission Role#permission}
        '''
        result = self._values.get("permission")
        return typing.cast(typing.Optional[typing.List["RolePermission"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RoleConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.RolePermission",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class RolePermission:
    def __init__(self, *, id: builtins.str) -> None:
        '''
        :param id: ID of the permission to assign. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/role.html#id Role#id}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''ID of the permission to assign.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/role.html#id Role#id}
        '''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RolePermission(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SecurityMonitoringDefaultRule(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.SecurityMonitoringDefaultRule",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html datadog_security_monitoring_default_rule}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        case: typing.Optional[typing.Sequence["SecurityMonitoringDefaultRuleCase"]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        filter: typing.Optional[typing.Sequence["SecurityMonitoringDefaultRuleFilter"]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html datadog_security_monitoring_default_rule} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param case: case block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#case SecurityMonitoringDefaultRule#case}
        :param enabled: Enable the rule. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#enabled SecurityMonitoringDefaultRule#enabled}
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#filter SecurityMonitoringDefaultRule#filter}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = SecurityMonitoringDefaultRuleConfig(
            case=case,
            enabled=enabled,
            filter=filter,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(SecurityMonitoringDefaultRule, self, [scope, id, config])

    @jsii.member(jsii_name="resetCase")
    def reset_case(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCase", []))

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @jsii.member(jsii_name="resetFilter")
    def reset_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFilter", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="caseInput")
    def case_input(
        self,
    ) -> typing.Optional[typing.List["SecurityMonitoringDefaultRuleCase"]]:
        return typing.cast(typing.Optional[typing.List["SecurityMonitoringDefaultRuleCase"]], jsii.get(self, "caseInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "enabledInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filterInput")
    def filter_input(
        self,
    ) -> typing.Optional[typing.List["SecurityMonitoringDefaultRuleFilter"]]:
        return typing.cast(typing.Optional[typing.List["SecurityMonitoringDefaultRuleFilter"]], jsii.get(self, "filterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="case")
    def case(self) -> typing.List["SecurityMonitoringDefaultRuleCase"]:
        return typing.cast(typing.List["SecurityMonitoringDefaultRuleCase"], jsii.get(self, "case"))

    @case.setter
    def case(self, value: typing.List["SecurityMonitoringDefaultRuleCase"]) -> None:
        jsii.set(self, "case", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(self, value: builtins.bool) -> None:
        jsii.set(self, "enabled", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filter")
    def filter(self) -> typing.List["SecurityMonitoringDefaultRuleFilter"]:
        return typing.cast(typing.List["SecurityMonitoringDefaultRuleFilter"], jsii.get(self, "filter"))

    @filter.setter
    def filter(self, value: typing.List["SecurityMonitoringDefaultRuleFilter"]) -> None:
        jsii.set(self, "filter", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SecurityMonitoringDefaultRuleCase",
    jsii_struct_bases=[],
    name_mapping={"notifications": "notifications", "status": "status"},
)
class SecurityMonitoringDefaultRuleCase:
    def __init__(
        self,
        *,
        notifications: typing.Sequence[builtins.str],
        status: builtins.str,
    ) -> None:
        '''
        :param notifications: Notification targets for each rule case. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#notifications SecurityMonitoringDefaultRule#notifications}
        :param status: Status of the rule case to match. Valid values are ``info``, ``low``, ``medium``, ``high``, ``critical``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#status SecurityMonitoringDefaultRule#status}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "notifications": notifications,
            "status": status,
        }

    @builtins.property
    def notifications(self) -> typing.List[builtins.str]:
        '''Notification targets for each rule case.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#notifications SecurityMonitoringDefaultRule#notifications}
        '''
        result = self._values.get("notifications")
        assert result is not None, "Required property 'notifications' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def status(self) -> builtins.str:
        '''Status of the rule case to match. Valid values are ``info``, ``low``, ``medium``, ``high``, ``critical``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#status SecurityMonitoringDefaultRule#status}
        '''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityMonitoringDefaultRuleCase(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SecurityMonitoringDefaultRuleConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "case": "case",
        "enabled": "enabled",
        "filter": "filter",
    },
)
class SecurityMonitoringDefaultRuleConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        case: typing.Optional[typing.Sequence[SecurityMonitoringDefaultRuleCase]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        filter: typing.Optional[typing.Sequence["SecurityMonitoringDefaultRuleFilter"]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param case: case block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#case SecurityMonitoringDefaultRule#case}
        :param enabled: Enable the rule. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#enabled SecurityMonitoringDefaultRule#enabled}
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#filter SecurityMonitoringDefaultRule#filter}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if case is not None:
            self._values["case"] = case
        if enabled is not None:
            self._values["enabled"] = enabled
        if filter is not None:
            self._values["filter"] = filter

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def case(self) -> typing.Optional[typing.List[SecurityMonitoringDefaultRuleCase]]:
        '''case block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#case SecurityMonitoringDefaultRule#case}
        '''
        result = self._values.get("case")
        return typing.cast(typing.Optional[typing.List[SecurityMonitoringDefaultRuleCase]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Enable the rule.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#enabled SecurityMonitoringDefaultRule#enabled}
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def filter(
        self,
    ) -> typing.Optional[typing.List["SecurityMonitoringDefaultRuleFilter"]]:
        '''filter block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#filter SecurityMonitoringDefaultRule#filter}
        '''
        result = self._values.get("filter")
        return typing.cast(typing.Optional[typing.List["SecurityMonitoringDefaultRuleFilter"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityMonitoringDefaultRuleConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SecurityMonitoringDefaultRuleFilter",
    jsii_struct_bases=[],
    name_mapping={"action": "action", "query": "query"},
)
class SecurityMonitoringDefaultRuleFilter:
    def __init__(self, *, action: builtins.str, query: builtins.str) -> None:
        '''
        :param action: The type of filtering action. Allowed enum values: require, suppress Valid values are ``require``, ``suppress``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#action SecurityMonitoringDefaultRule#action}
        :param query: Query for selecting logs to apply the filtering action. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#query SecurityMonitoringDefaultRule#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "action": action,
            "query": query,
        }

    @builtins.property
    def action(self) -> builtins.str:
        '''The type of filtering action. Allowed enum values: require, suppress Valid values are ``require``, ``suppress``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#action SecurityMonitoringDefaultRule#action}
        '''
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''Query for selecting logs to apply the filtering action.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_default_rule.html#query SecurityMonitoringDefaultRule#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityMonitoringDefaultRuleFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SecurityMonitoringRule(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.SecurityMonitoringRule",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html datadog_security_monitoring_rule}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        case: typing.Sequence["SecurityMonitoringRuleCase"],
        message: builtins.str,
        name: builtins.str,
        query: typing.Sequence["SecurityMonitoringRuleQuery"],
        enabled: typing.Optional[builtins.bool] = None,
        filter: typing.Optional[typing.Sequence["SecurityMonitoringRuleFilter"]] = None,
        has_extended_title: typing.Optional[builtins.bool] = None,
        options: typing.Optional[typing.Sequence["SecurityMonitoringRuleOptions"]] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html datadog_security_monitoring_rule} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param case: case block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#case SecurityMonitoringRule#case}
        :param message: Message for generated signals. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#message SecurityMonitoringRule#message}
        :param name: The name of the rule. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#name SecurityMonitoringRule#name}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#query SecurityMonitoringRule#query}
        :param enabled: Whether the rule is enabled. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#enabled SecurityMonitoringRule#enabled}
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#filter SecurityMonitoringRule#filter}
        :param has_extended_title: Whether the notifications include the triggering group-by values in their title. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#has_extended_title SecurityMonitoringRule#has_extended_title}
        :param options: options block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#options SecurityMonitoringRule#options}
        :param tags: Tags for generated signals. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#tags SecurityMonitoringRule#tags}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = SecurityMonitoringRuleConfig(
            case=case,
            message=message,
            name=name,
            query=query,
            enabled=enabled,
            filter=filter,
            has_extended_title=has_extended_title,
            options=options,
            tags=tags,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(SecurityMonitoringRule, self, [scope, id, config])

    @jsii.member(jsii_name="resetEnabled")
    def reset_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnabled", []))

    @jsii.member(jsii_name="resetFilter")
    def reset_filter(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetFilter", []))

    @jsii.member(jsii_name="resetHasExtendedTitle")
    def reset_has_extended_title(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHasExtendedTitle", []))

    @jsii.member(jsii_name="resetOptions")
    def reset_options(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptions", []))

    @jsii.member(jsii_name="resetTags")
    def reset_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTags", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="caseInput")
    def case_input(self) -> typing.List["SecurityMonitoringRuleCase"]:
        return typing.cast(typing.List["SecurityMonitoringRuleCase"], jsii.get(self, "caseInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="messageInput")
    def message_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "messageInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="queryInput")
    def query_input(self) -> typing.List["SecurityMonitoringRuleQuery"]:
        return typing.cast(typing.List["SecurityMonitoringRuleQuery"], jsii.get(self, "queryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enabledInput")
    def enabled_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "enabledInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filterInput")
    def filter_input(
        self,
    ) -> typing.Optional[typing.List["SecurityMonitoringRuleFilter"]]:
        return typing.cast(typing.Optional[typing.List["SecurityMonitoringRuleFilter"]], jsii.get(self, "filterInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hasExtendedTitleInput")
    def has_extended_title_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "hasExtendedTitleInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="optionsInput")
    def options_input(
        self,
    ) -> typing.Optional[typing.List["SecurityMonitoringRuleOptions"]]:
        return typing.cast(typing.Optional[typing.List["SecurityMonitoringRuleOptions"]], jsii.get(self, "optionsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="case")
    def case(self) -> typing.List["SecurityMonitoringRuleCase"]:
        return typing.cast(typing.List["SecurityMonitoringRuleCase"], jsii.get(self, "case"))

    @case.setter
    def case(self, value: typing.List["SecurityMonitoringRuleCase"]) -> None:
        jsii.set(self, "case", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enabled")
    def enabled(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(self, value: builtins.bool) -> None:
        jsii.set(self, "enabled", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filter")
    def filter(self) -> typing.List["SecurityMonitoringRuleFilter"]:
        return typing.cast(typing.List["SecurityMonitoringRuleFilter"], jsii.get(self, "filter"))

    @filter.setter
    def filter(self, value: typing.List["SecurityMonitoringRuleFilter"]) -> None:
        jsii.set(self, "filter", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hasExtendedTitle")
    def has_extended_title(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "hasExtendedTitle"))

    @has_extended_title.setter
    def has_extended_title(self, value: builtins.bool) -> None:
        jsii.set(self, "hasExtendedTitle", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="message")
    def message(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "message"))

    @message.setter
    def message(self, value: builtins.str) -> None:
        jsii.set(self, "message", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="options")
    def options(self) -> typing.List["SecurityMonitoringRuleOptions"]:
        return typing.cast(typing.List["SecurityMonitoringRuleOptions"], jsii.get(self, "options"))

    @options.setter
    def options(self, value: typing.List["SecurityMonitoringRuleOptions"]) -> None:
        jsii.set(self, "options", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="query")
    def query(self) -> typing.List["SecurityMonitoringRuleQuery"]:
        return typing.cast(typing.List["SecurityMonitoringRuleQuery"], jsii.get(self, "query"))

    @query.setter
    def query(self, value: typing.List["SecurityMonitoringRuleQuery"]) -> None:
        jsii.set(self, "query", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "tags", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SecurityMonitoringRuleCase",
    jsii_struct_bases=[],
    name_mapping={
        "status": "status",
        "condition": "condition",
        "name": "name",
        "notifications": "notifications",
    },
)
class SecurityMonitoringRuleCase:
    def __init__(
        self,
        *,
        status: builtins.str,
        condition: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        notifications: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param status: Severity of the Security Signal. Valid values are ``info``, ``low``, ``medium``, ``high``, ``critical``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#status SecurityMonitoringRule#status}
        :param condition: A rule case contains logical operations (``>``,``>=``, ``&&``, ``||``) to determine if a signal should be generated based on the event counts in the previously defined queries. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#condition SecurityMonitoringRule#condition}
        :param name: Name of the case. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#name SecurityMonitoringRule#name}
        :param notifications: Notification targets for each rule case. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#notifications SecurityMonitoringRule#notifications}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "status": status,
        }
        if condition is not None:
            self._values["condition"] = condition
        if name is not None:
            self._values["name"] = name
        if notifications is not None:
            self._values["notifications"] = notifications

    @builtins.property
    def status(self) -> builtins.str:
        '''Severity of the Security Signal. Valid values are ``info``, ``low``, ``medium``, ``high``, ``critical``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#status SecurityMonitoringRule#status}
        '''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def condition(self) -> typing.Optional[builtins.str]:
        '''A rule case contains logical operations (``>``,``>=``, ``&&``, ``||``) to determine if a signal should be generated based on the event counts in the previously defined queries.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#condition SecurityMonitoringRule#condition}
        '''
        result = self._values.get("condition")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the case.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#name SecurityMonitoringRule#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def notifications(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Notification targets for each rule case.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#notifications SecurityMonitoringRule#notifications}
        '''
        result = self._values.get("notifications")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityMonitoringRuleCase(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SecurityMonitoringRuleConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "case": "case",
        "message": "message",
        "name": "name",
        "query": "query",
        "enabled": "enabled",
        "filter": "filter",
        "has_extended_title": "hasExtendedTitle",
        "options": "options",
        "tags": "tags",
    },
)
class SecurityMonitoringRuleConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        case: typing.Sequence[SecurityMonitoringRuleCase],
        message: builtins.str,
        name: builtins.str,
        query: typing.Sequence["SecurityMonitoringRuleQuery"],
        enabled: typing.Optional[builtins.bool] = None,
        filter: typing.Optional[typing.Sequence["SecurityMonitoringRuleFilter"]] = None,
        has_extended_title: typing.Optional[builtins.bool] = None,
        options: typing.Optional[typing.Sequence["SecurityMonitoringRuleOptions"]] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param case: case block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#case SecurityMonitoringRule#case}
        :param message: Message for generated signals. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#message SecurityMonitoringRule#message}
        :param name: The name of the rule. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#name SecurityMonitoringRule#name}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#query SecurityMonitoringRule#query}
        :param enabled: Whether the rule is enabled. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#enabled SecurityMonitoringRule#enabled}
        :param filter: filter block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#filter SecurityMonitoringRule#filter}
        :param has_extended_title: Whether the notifications include the triggering group-by values in their title. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#has_extended_title SecurityMonitoringRule#has_extended_title}
        :param options: options block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#options SecurityMonitoringRule#options}
        :param tags: Tags for generated signals. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#tags SecurityMonitoringRule#tags}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "case": case,
            "message": message,
            "name": name,
            "query": query,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if enabled is not None:
            self._values["enabled"] = enabled
        if filter is not None:
            self._values["filter"] = filter
        if has_extended_title is not None:
            self._values["has_extended_title"] = has_extended_title
        if options is not None:
            self._values["options"] = options
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def case(self) -> typing.List[SecurityMonitoringRuleCase]:
        '''case block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#case SecurityMonitoringRule#case}
        '''
        result = self._values.get("case")
        assert result is not None, "Required property 'case' is missing"
        return typing.cast(typing.List[SecurityMonitoringRuleCase], result)

    @builtins.property
    def message(self) -> builtins.str:
        '''Message for generated signals.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#message SecurityMonitoringRule#message}
        '''
        result = self._values.get("message")
        assert result is not None, "Required property 'message' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the rule.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#name SecurityMonitoringRule#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> typing.List["SecurityMonitoringRuleQuery"]:
        '''query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#query SecurityMonitoringRule#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(typing.List["SecurityMonitoringRuleQuery"], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Whether the rule is enabled.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#enabled SecurityMonitoringRule#enabled}
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def filter(self) -> typing.Optional[typing.List["SecurityMonitoringRuleFilter"]]:
        '''filter block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#filter SecurityMonitoringRule#filter}
        '''
        result = self._values.get("filter")
        return typing.cast(typing.Optional[typing.List["SecurityMonitoringRuleFilter"]], result)

    @builtins.property
    def has_extended_title(self) -> typing.Optional[builtins.bool]:
        '''Whether the notifications include the triggering group-by values in their title.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#has_extended_title SecurityMonitoringRule#has_extended_title}
        '''
        result = self._values.get("has_extended_title")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def options(self) -> typing.Optional[typing.List["SecurityMonitoringRuleOptions"]]:
        '''options block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#options SecurityMonitoringRule#options}
        '''
        result = self._values.get("options")
        return typing.cast(typing.Optional[typing.List["SecurityMonitoringRuleOptions"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Tags for generated signals.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#tags SecurityMonitoringRule#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityMonitoringRuleConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SecurityMonitoringRuleFilter",
    jsii_struct_bases=[],
    name_mapping={"action": "action", "query": "query"},
)
class SecurityMonitoringRuleFilter:
    def __init__(self, *, action: builtins.str, query: builtins.str) -> None:
        '''
        :param action: The type of filtering action. Valid values are ``require``, ``suppress``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#action SecurityMonitoringRule#action}
        :param query: Query for selecting logs to apply the filtering action. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#query SecurityMonitoringRule#query}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "action": action,
            "query": query,
        }

    @builtins.property
    def action(self) -> builtins.str:
        '''The type of filtering action. Valid values are ``require``, ``suppress``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#action SecurityMonitoringRule#action}
        '''
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query(self) -> builtins.str:
        '''Query for selecting logs to apply the filtering action.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#query SecurityMonitoringRule#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityMonitoringRuleFilter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SecurityMonitoringRuleOptions",
    jsii_struct_bases=[],
    name_mapping={
        "evaluation_window": "evaluationWindow",
        "keep_alive": "keepAlive",
        "max_signal_duration": "maxSignalDuration",
        "detection_method": "detectionMethod",
        "new_value_options": "newValueOptions",
    },
)
class SecurityMonitoringRuleOptions:
    def __init__(
        self,
        *,
        evaluation_window: jsii.Number,
        keep_alive: jsii.Number,
        max_signal_duration: jsii.Number,
        detection_method: typing.Optional[builtins.str] = None,
        new_value_options: typing.Optional[typing.Sequence["SecurityMonitoringRuleOptionsNewValueOptions"]] = None,
    ) -> None:
        '''
        :param evaluation_window: A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time. Valid values are ``0``, ``60``, ``300``, ``600``, ``900``, ``1800``, ``3600``, ``7200``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#evaluation_window SecurityMonitoringRule#evaluation_window}
        :param keep_alive: Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window. Valid values are ``0``, ``60``, ``300``, ``600``, ``900``, ``1800``, ``3600``, ``7200``, ``10800``, ``21600``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#keep_alive SecurityMonitoringRule#keep_alive}
        :param max_signal_duration: A signal will close regardless of the query being matched once the time exceeds the maximum duration. This time is calculated from the first seen timestamp. Valid values are ``0``, ``60``, ``300``, ``600``, ``900``, ``1800``, ``3600``, ``7200``, ``10800``, ``21600``, ``43200``, ``86400``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#max_signal_duration SecurityMonitoringRule#max_signal_duration}
        :param detection_method: The detection method. Valid values are ``threshold``, ``new_value``, ``anomaly_detection``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#detection_method SecurityMonitoringRule#detection_method}
        :param new_value_options: new_value_options block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#new_value_options SecurityMonitoringRule#new_value_options}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "evaluation_window": evaluation_window,
            "keep_alive": keep_alive,
            "max_signal_duration": max_signal_duration,
        }
        if detection_method is not None:
            self._values["detection_method"] = detection_method
        if new_value_options is not None:
            self._values["new_value_options"] = new_value_options

    @builtins.property
    def evaluation_window(self) -> jsii.Number:
        '''A time window is specified to match when at least one of the cases matches true.

        This is a sliding window and evaluates in real time. Valid values are ``0``, ``60``, ``300``, ``600``, ``900``, ``1800``, ``3600``, ``7200``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#evaluation_window SecurityMonitoringRule#evaluation_window}
        '''
        result = self._values.get("evaluation_window")
        assert result is not None, "Required property 'evaluation_window' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def keep_alive(self) -> jsii.Number:
        '''Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window.

        Valid values are ``0``, ``60``, ``300``, ``600``, ``900``, ``1800``, ``3600``, ``7200``, ``10800``, ``21600``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#keep_alive SecurityMonitoringRule#keep_alive}
        '''
        result = self._values.get("keep_alive")
        assert result is not None, "Required property 'keep_alive' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def max_signal_duration(self) -> jsii.Number:
        '''A signal will close regardless of the query being matched once the time exceeds the maximum duration.

        This time is calculated from the first seen timestamp. Valid values are ``0``, ``60``, ``300``, ``600``, ``900``, ``1800``, ``3600``, ``7200``, ``10800``, ``21600``, ``43200``, ``86400``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#max_signal_duration SecurityMonitoringRule#max_signal_duration}
        '''
        result = self._values.get("max_signal_duration")
        assert result is not None, "Required property 'max_signal_duration' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def detection_method(self) -> typing.Optional[builtins.str]:
        '''The detection method. Valid values are ``threshold``, ``new_value``, ``anomaly_detection``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#detection_method SecurityMonitoringRule#detection_method}
        '''
        result = self._values.get("detection_method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def new_value_options(
        self,
    ) -> typing.Optional[typing.List["SecurityMonitoringRuleOptionsNewValueOptions"]]:
        '''new_value_options block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#new_value_options SecurityMonitoringRule#new_value_options}
        '''
        result = self._values.get("new_value_options")
        return typing.cast(typing.Optional[typing.List["SecurityMonitoringRuleOptionsNewValueOptions"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityMonitoringRuleOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SecurityMonitoringRuleOptionsNewValueOptions",
    jsii_struct_bases=[],
    name_mapping={
        "forget_after": "forgetAfter",
        "learning_duration": "learningDuration",
    },
)
class SecurityMonitoringRuleOptionsNewValueOptions:
    def __init__(
        self,
        *,
        forget_after: jsii.Number,
        learning_duration: jsii.Number,
    ) -> None:
        '''
        :param forget_after: The duration in days after which a learned value is forgotten. Valid values are ``1``, ``2``, ``7``, ``14``, ``21``, ``28``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#forget_after SecurityMonitoringRule#forget_after}
        :param learning_duration: The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned. Valid values are ``0``, ``1``, ``7``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#learning_duration SecurityMonitoringRule#learning_duration}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "forget_after": forget_after,
            "learning_duration": learning_duration,
        }

    @builtins.property
    def forget_after(self) -> jsii.Number:
        '''The duration in days after which a learned value is forgotten.

        Valid values are ``1``, ``2``, ``7``, ``14``, ``21``, ``28``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#forget_after SecurityMonitoringRule#forget_after}
        '''
        result = self._values.get("forget_after")
        assert result is not None, "Required property 'forget_after' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def learning_duration(self) -> jsii.Number:
        '''The duration in days during which values are learned, and after which signals will be generated for values that weren't learned.

        If set to 0, a signal will be generated for all new values after the first value is learned. Valid values are ``0``, ``1``, ``7``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#learning_duration SecurityMonitoringRule#learning_duration}
        '''
        result = self._values.get("learning_duration")
        assert result is not None, "Required property 'learning_duration' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityMonitoringRuleOptionsNewValueOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SecurityMonitoringRuleQuery",
    jsii_struct_bases=[],
    name_mapping={
        "query": "query",
        "aggregation": "aggregation",
        "distinct_fields": "distinctFields",
        "group_by_fields": "groupByFields",
        "metric": "metric",
        "name": "name",
    },
)
class SecurityMonitoringRuleQuery:
    def __init__(
        self,
        *,
        query: builtins.str,
        aggregation: typing.Optional[builtins.str] = None,
        distinct_fields: typing.Optional[typing.Sequence[builtins.str]] = None,
        group_by_fields: typing.Optional[typing.Sequence[builtins.str]] = None,
        metric: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param query: Query to run on logs. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#query SecurityMonitoringRule#query}
        :param aggregation: The aggregation type. Valid values are ``count``, ``cardinality``, ``sum``, ``max``, ``new_value``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#aggregation SecurityMonitoringRule#aggregation}
        :param distinct_fields: Field for which the cardinality is measured. Sent as an array. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#distinct_fields SecurityMonitoringRule#distinct_fields}
        :param group_by_fields: Fields to group by. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#group_by_fields SecurityMonitoringRule#group_by_fields}
        :param metric: The target field to aggregate over when using the sum or max aggregations. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#metric SecurityMonitoringRule#metric}
        :param name: Name of the query. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#name SecurityMonitoringRule#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "query": query,
        }
        if aggregation is not None:
            self._values["aggregation"] = aggregation
        if distinct_fields is not None:
            self._values["distinct_fields"] = distinct_fields
        if group_by_fields is not None:
            self._values["group_by_fields"] = group_by_fields
        if metric is not None:
            self._values["metric"] = metric
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def query(self) -> builtins.str:
        '''Query to run on logs.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#query SecurityMonitoringRule#query}
        '''
        result = self._values.get("query")
        assert result is not None, "Required property 'query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aggregation(self) -> typing.Optional[builtins.str]:
        '''The aggregation type. Valid values are ``count``, ``cardinality``, ``sum``, ``max``, ``new_value``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#aggregation SecurityMonitoringRule#aggregation}
        '''
        result = self._values.get("aggregation")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def distinct_fields(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Field for which the cardinality is measured. Sent as an array.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#distinct_fields SecurityMonitoringRule#distinct_fields}
        '''
        result = self._values.get("distinct_fields")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def group_by_fields(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Fields to group by.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#group_by_fields SecurityMonitoringRule#group_by_fields}
        '''
        result = self._values.get("group_by_fields")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def metric(self) -> typing.Optional[builtins.str]:
        '''The target field to aggregate over when using the sum or max aggregations.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#metric SecurityMonitoringRule#metric}
        '''
        result = self._values.get("metric")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the query.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/security_monitoring_rule.html#name SecurityMonitoringRule#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityMonitoringRuleQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ServiceLevelObjective(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.ServiceLevelObjective",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html datadog_service_level_objective}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        name: builtins.str,
        thresholds: typing.Sequence["ServiceLevelObjectiveThresholds"],
        type: builtins.str,
        description: typing.Optional[builtins.str] = None,
        force_delete: typing.Optional[builtins.bool] = None,
        groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        monitor_ids: typing.Optional[typing.Sequence[jsii.Number]] = None,
        query: typing.Optional[typing.Sequence["ServiceLevelObjectiveQuery"]] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        validate: typing.Optional[builtins.bool] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html datadog_service_level_objective} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param name: Name of Datadog service level objective. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#name ServiceLevelObjective#name}
        :param thresholds: thresholds block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#thresholds ServiceLevelObjective#thresholds}
        :param type: The type of the service level objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API `documentation page <https://docs.datadoghq.com/api/v1/service-level-objectives/#create-a-slo-object>`_. Valid values are ``metric``, ``monitor``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#type ServiceLevelObjective#type}
        :param description: A description of this service level objective. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#description ServiceLevelObjective#description}
        :param force_delete: A boolean indicating whether this monitor can be deleted even if its referenced by other resources (e.g. dashboards). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#force_delete ServiceLevelObjective#force_delete}
        :param groups: A static set of groups to filter monitor-based SLOs. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#groups ServiceLevelObjective#groups}
        :param monitor_ids: A static set of monitor IDs to use as part of the SLO. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#monitor_ids ServiceLevelObjective#monitor_ids}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#query ServiceLevelObjective#query}
        :param tags: A list of tags to associate with your service level objective. This can help you categorize and filter service level objectives in the service level objectives page of the UI. Note: it's not currently possible to filter by these tags when querying via the API Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#tags ServiceLevelObjective#tags}
        :param validate: Whether or not to validate the SLO. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#validate ServiceLevelObjective#validate}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = ServiceLevelObjectiveConfig(
            name=name,
            thresholds=thresholds,
            type=type,
            description=description,
            force_delete=force_delete,
            groups=groups,
            monitor_ids=monitor_ids,
            query=query,
            tags=tags,
            validate=validate,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(ServiceLevelObjective, self, [scope, id, config])

    @jsii.member(jsii_name="resetDescription")
    def reset_description(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDescription", []))

    @jsii.member(jsii_name="resetForceDelete")
    def reset_force_delete(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetForceDelete", []))

    @jsii.member(jsii_name="resetGroups")
    def reset_groups(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetGroups", []))

    @jsii.member(jsii_name="resetMonitorIds")
    def reset_monitor_ids(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMonitorIds", []))

    @jsii.member(jsii_name="resetQuery")
    def reset_query(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetQuery", []))

    @jsii.member(jsii_name="resetTags")
    def reset_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTags", []))

    @jsii.member(jsii_name="resetValidate")
    def reset_validate(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetValidate", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="thresholdsInput")
    def thresholds_input(self) -> typing.List["ServiceLevelObjectiveThresholds"]:
        return typing.cast(typing.List["ServiceLevelObjectiveThresholds"], jsii.get(self, "thresholdsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "typeInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="descriptionInput")
    def description_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "descriptionInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="forceDeleteInput")
    def force_delete_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "forceDeleteInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupsInput")
    def groups_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "groupsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorIdsInput")
    def monitor_ids_input(self) -> typing.Optional[typing.List[jsii.Number]]:
        return typing.cast(typing.Optional[typing.List[jsii.Number]], jsii.get(self, "monitorIdsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="queryInput")
    def query_input(self) -> typing.Optional[typing.List["ServiceLevelObjectiveQuery"]]:
        return typing.cast(typing.Optional[typing.List["ServiceLevelObjectiveQuery"]], jsii.get(self, "queryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="validateInput")
    def validate_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "validateInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "description"))

    @description.setter
    def description(self, value: builtins.str) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="forceDelete")
    def force_delete(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "forceDelete"))

    @force_delete.setter
    def force_delete(self, value: builtins.bool) -> None:
        jsii.set(self, "forceDelete", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groups")
    def groups(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "groups"))

    @groups.setter
    def groups(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "groups", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorIds")
    def monitor_ids(self) -> typing.List[jsii.Number]:
        return typing.cast(typing.List[jsii.Number], jsii.get(self, "monitorIds"))

    @monitor_ids.setter
    def monitor_ids(self, value: typing.List[jsii.Number]) -> None:
        jsii.set(self, "monitorIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="query")
    def query(self) -> typing.List["ServiceLevelObjectiveQuery"]:
        return typing.cast(typing.List["ServiceLevelObjectiveQuery"], jsii.get(self, "query"))

    @query.setter
    def query(self, value: typing.List["ServiceLevelObjectiveQuery"]) -> None:
        jsii.set(self, "query", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "tags", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="thresholds")
    def thresholds(self) -> typing.List["ServiceLevelObjectiveThresholds"]:
        return typing.cast(typing.List["ServiceLevelObjectiveThresholds"], jsii.get(self, "thresholds"))

    @thresholds.setter
    def thresholds(self, value: typing.List["ServiceLevelObjectiveThresholds"]) -> None:
        jsii.set(self, "thresholds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        jsii.set(self, "type", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="validate")
    def validate(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "validate"))

    @validate.setter
    def validate(self, value: builtins.bool) -> None:
        jsii.set(self, "validate", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.ServiceLevelObjectiveConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "name": "name",
        "thresholds": "thresholds",
        "type": "type",
        "description": "description",
        "force_delete": "forceDelete",
        "groups": "groups",
        "monitor_ids": "monitorIds",
        "query": "query",
        "tags": "tags",
        "validate": "validate",
    },
)
class ServiceLevelObjectiveConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        name: builtins.str,
        thresholds: typing.Sequence["ServiceLevelObjectiveThresholds"],
        type: builtins.str,
        description: typing.Optional[builtins.str] = None,
        force_delete: typing.Optional[builtins.bool] = None,
        groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        monitor_ids: typing.Optional[typing.Sequence[jsii.Number]] = None,
        query: typing.Optional[typing.Sequence["ServiceLevelObjectiveQuery"]] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        validate: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param name: Name of Datadog service level objective. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#name ServiceLevelObjective#name}
        :param thresholds: thresholds block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#thresholds ServiceLevelObjective#thresholds}
        :param type: The type of the service level objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API `documentation page <https://docs.datadoghq.com/api/v1/service-level-objectives/#create-a-slo-object>`_. Valid values are ``metric``, ``monitor``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#type ServiceLevelObjective#type}
        :param description: A description of this service level objective. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#description ServiceLevelObjective#description}
        :param force_delete: A boolean indicating whether this monitor can be deleted even if its referenced by other resources (e.g. dashboards). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#force_delete ServiceLevelObjective#force_delete}
        :param groups: A static set of groups to filter monitor-based SLOs. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#groups ServiceLevelObjective#groups}
        :param monitor_ids: A static set of monitor IDs to use as part of the SLO. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#monitor_ids ServiceLevelObjective#monitor_ids}
        :param query: query block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#query ServiceLevelObjective#query}
        :param tags: A list of tags to associate with your service level objective. This can help you categorize and filter service level objectives in the service level objectives page of the UI. Note: it's not currently possible to filter by these tags when querying via the API Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#tags ServiceLevelObjective#tags}
        :param validate: Whether or not to validate the SLO. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#validate ServiceLevelObjective#validate}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "thresholds": thresholds,
            "type": type,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if description is not None:
            self._values["description"] = description
        if force_delete is not None:
            self._values["force_delete"] = force_delete
        if groups is not None:
            self._values["groups"] = groups
        if monitor_ids is not None:
            self._values["monitor_ids"] = monitor_ids
        if query is not None:
            self._values["query"] = query
        if tags is not None:
            self._values["tags"] = tags
        if validate is not None:
            self._values["validate"] = validate

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of Datadog service level objective.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#name ServiceLevelObjective#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def thresholds(self) -> typing.List["ServiceLevelObjectiveThresholds"]:
        '''thresholds block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#thresholds ServiceLevelObjective#thresholds}
        '''
        result = self._values.get("thresholds")
        assert result is not None, "Required property 'thresholds' is missing"
        return typing.cast(typing.List["ServiceLevelObjectiveThresholds"], result)

    @builtins.property
    def type(self) -> builtins.str:
        '''The type of the service level objective.

        The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API `documentation page <https://docs.datadoghq.com/api/v1/service-level-objectives/#create-a-slo-object>`_. Valid values are ``metric``, ``monitor``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#type ServiceLevelObjective#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description of this service level objective.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#description ServiceLevelObjective#description}
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def force_delete(self) -> typing.Optional[builtins.bool]:
        '''A boolean indicating whether this monitor can be deleted even if its referenced by other resources (e.g. dashboards).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#force_delete ServiceLevelObjective#force_delete}
        '''
        result = self._values.get("force_delete")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A static set of groups to filter monitor-based SLOs.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#groups ServiceLevelObjective#groups}
        '''
        result = self._values.get("groups")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def monitor_ids(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''A static set of monitor IDs to use as part of the SLO.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#monitor_ids ServiceLevelObjective#monitor_ids}
        '''
        result = self._values.get("monitor_ids")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def query(self) -> typing.Optional[typing.List["ServiceLevelObjectiveQuery"]]:
        '''query block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#query ServiceLevelObjective#query}
        '''
        result = self._values.get("query")
        return typing.cast(typing.Optional[typing.List["ServiceLevelObjectiveQuery"]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of tags to associate with your service level objective.

        This can help you categorize and filter service level objectives in the service level objectives page of the UI. Note: it's not currently possible to filter by these tags when querying via the API

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#tags ServiceLevelObjective#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def validate(self) -> typing.Optional[builtins.bool]:
        '''Whether or not to validate the SLO.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#validate ServiceLevelObjective#validate}
        '''
        result = self._values.get("validate")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ServiceLevelObjectiveConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.ServiceLevelObjectiveQuery",
    jsii_struct_bases=[],
    name_mapping={"denominator": "denominator", "numerator": "numerator"},
)
class ServiceLevelObjectiveQuery:
    def __init__(self, *, denominator: builtins.str, numerator: builtins.str) -> None:
        '''
        :param denominator: The sum of the ``total`` events. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#denominator ServiceLevelObjective#denominator}
        :param numerator: The sum of all the ``good`` events. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#numerator ServiceLevelObjective#numerator}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "denominator": denominator,
            "numerator": numerator,
        }

    @builtins.property
    def denominator(self) -> builtins.str:
        '''The sum of the ``total`` events.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#denominator ServiceLevelObjective#denominator}
        '''
        result = self._values.get("denominator")
        assert result is not None, "Required property 'denominator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def numerator(self) -> builtins.str:
        '''The sum of all the ``good`` events.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#numerator ServiceLevelObjective#numerator}
        '''
        result = self._values.get("numerator")
        assert result is not None, "Required property 'numerator' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ServiceLevelObjectiveQuery(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.ServiceLevelObjectiveThresholds",
    jsii_struct_bases=[],
    name_mapping={
        "target": "target",
        "timeframe": "timeframe",
        "target_display": "targetDisplay",
        "warning": "warning",
        "warning_display": "warningDisplay",
    },
)
class ServiceLevelObjectiveThresholds:
    def __init__(
        self,
        *,
        target: jsii.Number,
        timeframe: builtins.str,
        target_display: typing.Optional[builtins.str] = None,
        warning: typing.Optional[jsii.Number] = None,
        warning_display: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param target: The objective's target in``[0,100]``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#target ServiceLevelObjective#target}
        :param timeframe: The time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Valid values are ``7d``, ``30d``, ``90d``, ``custom``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#timeframe ServiceLevelObjective#timeframe}
        :param target_display: A string representation of the target that indicates its precision. It uses trailing zeros to show significant decimal places (e.g. ``98.00``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#target_display ServiceLevelObjective#target_display}
        :param warning: The objective's warning value in ``[0,100]``. This must be greater than the target value. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#warning ServiceLevelObjective#warning}
        :param warning_display: A string representation of the warning target (see the description of the target_display field for details). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#warning_display ServiceLevelObjective#warning_display}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "target": target,
            "timeframe": timeframe,
        }
        if target_display is not None:
            self._values["target_display"] = target_display
        if warning is not None:
            self._values["warning"] = warning
        if warning_display is not None:
            self._values["warning_display"] = warning_display

    @builtins.property
    def target(self) -> jsii.Number:
        '''The objective's target in``[0,100]``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#target ServiceLevelObjective#target}
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def timeframe(self) -> builtins.str:
        '''The time frame for the objective.

        The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Valid values are ``7d``, ``30d``, ``90d``, ``custom``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#timeframe ServiceLevelObjective#timeframe}
        '''
        result = self._values.get("timeframe")
        assert result is not None, "Required property 'timeframe' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_display(self) -> typing.Optional[builtins.str]:
        '''A string representation of the target that indicates its precision.

        It uses trailing zeros to show significant decimal places (e.g. ``98.00``).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#target_display ServiceLevelObjective#target_display}
        '''
        result = self._values.get("target_display")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def warning(self) -> typing.Optional[jsii.Number]:
        '''The objective's warning value in ``[0,100]``. This must be greater than the target value.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#warning ServiceLevelObjective#warning}
        '''
        result = self._values.get("warning")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def warning_display(self) -> typing.Optional[builtins.str]:
        '''A string representation of the warning target (see the description of the target_display field for details).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/service_level_objective.html#warning_display ServiceLevelObjective#warning_display}
        '''
        result = self._values.get("warning_display")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ServiceLevelObjectiveThresholds(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SloCorrection(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.SloCorrection",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html datadog_slo_correction}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        category: builtins.str,
        end: jsii.Number,
        slo_id: builtins.str,
        start: jsii.Number,
        description: typing.Optional[builtins.str] = None,
        timezone: typing.Optional[builtins.str] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html datadog_slo_correction} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param category: Category the SLO correction belongs to. Valid values are ``Scheduled Maintenance``, ``Outside Business Hours``, ``Deployment``, ``Other``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#category SloCorrection#category}
        :param end: Ending time of the correction in epoch seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#end SloCorrection#end}
        :param slo_id: ID of the SLO that this correction will be applied to. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#slo_id SloCorrection#slo_id}
        :param start: Starting time of the correction in epoch seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#start SloCorrection#start}
        :param description: Description of the correction being made. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#description SloCorrection#description}
        :param timezone: The timezone to display in the UI for the correction times (defaults to "UTC"). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#timezone SloCorrection#timezone}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = SloCorrectionConfig(
            category=category,
            end=end,
            slo_id=slo_id,
            start=start,
            description=description,
            timezone=timezone,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(SloCorrection, self, [scope, id, config])

    @jsii.member(jsii_name="resetDescription")
    def reset_description(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDescription", []))

    @jsii.member(jsii_name="resetTimezone")
    def reset_timezone(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimezone", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="categoryInput")
    def category_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "categoryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="endInput")
    def end_input(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "endInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sloIdInput")
    def slo_id_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sloIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="startInput")
    def start_input(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "startInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="descriptionInput")
    def description_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "descriptionInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="timezoneInput")
    def timezone_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timezoneInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="category")
    def category(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "category"))

    @category.setter
    def category(self, value: builtins.str) -> None:
        jsii.set(self, "category", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "description"))

    @description.setter
    def description(self, value: builtins.str) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="end")
    def end(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "end"))

    @end.setter
    def end(self, value: jsii.Number) -> None:
        jsii.set(self, "end", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sloId")
    def slo_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sloId"))

    @slo_id.setter
    def slo_id(self, value: builtins.str) -> None:
        jsii.set(self, "sloId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="start")
    def start(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "start"))

    @start.setter
    def start(self, value: jsii.Number) -> None:
        jsii.set(self, "start", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="timezone")
    def timezone(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "timezone"))

    @timezone.setter
    def timezone(self, value: builtins.str) -> None:
        jsii.set(self, "timezone", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SloCorrectionConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "category": "category",
        "end": "end",
        "slo_id": "sloId",
        "start": "start",
        "description": "description",
        "timezone": "timezone",
    },
)
class SloCorrectionConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        category: builtins.str,
        end: jsii.Number,
        slo_id: builtins.str,
        start: jsii.Number,
        description: typing.Optional[builtins.str] = None,
        timezone: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param category: Category the SLO correction belongs to. Valid values are ``Scheduled Maintenance``, ``Outside Business Hours``, ``Deployment``, ``Other``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#category SloCorrection#category}
        :param end: Ending time of the correction in epoch seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#end SloCorrection#end}
        :param slo_id: ID of the SLO that this correction will be applied to. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#slo_id SloCorrection#slo_id}
        :param start: Starting time of the correction in epoch seconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#start SloCorrection#start}
        :param description: Description of the correction being made. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#description SloCorrection#description}
        :param timezone: The timezone to display in the UI for the correction times (defaults to "UTC"). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#timezone SloCorrection#timezone}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "category": category,
            "end": end,
            "slo_id": slo_id,
            "start": start,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if description is not None:
            self._values["description"] = description
        if timezone is not None:
            self._values["timezone"] = timezone

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def category(self) -> builtins.str:
        '''Category the SLO correction belongs to. Valid values are ``Scheduled Maintenance``, ``Outside Business Hours``, ``Deployment``, ``Other``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#category SloCorrection#category}
        '''
        result = self._values.get("category")
        assert result is not None, "Required property 'category' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def end(self) -> jsii.Number:
        '''Ending time of the correction in epoch seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#end SloCorrection#end}
        '''
        result = self._values.get("end")
        assert result is not None, "Required property 'end' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def slo_id(self) -> builtins.str:
        '''ID of the SLO that this correction will be applied to.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#slo_id SloCorrection#slo_id}
        '''
        result = self._values.get("slo_id")
        assert result is not None, "Required property 'slo_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def start(self) -> jsii.Number:
        '''Starting time of the correction in epoch seconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#start SloCorrection#start}
        '''
        result = self._values.get("start")
        assert result is not None, "Required property 'start' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Description of the correction being made.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#description SloCorrection#description}
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timezone(self) -> typing.Optional[builtins.str]:
        '''The timezone to display in the UI for the correction times (defaults to "UTC").

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/slo_correction.html#timezone SloCorrection#timezone}
        '''
        result = self._values.get("timezone")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SloCorrectionConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SyntheticsGlobalVariable(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.SyntheticsGlobalVariable",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html datadog_synthetics_global_variable}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        name: builtins.str,
        value: builtins.str,
        description: typing.Optional[builtins.str] = None,
        parse_test_id: typing.Optional[builtins.str] = None,
        parse_test_options: typing.Optional[typing.Sequence["SyntheticsGlobalVariableParseTestOptions"]] = None,
        secure: typing.Optional[builtins.bool] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html datadog_synthetics_global_variable} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param name: Synthetics global variable name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#name SyntheticsGlobalVariable#name}
        :param value: The value of the global variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#value SyntheticsGlobalVariable#value}
        :param description: Description of the global variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#description SyntheticsGlobalVariable#description}
        :param parse_test_id: Id of the Synthetics test to use for a variable from test. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#parse_test_id SyntheticsGlobalVariable#parse_test_id}
        :param parse_test_options: parse_test_options block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#parse_test_options SyntheticsGlobalVariable#parse_test_options}
        :param secure: Sets the variable as secure. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#secure SyntheticsGlobalVariable#secure}
        :param tags: A list of tags to associate with your synthetics global variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#tags SyntheticsGlobalVariable#tags}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = SyntheticsGlobalVariableConfig(
            name=name,
            value=value,
            description=description,
            parse_test_id=parse_test_id,
            parse_test_options=parse_test_options,
            secure=secure,
            tags=tags,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(SyntheticsGlobalVariable, self, [scope, id, config])

    @jsii.member(jsii_name="resetDescription")
    def reset_description(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDescription", []))

    @jsii.member(jsii_name="resetParseTestId")
    def reset_parse_test_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetParseTestId", []))

    @jsii.member(jsii_name="resetParseTestOptions")
    def reset_parse_test_options(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetParseTestOptions", []))

    @jsii.member(jsii_name="resetSecure")
    def reset_secure(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSecure", []))

    @jsii.member(jsii_name="resetTags")
    def reset_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTags", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="valueInput")
    def value_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "valueInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="descriptionInput")
    def description_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "descriptionInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="parseTestIdInput")
    def parse_test_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "parseTestIdInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="parseTestOptionsInput")
    def parse_test_options_input(
        self,
    ) -> typing.Optional[typing.List["SyntheticsGlobalVariableParseTestOptions"]]:
        return typing.cast(typing.Optional[typing.List["SyntheticsGlobalVariableParseTestOptions"]], jsii.get(self, "parseTestOptionsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="secureInput")
    def secure_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "secureInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "description"))

    @description.setter
    def description(self, value: builtins.str) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="parseTestId")
    def parse_test_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "parseTestId"))

    @parse_test_id.setter
    def parse_test_id(self, value: builtins.str) -> None:
        jsii.set(self, "parseTestId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="parseTestOptions")
    def parse_test_options(
        self,
    ) -> typing.List["SyntheticsGlobalVariableParseTestOptions"]:
        return typing.cast(typing.List["SyntheticsGlobalVariableParseTestOptions"], jsii.get(self, "parseTestOptions"))

    @parse_test_options.setter
    def parse_test_options(
        self,
        value: typing.List["SyntheticsGlobalVariableParseTestOptions"],
    ) -> None:
        jsii.set(self, "parseTestOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="secure")
    def secure(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "secure"))

    @secure.setter
    def secure(self, value: builtins.bool) -> None:
        jsii.set(self, "secure", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "tags", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        jsii.set(self, "value", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsGlobalVariableConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "name": "name",
        "value": "value",
        "description": "description",
        "parse_test_id": "parseTestId",
        "parse_test_options": "parseTestOptions",
        "secure": "secure",
        "tags": "tags",
    },
)
class SyntheticsGlobalVariableConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        name: builtins.str,
        value: builtins.str,
        description: typing.Optional[builtins.str] = None,
        parse_test_id: typing.Optional[builtins.str] = None,
        parse_test_options: typing.Optional[typing.Sequence["SyntheticsGlobalVariableParseTestOptions"]] = None,
        secure: typing.Optional[builtins.bool] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param name: Synthetics global variable name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#name SyntheticsGlobalVariable#name}
        :param value: The value of the global variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#value SyntheticsGlobalVariable#value}
        :param description: Description of the global variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#description SyntheticsGlobalVariable#description}
        :param parse_test_id: Id of the Synthetics test to use for a variable from test. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#parse_test_id SyntheticsGlobalVariable#parse_test_id}
        :param parse_test_options: parse_test_options block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#parse_test_options SyntheticsGlobalVariable#parse_test_options}
        :param secure: Sets the variable as secure. Defaults to ``false``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#secure SyntheticsGlobalVariable#secure}
        :param tags: A list of tags to associate with your synthetics global variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#tags SyntheticsGlobalVariable#tags}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if description is not None:
            self._values["description"] = description
        if parse_test_id is not None:
            self._values["parse_test_id"] = parse_test_id
        if parse_test_options is not None:
            self._values["parse_test_options"] = parse_test_options
        if secure is not None:
            self._values["secure"] = secure
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Synthetics global variable name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#name SyntheticsGlobalVariable#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''The value of the global variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#value SyntheticsGlobalVariable#value}
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Description of the global variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#description SyntheticsGlobalVariable#description}
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parse_test_id(self) -> typing.Optional[builtins.str]:
        '''Id of the Synthetics test to use for a variable from test.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#parse_test_id SyntheticsGlobalVariable#parse_test_id}
        '''
        result = self._values.get("parse_test_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parse_test_options(
        self,
    ) -> typing.Optional[typing.List["SyntheticsGlobalVariableParseTestOptions"]]:
        '''parse_test_options block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#parse_test_options SyntheticsGlobalVariable#parse_test_options}
        '''
        result = self._values.get("parse_test_options")
        return typing.cast(typing.Optional[typing.List["SyntheticsGlobalVariableParseTestOptions"]], result)

    @builtins.property
    def secure(self) -> typing.Optional[builtins.bool]:
        '''Sets the variable as secure. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#secure SyntheticsGlobalVariable#secure}
        '''
        result = self._values.get("secure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of tags to associate with your synthetics global variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#tags SyntheticsGlobalVariable#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsGlobalVariableConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsGlobalVariableParseTestOptions",
    jsii_struct_bases=[],
    name_mapping={"parser": "parser", "type": "type", "field": "field"},
)
class SyntheticsGlobalVariableParseTestOptions:
    def __init__(
        self,
        *,
        parser: typing.Sequence["SyntheticsGlobalVariableParseTestOptionsParser"],
        type: builtins.str,
        field: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param parser: parser block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#parser SyntheticsGlobalVariable#parser}
        :param type: Defines the source to use to extract the value. Valid values are ``http_body``, ``http_header``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#type SyntheticsGlobalVariable#type}
        :param field: Required when type = ``http_header``. Defines the header to use to extract the value. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#field SyntheticsGlobalVariable#field}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "parser": parser,
            "type": type,
        }
        if field is not None:
            self._values["field"] = field

    @builtins.property
    def parser(self) -> typing.List["SyntheticsGlobalVariableParseTestOptionsParser"]:
        '''parser block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#parser SyntheticsGlobalVariable#parser}
        '''
        result = self._values.get("parser")
        assert result is not None, "Required property 'parser' is missing"
        return typing.cast(typing.List["SyntheticsGlobalVariableParseTestOptionsParser"], result)

    @builtins.property
    def type(self) -> builtins.str:
        '''Defines the source to use to extract the value. Valid values are ``http_body``, ``http_header``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#type SyntheticsGlobalVariable#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def field(self) -> typing.Optional[builtins.str]:
        '''Required when type = ``http_header``. Defines the header to use to extract the value.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#field SyntheticsGlobalVariable#field}
        '''
        result = self._values.get("field")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsGlobalVariableParseTestOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsGlobalVariableParseTestOptionsParser",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "value": "value"},
)
class SyntheticsGlobalVariableParseTestOptionsParser:
    def __init__(
        self,
        *,
        type: builtins.str,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: Type of parser to extract the value. Valid values are ``raw``, ``json_path``, ``regex``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#type SyntheticsGlobalVariable#type}
        :param value: Value for the parser to use, required for type ``json_path`` or ``regex``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#value SyntheticsGlobalVariable#value}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def type(self) -> builtins.str:
        '''Type of parser to extract the value. Valid values are ``raw``, ``json_path``, ``regex``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#type SyntheticsGlobalVariable#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value for the parser to use, required for type ``json_path`` or ``regex``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_global_variable.html#value SyntheticsGlobalVariable#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsGlobalVariableParseTestOptionsParser(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SyntheticsPrivateLocation(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.SyntheticsPrivateLocation",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_private_location.html datadog_synthetics_private_location}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        name: builtins.str,
        description: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_private_location.html datadog_synthetics_private_location} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param name: Synthetics private location name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_private_location.html#name SyntheticsPrivateLocation#name}
        :param description: Description of the private location. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_private_location.html#description SyntheticsPrivateLocation#description}
        :param tags: A list of tags to associate with your synthetics private location. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_private_location.html#tags SyntheticsPrivateLocation#tags}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = SyntheticsPrivateLocationConfig(
            name=name,
            description=description,
            tags=tags,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(SyntheticsPrivateLocation, self, [scope, id, config])

    @jsii.member(jsii_name="resetDescription")
    def reset_description(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDescription", []))

    @jsii.member(jsii_name="resetTags")
    def reset_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTags", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="config")
    def config(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "config"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="descriptionInput")
    def description_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "descriptionInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "description"))

    @description.setter
    def description(self, value: builtins.str) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "tags", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsPrivateLocationConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "name": "name",
        "description": "description",
        "tags": "tags",
    },
)
class SyntheticsPrivateLocationConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        name: builtins.str,
        description: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param name: Synthetics private location name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_private_location.html#name SyntheticsPrivateLocation#name}
        :param description: Description of the private location. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_private_location.html#description SyntheticsPrivateLocation#description}
        :param tags: A list of tags to associate with your synthetics private location. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_private_location.html#tags SyntheticsPrivateLocation#tags}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if description is not None:
            self._values["description"] = description
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Synthetics private location name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_private_location.html#name SyntheticsPrivateLocation#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Description of the private location.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_private_location.html#description SyntheticsPrivateLocation#description}
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of tags to associate with your synthetics private location.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_private_location.html#tags SyntheticsPrivateLocation#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsPrivateLocationConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SyntheticsTest(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.SyntheticsTest",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html datadog_synthetics_test}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        locations: typing.Sequence[builtins.str],
        name: builtins.str,
        status: builtins.str,
        type: builtins.str,
        api_step: typing.Optional[typing.Sequence["SyntheticsTestApiStep"]] = None,
        assertion: typing.Optional[typing.Sequence["SyntheticsTestAssertion"]] = None,
        browser_step: typing.Optional[typing.Sequence["SyntheticsTestBrowserStep"]] = None,
        browser_variable: typing.Optional[typing.Sequence["SyntheticsTestBrowserVariable"]] = None,
        config_variable: typing.Optional[typing.Sequence["SyntheticsTestConfigVariable"]] = None,
        device_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        message: typing.Optional[builtins.str] = None,
        options_list: typing.Optional[typing.Sequence["SyntheticsTestOptionsList"]] = None,
        request_basicauth: typing.Optional[typing.Sequence["SyntheticsTestRequestBasicauth"]] = None,
        request_client_certificate: typing.Optional[typing.Sequence["SyntheticsTestRequestClientCertificate"]] = None,
        request_definition: typing.Optional[typing.Sequence["SyntheticsTestRequestDefinition"]] = None,
        request_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        request_query: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        set_cookie: typing.Optional[builtins.str] = None,
        subtype: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html datadog_synthetics_test} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param locations: Array of locations used to run the test. Refer to `Datadog documentation <https://docs.datadoghq.com/synthetics/api_test/#request>`_ for available locations (e.g. ``aws:eu-central-1``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#locations SyntheticsTest#locations}
        :param name: Name of Datadog synthetics test. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        :param status: Define whether you want to start (``live``) or pause (``paused``) a Synthetic test. Valid values are ``live``, ``paused``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#status SyntheticsTest#status}
        :param type: Synthetics test type. Valid values are ``api``, ``browser``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        :param api_step: api_step block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#api_step SyntheticsTest#api_step}
        :param assertion: assertion block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#assertion SyntheticsTest#assertion}
        :param browser_step: browser_step block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#browser_step SyntheticsTest#browser_step}
        :param browser_variable: browser_variable block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#browser_variable SyntheticsTest#browser_variable}
        :param config_variable: config_variable block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#config_variable SyntheticsTest#config_variable}
        :param device_ids: Array with the different device IDs used to run the test (only for ``browser`` tests). Valid values are ``laptop_large``, ``tablet``, ``mobile_small``, ``chrome.laptop_large``, ``chrome.tablet``, ``chrome.mobile_small``, ``firefox.laptop_large``, ``firefox.tablet``, ``firefox.mobile_small``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#device_ids SyntheticsTest#device_ids}
        :param message: A message to include with notifications for this synthetics test. Email notifications can be sent to specific users by using the same ``@username`` notation as events. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#message SyntheticsTest#message}
        :param options_list: options_list block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#options_list SyntheticsTest#options_list}
        :param request_basicauth: request_basicauth block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_basicauth SyntheticsTest#request_basicauth}
        :param request_client_certificate: request_client_certificate block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_client_certificate SyntheticsTest#request_client_certificate}
        :param request_definition: request_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_definition SyntheticsTest#request_definition}
        :param request_headers: Header name and value map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_headers SyntheticsTest#request_headers}
        :param request_query: Query arguments name and value map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_query SyntheticsTest#request_query}
        :param set_cookie: Cookies to be used for a browser test request, using the `Set-Cookie <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie>`_ syntax. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#set_cookie SyntheticsTest#set_cookie}
        :param subtype: The subtype of the Synthetic API test. Defaults to ``http``. Valid values are ``http``, ``ssl``, ``tcp``, ``dns``, ``multi``, ``icmp``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#subtype SyntheticsTest#subtype}
        :param tags: A list of tags to associate with your synthetics test. This can help you categorize and filter tests in the manage synthetics page of the UI. Default is an empty list (``[]``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#tags SyntheticsTest#tags}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = SyntheticsTestConfig(
            locations=locations,
            name=name,
            status=status,
            type=type,
            api_step=api_step,
            assertion=assertion,
            browser_step=browser_step,
            browser_variable=browser_variable,
            config_variable=config_variable,
            device_ids=device_ids,
            message=message,
            options_list=options_list,
            request_basicauth=request_basicauth,
            request_client_certificate=request_client_certificate,
            request_definition=request_definition,
            request_headers=request_headers,
            request_query=request_query,
            set_cookie=set_cookie,
            subtype=subtype,
            tags=tags,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(SyntheticsTest, self, [scope, id, config])

    @jsii.member(jsii_name="resetApiStep")
    def reset_api_step(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetApiStep", []))

    @jsii.member(jsii_name="resetAssertion")
    def reset_assertion(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAssertion", []))

    @jsii.member(jsii_name="resetBrowserStep")
    def reset_browser_step(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBrowserStep", []))

    @jsii.member(jsii_name="resetBrowserVariable")
    def reset_browser_variable(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBrowserVariable", []))

    @jsii.member(jsii_name="resetConfigVariable")
    def reset_config_variable(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetConfigVariable", []))

    @jsii.member(jsii_name="resetDeviceIds")
    def reset_device_ids(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeviceIds", []))

    @jsii.member(jsii_name="resetMessage")
    def reset_message(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMessage", []))

    @jsii.member(jsii_name="resetOptionsList")
    def reset_options_list(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOptionsList", []))

    @jsii.member(jsii_name="resetRequestBasicauth")
    def reset_request_basicauth(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRequestBasicauth", []))

    @jsii.member(jsii_name="resetRequestClientCertificate")
    def reset_request_client_certificate(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRequestClientCertificate", []))

    @jsii.member(jsii_name="resetRequestDefinition")
    def reset_request_definition(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRequestDefinition", []))

    @jsii.member(jsii_name="resetRequestHeaders")
    def reset_request_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRequestHeaders", []))

    @jsii.member(jsii_name="resetRequestQuery")
    def reset_request_query(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRequestQuery", []))

    @jsii.member(jsii_name="resetSetCookie")
    def reset_set_cookie(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSetCookie", []))

    @jsii.member(jsii_name="resetSubtype")
    def reset_subtype(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSubtype", []))

    @jsii.member(jsii_name="resetTags")
    def reset_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTags", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="locationsInput")
    def locations_input(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "locationsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitorId")
    def monitor_id(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "monitorId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="statusInput")
    def status_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "statusInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "typeInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apiStepInput")
    def api_step_input(self) -> typing.Optional[typing.List["SyntheticsTestApiStep"]]:
        return typing.cast(typing.Optional[typing.List["SyntheticsTestApiStep"]], jsii.get(self, "apiStepInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="assertionInput")
    def assertion_input(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestAssertion"]]:
        return typing.cast(typing.Optional[typing.List["SyntheticsTestAssertion"]], jsii.get(self, "assertionInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="browserStepInput")
    def browser_step_input(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestBrowserStep"]]:
        return typing.cast(typing.Optional[typing.List["SyntheticsTestBrowserStep"]], jsii.get(self, "browserStepInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="browserVariableInput")
    def browser_variable_input(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestBrowserVariable"]]:
        return typing.cast(typing.Optional[typing.List["SyntheticsTestBrowserVariable"]], jsii.get(self, "browserVariableInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="configVariableInput")
    def config_variable_input(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestConfigVariable"]]:
        return typing.cast(typing.Optional[typing.List["SyntheticsTestConfigVariable"]], jsii.get(self, "configVariableInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="deviceIdsInput")
    def device_ids_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "deviceIdsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="messageInput")
    def message_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "messageInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="optionsListInput")
    def options_list_input(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestOptionsList"]]:
        return typing.cast(typing.Optional[typing.List["SyntheticsTestOptionsList"]], jsii.get(self, "optionsListInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requestBasicauthInput")
    def request_basicauth_input(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestRequestBasicauth"]]:
        return typing.cast(typing.Optional[typing.List["SyntheticsTestRequestBasicauth"]], jsii.get(self, "requestBasicauthInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requestClientCertificateInput")
    def request_client_certificate_input(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestRequestClientCertificate"]]:
        return typing.cast(typing.Optional[typing.List["SyntheticsTestRequestClientCertificate"]], jsii.get(self, "requestClientCertificateInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requestDefinitionInput")
    def request_definition_input(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestRequestDefinition"]]:
        return typing.cast(typing.Optional[typing.List["SyntheticsTestRequestDefinition"]], jsii.get(self, "requestDefinitionInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requestHeadersInput")
    def request_headers_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "requestHeadersInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requestQueryInput")
    def request_query_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "requestQueryInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="setCookieInput")
    def set_cookie_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "setCookieInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subtypeInput")
    def subtype_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subtypeInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "tagsInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="apiStep")
    def api_step(self) -> typing.List["SyntheticsTestApiStep"]:
        return typing.cast(typing.List["SyntheticsTestApiStep"], jsii.get(self, "apiStep"))

    @api_step.setter
    def api_step(self, value: typing.List["SyntheticsTestApiStep"]) -> None:
        jsii.set(self, "apiStep", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="assertion")
    def assertion(self) -> typing.List["SyntheticsTestAssertion"]:
        return typing.cast(typing.List["SyntheticsTestAssertion"], jsii.get(self, "assertion"))

    @assertion.setter
    def assertion(self, value: typing.List["SyntheticsTestAssertion"]) -> None:
        jsii.set(self, "assertion", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="browserStep")
    def browser_step(self) -> typing.List["SyntheticsTestBrowserStep"]:
        return typing.cast(typing.List["SyntheticsTestBrowserStep"], jsii.get(self, "browserStep"))

    @browser_step.setter
    def browser_step(self, value: typing.List["SyntheticsTestBrowserStep"]) -> None:
        jsii.set(self, "browserStep", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="browserVariable")
    def browser_variable(self) -> typing.List["SyntheticsTestBrowserVariable"]:
        return typing.cast(typing.List["SyntheticsTestBrowserVariable"], jsii.get(self, "browserVariable"))

    @browser_variable.setter
    def browser_variable(
        self,
        value: typing.List["SyntheticsTestBrowserVariable"],
    ) -> None:
        jsii.set(self, "browserVariable", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="configVariable")
    def config_variable(self) -> typing.List["SyntheticsTestConfigVariable"]:
        return typing.cast(typing.List["SyntheticsTestConfigVariable"], jsii.get(self, "configVariable"))

    @config_variable.setter
    def config_variable(
        self,
        value: typing.List["SyntheticsTestConfigVariable"],
    ) -> None:
        jsii.set(self, "configVariable", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="deviceIds")
    def device_ids(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "deviceIds"))

    @device_ids.setter
    def device_ids(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "deviceIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="locations")
    def locations(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "locations"))

    @locations.setter
    def locations(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "locations", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="message")
    def message(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "message"))

    @message.setter
    def message(self, value: builtins.str) -> None:
        jsii.set(self, "message", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="optionsList")
    def options_list(self) -> typing.List["SyntheticsTestOptionsList"]:
        return typing.cast(typing.List["SyntheticsTestOptionsList"], jsii.get(self, "optionsList"))

    @options_list.setter
    def options_list(self, value: typing.List["SyntheticsTestOptionsList"]) -> None:
        jsii.set(self, "optionsList", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requestBasicauth")
    def request_basicauth(self) -> typing.List["SyntheticsTestRequestBasicauth"]:
        return typing.cast(typing.List["SyntheticsTestRequestBasicauth"], jsii.get(self, "requestBasicauth"))

    @request_basicauth.setter
    def request_basicauth(
        self,
        value: typing.List["SyntheticsTestRequestBasicauth"],
    ) -> None:
        jsii.set(self, "requestBasicauth", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requestClientCertificate")
    def request_client_certificate(
        self,
    ) -> typing.List["SyntheticsTestRequestClientCertificate"]:
        return typing.cast(typing.List["SyntheticsTestRequestClientCertificate"], jsii.get(self, "requestClientCertificate"))

    @request_client_certificate.setter
    def request_client_certificate(
        self,
        value: typing.List["SyntheticsTestRequestClientCertificate"],
    ) -> None:
        jsii.set(self, "requestClientCertificate", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requestDefinition")
    def request_definition(self) -> typing.List["SyntheticsTestRequestDefinition"]:
        return typing.cast(typing.List["SyntheticsTestRequestDefinition"], jsii.get(self, "requestDefinition"))

    @request_definition.setter
    def request_definition(
        self,
        value: typing.List["SyntheticsTestRequestDefinition"],
    ) -> None:
        jsii.set(self, "requestDefinition", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requestHeaders")
    def request_headers(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "requestHeaders"))

    @request_headers.setter
    def request_headers(
        self,
        value: typing.Mapping[builtins.str, builtins.str],
    ) -> None:
        jsii.set(self, "requestHeaders", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="requestQuery")
    def request_query(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "requestQuery"))

    @request_query.setter
    def request_query(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        jsii.set(self, "requestQuery", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="setCookie")
    def set_cookie(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "setCookie"))

    @set_cookie.setter
    def set_cookie(self, value: builtins.str) -> None:
        jsii.set(self, "setCookie", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="status")
    def status(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "status"))

    @status.setter
    def status(self, value: builtins.str) -> None:
        jsii.set(self, "status", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subtype")
    def subtype(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subtype"))

    @subtype.setter
    def subtype(self, value: builtins.str) -> None:
        jsii.set(self, "subtype", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "tags", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        jsii.set(self, "type", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestApiStep",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "allow_failure": "allowFailure",
        "assertion": "assertion",
        "extracted_value": "extractedValue",
        "is_critical": "isCritical",
        "request_basicauth": "requestBasicauth",
        "request_client_certificate": "requestClientCertificate",
        "request_definition": "requestDefinition",
        "request_headers": "requestHeaders",
        "request_query": "requestQuery",
        "subtype": "subtype",
    },
)
class SyntheticsTestApiStep:
    def __init__(
        self,
        *,
        name: builtins.str,
        allow_failure: typing.Optional[builtins.bool] = None,
        assertion: typing.Optional[typing.Sequence["SyntheticsTestApiStepAssertion"]] = None,
        extracted_value: typing.Optional[typing.Sequence["SyntheticsTestApiStepExtractedValue"]] = None,
        is_critical: typing.Optional[builtins.bool] = None,
        request_basicauth: typing.Optional[typing.Sequence["SyntheticsTestApiStepRequestBasicauth"]] = None,
        request_client_certificate: typing.Optional[typing.Sequence["SyntheticsTestApiStepRequestClientCertificate"]] = None,
        request_definition: typing.Optional[typing.Sequence["SyntheticsTestApiStepRequestDefinition"]] = None,
        request_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        request_query: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        subtype: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: The name of the step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        :param allow_failure: Determines whether or not to continue with test if this step fails. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#allow_failure SyntheticsTest#allow_failure}
        :param assertion: assertion block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#assertion SyntheticsTest#assertion}
        :param extracted_value: extracted_value block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#extracted_value SyntheticsTest#extracted_value}
        :param is_critical: Determines whether or not to consider the entire test as failed if this step fails. Can be used only if ``allow_failure`` is ``true``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#is_critical SyntheticsTest#is_critical}
        :param request_basicauth: request_basicauth block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_basicauth SyntheticsTest#request_basicauth}
        :param request_client_certificate: request_client_certificate block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_client_certificate SyntheticsTest#request_client_certificate}
        :param request_definition: request_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_definition SyntheticsTest#request_definition}
        :param request_headers: Header name and value map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_headers SyntheticsTest#request_headers}
        :param request_query: Query arguments name and value map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_query SyntheticsTest#request_query}
        :param subtype: The subtype of the Synthetic multistep API test step. Valid values are ``http``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#subtype SyntheticsTest#subtype}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if allow_failure is not None:
            self._values["allow_failure"] = allow_failure
        if assertion is not None:
            self._values["assertion"] = assertion
        if extracted_value is not None:
            self._values["extracted_value"] = extracted_value
        if is_critical is not None:
            self._values["is_critical"] = is_critical
        if request_basicauth is not None:
            self._values["request_basicauth"] = request_basicauth
        if request_client_certificate is not None:
            self._values["request_client_certificate"] = request_client_certificate
        if request_definition is not None:
            self._values["request_definition"] = request_definition
        if request_headers is not None:
            self._values["request_headers"] = request_headers
        if request_query is not None:
            self._values["request_query"] = request_query
        if subtype is not None:
            self._values["subtype"] = subtype

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def allow_failure(self) -> typing.Optional[builtins.bool]:
        '''Determines whether or not to continue with test if this step fails.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#allow_failure SyntheticsTest#allow_failure}
        '''
        result = self._values.get("allow_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def assertion(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestApiStepAssertion"]]:
        '''assertion block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#assertion SyntheticsTest#assertion}
        '''
        result = self._values.get("assertion")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestApiStepAssertion"]], result)

    @builtins.property
    def extracted_value(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestApiStepExtractedValue"]]:
        '''extracted_value block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#extracted_value SyntheticsTest#extracted_value}
        '''
        result = self._values.get("extracted_value")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestApiStepExtractedValue"]], result)

    @builtins.property
    def is_critical(self) -> typing.Optional[builtins.bool]:
        '''Determines whether or not to consider the entire test as failed if this step fails.

        Can be used only if ``allow_failure`` is ``true``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#is_critical SyntheticsTest#is_critical}
        '''
        result = self._values.get("is_critical")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def request_basicauth(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestApiStepRequestBasicauth"]]:
        '''request_basicauth block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_basicauth SyntheticsTest#request_basicauth}
        '''
        result = self._values.get("request_basicauth")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestApiStepRequestBasicauth"]], result)

    @builtins.property
    def request_client_certificate(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestApiStepRequestClientCertificate"]]:
        '''request_client_certificate block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_client_certificate SyntheticsTest#request_client_certificate}
        '''
        result = self._values.get("request_client_certificate")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestApiStepRequestClientCertificate"]], result)

    @builtins.property
    def request_definition(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestApiStepRequestDefinition"]]:
        '''request_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_definition SyntheticsTest#request_definition}
        '''
        result = self._values.get("request_definition")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestApiStepRequestDefinition"]], result)

    @builtins.property
    def request_headers(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Header name and value map.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_headers SyntheticsTest#request_headers}
        '''
        result = self._values.get("request_headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def request_query(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Query arguments name and value map.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_query SyntheticsTest#request_query}
        '''
        result = self._values.get("request_query")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def subtype(self) -> typing.Optional[builtins.str]:
        '''The subtype of the Synthetic multistep API test step. Valid values are ``http``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#subtype SyntheticsTest#subtype}
        '''
        result = self._values.get("subtype")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestApiStep(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestApiStepAssertion",
    jsii_struct_bases=[],
    name_mapping={
        "operator": "operator",
        "type": "type",
        "property": "property",
        "target": "target",
        "targetjsonpath": "targetjsonpath",
    },
)
class SyntheticsTestApiStepAssertion:
    def __init__(
        self,
        *,
        operator: builtins.str,
        type: builtins.str,
        property: typing.Optional[builtins.str] = None,
        target: typing.Optional[builtins.str] = None,
        targetjsonpath: typing.Optional[typing.Sequence["SyntheticsTestApiStepAssertionTargetjsonpath"]] = None,
    ) -> None:
        '''
        :param operator: Assertion operator. **Note** Only some combinations of ``type`` and ``operator`` are valid (please refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#operator SyntheticsTest#operator}
        :param type: Type of assertion. **Note** Only some combinations of ``type`` and ``operator`` are valid (please refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_). Valid values are ``body``, ``header``, ``statusCode``, ``certificate``, ``responseTime``, ``property``, ``recordEvery``, ``recordSome``, ``tlsVersion``, ``minTlsVersion``, ``latency``, ``packetLossPercentage``, ``packetsReceived``, ``networkHop``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        :param property: If assertion type is ``header``, this is the header name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#property SyntheticsTest#property}
        :param target: Expected value. Depends on the assertion type, refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_ for details. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#target SyntheticsTest#target}
        :param targetjsonpath: targetjsonpath block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#targetjsonpath SyntheticsTest#targetjsonpath}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "operator": operator,
            "type": type,
        }
        if property is not None:
            self._values["property"] = property
        if target is not None:
            self._values["target"] = target
        if targetjsonpath is not None:
            self._values["targetjsonpath"] = targetjsonpath

    @builtins.property
    def operator(self) -> builtins.str:
        '''Assertion operator. **Note** Only some combinations of ``type`` and ``operator`` are valid (please refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#operator SyntheticsTest#operator}
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''Type of assertion.

        **Note** Only some combinations of ``type`` and ``operator`` are valid (please refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_). Valid values are ``body``, ``header``, ``statusCode``, ``certificate``, ``responseTime``, ``property``, ``recordEvery``, ``recordSome``, ``tlsVersion``, ``minTlsVersion``, ``latency``, ``packetLossPercentage``, ``packetsReceived``, ``networkHop``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''If assertion type is ``header``, this is the header name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#property SyntheticsTest#property}
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target(self) -> typing.Optional[builtins.str]:
        '''Expected value. Depends on the assertion type, refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_ for details.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#target SyntheticsTest#target}
        '''
        result = self._values.get("target")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def targetjsonpath(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestApiStepAssertionTargetjsonpath"]]:
        '''targetjsonpath block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#targetjsonpath SyntheticsTest#targetjsonpath}
        '''
        result = self._values.get("targetjsonpath")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestApiStepAssertionTargetjsonpath"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestApiStepAssertion(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestApiStepAssertionTargetjsonpath",
    jsii_struct_bases=[],
    name_mapping={
        "jsonpath": "jsonpath",
        "operator": "operator",
        "targetvalue": "targetvalue",
    },
)
class SyntheticsTestApiStepAssertionTargetjsonpath:
    def __init__(
        self,
        *,
        jsonpath: builtins.str,
        operator: builtins.str,
        targetvalue: builtins.str,
    ) -> None:
        '''
        :param jsonpath: The JSON path to assert. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#jsonpath SyntheticsTest#jsonpath}
        :param operator: The specific operator to use on the path. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#operator SyntheticsTest#operator}
        :param targetvalue: Expected matching value. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#targetvalue SyntheticsTest#targetvalue}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "jsonpath": jsonpath,
            "operator": operator,
            "targetvalue": targetvalue,
        }

    @builtins.property
    def jsonpath(self) -> builtins.str:
        '''The JSON path to assert.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#jsonpath SyntheticsTest#jsonpath}
        '''
        result = self._values.get("jsonpath")
        assert result is not None, "Required property 'jsonpath' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''The specific operator to use on the path.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#operator SyntheticsTest#operator}
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def targetvalue(self) -> builtins.str:
        '''Expected matching value.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#targetvalue SyntheticsTest#targetvalue}
        '''
        result = self._values.get("targetvalue")
        assert result is not None, "Required property 'targetvalue' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestApiStepAssertionTargetjsonpath(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestApiStepExtractedValue",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "parser": "parser",
        "type": "type",
        "field": "field",
    },
)
class SyntheticsTestApiStepExtractedValue:
    def __init__(
        self,
        *,
        name: builtins.str,
        parser: typing.Sequence["SyntheticsTestApiStepExtractedValueParser"],
        type: builtins.str,
        field: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}.
        :param parser: parser block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#parser SyntheticsTest#parser}
        :param type: Property of the Synthetics Test Response to use for the variable. Valid values are ``http_body``, ``http_header``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        :param field: When type is ``http_header``, name of the header to use to extract the value. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#field SyntheticsTest#field}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "parser": parser,
            "type": type,
        }
        if field is not None:
            self._values["field"] = field

    @builtins.property
    def name(self) -> builtins.str:
        '''Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def parser(self) -> typing.List["SyntheticsTestApiStepExtractedValueParser"]:
        '''parser block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#parser SyntheticsTest#parser}
        '''
        result = self._values.get("parser")
        assert result is not None, "Required property 'parser' is missing"
        return typing.cast(typing.List["SyntheticsTestApiStepExtractedValueParser"], result)

    @builtins.property
    def type(self) -> builtins.str:
        '''Property of the Synthetics Test Response to use for the variable. Valid values are ``http_body``, ``http_header``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def field(self) -> typing.Optional[builtins.str]:
        '''When type is ``http_header``, name of the header to use to extract the value.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#field SyntheticsTest#field}
        '''
        result = self._values.get("field")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestApiStepExtractedValue(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestApiStepExtractedValueParser",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "value": "value"},
)
class SyntheticsTestApiStepExtractedValueParser:
    def __init__(
        self,
        *,
        type: builtins.str,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: Type of parser for a Synthetics global variable from a synthetics test. Valid values are ``raw``, ``json_path``, ``regex``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        :param value: Regex or JSON path used for the parser. Not used with type ``raw``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#value SyntheticsTest#value}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def type(self) -> builtins.str:
        '''Type of parser for a Synthetics global variable from a synthetics test. Valid values are ``raw``, ``json_path``, ``regex``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Regex or JSON path used for the parser. Not used with type ``raw``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#value SyntheticsTest#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestApiStepExtractedValueParser(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestApiStepRequestBasicauth",
    jsii_struct_bases=[],
    name_mapping={"password": "password", "username": "username"},
)
class SyntheticsTestApiStepRequestBasicauth:
    def __init__(self, *, password: builtins.str, username: builtins.str) -> None:
        '''
        :param password: Password for authentication. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#password SyntheticsTest#password}
        :param username: Username for authentication. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#username SyntheticsTest#username}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "password": password,
            "username": username,
        }

    @builtins.property
    def password(self) -> builtins.str:
        '''Password for authentication.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#password SyntheticsTest#password}
        '''
        result = self._values.get("password")
        assert result is not None, "Required property 'password' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username for authentication.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#username SyntheticsTest#username}
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestApiStepRequestBasicauth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestApiStepRequestClientCertificate",
    jsii_struct_bases=[],
    name_mapping={"cert": "cert", "key": "key"},
)
class SyntheticsTestApiStepRequestClientCertificate:
    def __init__(
        self,
        *,
        cert: typing.Sequence["SyntheticsTestApiStepRequestClientCertificateCert"],
        key: typing.Sequence["SyntheticsTestApiStepRequestClientCertificateKey"],
    ) -> None:
        '''
        :param cert: cert block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#cert SyntheticsTest#cert}
        :param key: key block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#key SyntheticsTest#key}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "cert": cert,
            "key": key,
        }

    @builtins.property
    def cert(self) -> typing.List["SyntheticsTestApiStepRequestClientCertificateCert"]:
        '''cert block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#cert SyntheticsTest#cert}
        '''
        result = self._values.get("cert")
        assert result is not None, "Required property 'cert' is missing"
        return typing.cast(typing.List["SyntheticsTestApiStepRequestClientCertificateCert"], result)

    @builtins.property
    def key(self) -> typing.List["SyntheticsTestApiStepRequestClientCertificateKey"]:
        '''key block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#key SyntheticsTest#key}
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(typing.List["SyntheticsTestApiStepRequestClientCertificateKey"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestApiStepRequestClientCertificate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestApiStepRequestClientCertificateCert",
    jsii_struct_bases=[],
    name_mapping={"content": "content", "filename": "filename"},
)
class SyntheticsTestApiStepRequestClientCertificateCert:
    def __init__(
        self,
        *,
        content: builtins.str,
        filename: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param content: Content of the certificate. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#content SyntheticsTest#content}
        :param filename: File name for the certificate. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#filename SyntheticsTest#filename}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "content": content,
        }
        if filename is not None:
            self._values["filename"] = filename

    @builtins.property
    def content(self) -> builtins.str:
        '''Content of the certificate.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#content SyntheticsTest#content}
        '''
        result = self._values.get("content")
        assert result is not None, "Required property 'content' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filename(self) -> typing.Optional[builtins.str]:
        '''File name for the certificate.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#filename SyntheticsTest#filename}
        '''
        result = self._values.get("filename")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestApiStepRequestClientCertificateCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestApiStepRequestClientCertificateKey",
    jsii_struct_bases=[],
    name_mapping={"content": "content", "filename": "filename"},
)
class SyntheticsTestApiStepRequestClientCertificateKey:
    def __init__(
        self,
        *,
        content: builtins.str,
        filename: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param content: Content of the certificate. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#content SyntheticsTest#content}
        :param filename: File name for the certificate. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#filename SyntheticsTest#filename}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "content": content,
        }
        if filename is not None:
            self._values["filename"] = filename

    @builtins.property
    def content(self) -> builtins.str:
        '''Content of the certificate.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#content SyntheticsTest#content}
        '''
        result = self._values.get("content")
        assert result is not None, "Required property 'content' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filename(self) -> typing.Optional[builtins.str]:
        '''File name for the certificate.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#filename SyntheticsTest#filename}
        '''
        result = self._values.get("filename")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestApiStepRequestClientCertificateKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestApiStepRequestDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "body": "body",
        "dns_server": "dnsServer",
        "dns_server_port": "dnsServerPort",
        "host": "host",
        "method": "method",
        "no_saving_response_body": "noSavingResponseBody",
        "number_of_packets": "numberOfPackets",
        "port": "port",
        "should_track_hops": "shouldTrackHops",
        "timeout": "timeout",
        "url": "url",
    },
)
class SyntheticsTestApiStepRequestDefinition:
    def __init__(
        self,
        *,
        body: typing.Optional[builtins.str] = None,
        dns_server: typing.Optional[builtins.str] = None,
        dns_server_port: typing.Optional[jsii.Number] = None,
        host: typing.Optional[builtins.str] = None,
        method: typing.Optional[builtins.str] = None,
        no_saving_response_body: typing.Optional[builtins.bool] = None,
        number_of_packets: typing.Optional[jsii.Number] = None,
        port: typing.Optional[jsii.Number] = None,
        should_track_hops: typing.Optional[builtins.bool] = None,
        timeout: typing.Optional[jsii.Number] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param body: The request body. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#body SyntheticsTest#body}
        :param dns_server: DNS server to use for DNS tests (``subtype = "dns"``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#dns_server SyntheticsTest#dns_server}
        :param dns_server_port: DNS server port to use for DNS tests. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#dns_server_port SyntheticsTest#dns_server_port}
        :param host: Host name to perform the test with. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#host SyntheticsTest#host}
        :param method: The HTTP method. Valid values are ``GET``, ``POST``, ``PATCH``, ``PUT``, ``DELETE``, ``HEAD``, ``OPTIONS``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#method SyntheticsTest#method}
        :param no_saving_response_body: Determines whether or not to save the response body. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#no_saving_response_body SyntheticsTest#no_saving_response_body}
        :param number_of_packets: Number of pings to use per test for ICMP tests (``subtype = "icmp"``) between 0 and 10. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#number_of_packets SyntheticsTest#number_of_packets}
        :param port: Port to use when performing the test. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#port SyntheticsTest#port}
        :param should_track_hops: This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (``subtype = "icmp"``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#should_track_hops SyntheticsTest#should_track_hops}
        :param timeout: Timeout in seconds for the test. Defaults to ``60``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#timeout SyntheticsTest#timeout}
        :param url: The URL to send the request to. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#url SyntheticsTest#url}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if body is not None:
            self._values["body"] = body
        if dns_server is not None:
            self._values["dns_server"] = dns_server
        if dns_server_port is not None:
            self._values["dns_server_port"] = dns_server_port
        if host is not None:
            self._values["host"] = host
        if method is not None:
            self._values["method"] = method
        if no_saving_response_body is not None:
            self._values["no_saving_response_body"] = no_saving_response_body
        if number_of_packets is not None:
            self._values["number_of_packets"] = number_of_packets
        if port is not None:
            self._values["port"] = port
        if should_track_hops is not None:
            self._values["should_track_hops"] = should_track_hops
        if timeout is not None:
            self._values["timeout"] = timeout
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''The request body.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#body SyntheticsTest#body}
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_server(self) -> typing.Optional[builtins.str]:
        '''DNS server to use for DNS tests (``subtype = "dns"``).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#dns_server SyntheticsTest#dns_server}
        '''
        result = self._values.get("dns_server")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_server_port(self) -> typing.Optional[jsii.Number]:
        '''DNS server port to use for DNS tests.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#dns_server_port SyntheticsTest#dns_server_port}
        '''
        result = self._values.get("dns_server_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''Host name to perform the test with.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#host SyntheticsTest#host}
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''The HTTP method. Valid values are ``GET``, ``POST``, ``PATCH``, ``PUT``, ``DELETE``, ``HEAD``, ``OPTIONS``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#method SyntheticsTest#method}
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def no_saving_response_body(self) -> typing.Optional[builtins.bool]:
        '''Determines whether or not to save the response body.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#no_saving_response_body SyntheticsTest#no_saving_response_body}
        '''
        result = self._values.get("no_saving_response_body")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def number_of_packets(self) -> typing.Optional[jsii.Number]:
        '''Number of pings to use per test for ICMP tests (``subtype = "icmp"``) between 0 and 10.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#number_of_packets SyntheticsTest#number_of_packets}
        '''
        result = self._values.get("number_of_packets")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''Port to use when performing the test.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#port SyntheticsTest#port}
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def should_track_hops(self) -> typing.Optional[builtins.bool]:
        '''This will turn on a traceroute probe to discover all gateways along the path to the host destination.

        For ICMP tests (``subtype = "icmp"``).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#should_track_hops SyntheticsTest#should_track_hops}
        '''
        result = self._values.get("should_track_hops")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def timeout(self) -> typing.Optional[jsii.Number]:
        '''Timeout in seconds for the test. Defaults to ``60``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#timeout SyntheticsTest#timeout}
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''The URL to send the request to.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#url SyntheticsTest#url}
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestApiStepRequestDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestAssertion",
    jsii_struct_bases=[],
    name_mapping={
        "operator": "operator",
        "type": "type",
        "property": "property",
        "target": "target",
        "targetjsonpath": "targetjsonpath",
    },
)
class SyntheticsTestAssertion:
    def __init__(
        self,
        *,
        operator: builtins.str,
        type: builtins.str,
        property: typing.Optional[builtins.str] = None,
        target: typing.Optional[builtins.str] = None,
        targetjsonpath: typing.Optional[typing.Sequence["SyntheticsTestAssertionTargetjsonpath"]] = None,
    ) -> None:
        '''
        :param operator: Assertion operator. **Note** Only some combinations of ``type`` and ``operator`` are valid (please refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#operator SyntheticsTest#operator}
        :param type: Type of assertion. **Note** Only some combinations of ``type`` and ``operator`` are valid (please refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_). Valid values are ``body``, ``header``, ``statusCode``, ``certificate``, ``responseTime``, ``property``, ``recordEvery``, ``recordSome``, ``tlsVersion``, ``minTlsVersion``, ``latency``, ``packetLossPercentage``, ``packetsReceived``, ``networkHop``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        :param property: If assertion type is ``header``, this is the header name. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#property SyntheticsTest#property}
        :param target: Expected value. Depends on the assertion type, refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_ for details. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#target SyntheticsTest#target}
        :param targetjsonpath: targetjsonpath block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#targetjsonpath SyntheticsTest#targetjsonpath}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "operator": operator,
            "type": type,
        }
        if property is not None:
            self._values["property"] = property
        if target is not None:
            self._values["target"] = target
        if targetjsonpath is not None:
            self._values["targetjsonpath"] = targetjsonpath

    @builtins.property
    def operator(self) -> builtins.str:
        '''Assertion operator. **Note** Only some combinations of ``type`` and ``operator`` are valid (please refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#operator SyntheticsTest#operator}
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''Type of assertion.

        **Note** Only some combinations of ``type`` and ``operator`` are valid (please refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_). Valid values are ``body``, ``header``, ``statusCode``, ``certificate``, ``responseTime``, ``property``, ``recordEvery``, ``recordSome``, ``tlsVersion``, ``minTlsVersion``, ``latency``, ``packetLossPercentage``, ``packetsReceived``, ``networkHop``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''If assertion type is ``header``, this is the header name.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#property SyntheticsTest#property}
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target(self) -> typing.Optional[builtins.str]:
        '''Expected value. Depends on the assertion type, refer to `Datadog documentation <https://docs.datadoghq.com/api/latest/synthetics/#create-a-test>`_ for details.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#target SyntheticsTest#target}
        '''
        result = self._values.get("target")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def targetjsonpath(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestAssertionTargetjsonpath"]]:
        '''targetjsonpath block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#targetjsonpath SyntheticsTest#targetjsonpath}
        '''
        result = self._values.get("targetjsonpath")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestAssertionTargetjsonpath"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestAssertion(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestAssertionTargetjsonpath",
    jsii_struct_bases=[],
    name_mapping={
        "jsonpath": "jsonpath",
        "operator": "operator",
        "targetvalue": "targetvalue",
    },
)
class SyntheticsTestAssertionTargetjsonpath:
    def __init__(
        self,
        *,
        jsonpath: builtins.str,
        operator: builtins.str,
        targetvalue: builtins.str,
    ) -> None:
        '''
        :param jsonpath: The JSON path to assert. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#jsonpath SyntheticsTest#jsonpath}
        :param operator: The specific operator to use on the path. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#operator SyntheticsTest#operator}
        :param targetvalue: Expected matching value. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#targetvalue SyntheticsTest#targetvalue}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "jsonpath": jsonpath,
            "operator": operator,
            "targetvalue": targetvalue,
        }

    @builtins.property
    def jsonpath(self) -> builtins.str:
        '''The JSON path to assert.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#jsonpath SyntheticsTest#jsonpath}
        '''
        result = self._values.get("jsonpath")
        assert result is not None, "Required property 'jsonpath' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''The specific operator to use on the path.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#operator SyntheticsTest#operator}
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def targetvalue(self) -> builtins.str:
        '''Expected matching value.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#targetvalue SyntheticsTest#targetvalue}
        '''
        result = self._values.get("targetvalue")
        assert result is not None, "Required property 'targetvalue' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestAssertionTargetjsonpath(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestBrowserStep",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "params": "params",
        "type": "type",
        "allow_failure": "allowFailure",
        "force_element_update": "forceElementUpdate",
        "timeout": "timeout",
    },
)
class SyntheticsTestBrowserStep:
    def __init__(
        self,
        *,
        name: builtins.str,
        params: typing.Sequence["SyntheticsTestBrowserStepParams"],
        type: builtins.str,
        allow_failure: typing.Optional[builtins.bool] = None,
        force_element_update: typing.Optional[builtins.bool] = None,
        timeout: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param name: Name of the step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        :param params: params block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#params SyntheticsTest#params}
        :param type: Type of the step. Valid values are ``assertCurrentUrl``, ``assertElementAttribute``, ``assertElementContent``, ``assertElementPresent``, ``assertEmail``, ``assertFileDownload``, ``assertFromJavascript``, ``assertPageContains``, ``assertPageLacks``, ``click``, ``extractFromJavascript``, ``extractVariable``, ``goToEmailLink``, ``goToUrl``, ``goToUrlAndMeasureTti``, ``hover``, ``playSubTest``, ``pressKey``, ``refresh``, ``runApiTest``, ``scroll``, ``selectOption``, ``typeText``, ``uploadFiles``, ``wait``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        :param allow_failure: Determines if the step should be allowed to fail. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#allow_failure SyntheticsTest#allow_failure}
        :param force_element_update: Force update of the "element" parameter for the step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#force_element_update SyntheticsTest#force_element_update}
        :param timeout: Used to override the default timeout of a step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#timeout SyntheticsTest#timeout}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "params": params,
            "type": type,
        }
        if allow_failure is not None:
            self._values["allow_failure"] = allow_failure
        if force_element_update is not None:
            self._values["force_element_update"] = force_element_update
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def params(self) -> typing.List["SyntheticsTestBrowserStepParams"]:
        '''params block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#params SyntheticsTest#params}
        '''
        result = self._values.get("params")
        assert result is not None, "Required property 'params' is missing"
        return typing.cast(typing.List["SyntheticsTestBrowserStepParams"], result)

    @builtins.property
    def type(self) -> builtins.str:
        '''Type of the step.

        Valid values are ``assertCurrentUrl``, ``assertElementAttribute``, ``assertElementContent``, ``assertElementPresent``, ``assertEmail``, ``assertFileDownload``, ``assertFromJavascript``, ``assertPageContains``, ``assertPageLacks``, ``click``, ``extractFromJavascript``, ``extractVariable``, ``goToEmailLink``, ``goToUrl``, ``goToUrlAndMeasureTti``, ``hover``, ``playSubTest``, ``pressKey``, ``refresh``, ``runApiTest``, ``scroll``, ``selectOption``, ``typeText``, ``uploadFiles``, ``wait``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def allow_failure(self) -> typing.Optional[builtins.bool]:
        '''Determines if the step should be allowed to fail.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#allow_failure SyntheticsTest#allow_failure}
        '''
        result = self._values.get("allow_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def force_element_update(self) -> typing.Optional[builtins.bool]:
        '''Force update of the "element" parameter for the step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#force_element_update SyntheticsTest#force_element_update}
        '''
        result = self._values.get("force_element_update")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def timeout(self) -> typing.Optional[jsii.Number]:
        '''Used to override the default timeout of a step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#timeout SyntheticsTest#timeout}
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestBrowserStep(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestBrowserStepParams",
    jsii_struct_bases=[],
    name_mapping={
        "attribute": "attribute",
        "check": "check",
        "click_type": "clickType",
        "code": "code",
        "delay": "delay",
        "element": "element",
        "email": "email",
        "file": "file",
        "files": "files",
        "modifiers": "modifiers",
        "playing_tab_id": "playingTabId",
        "request": "request",
        "subtest_public_id": "subtestPublicId",
        "value": "value",
        "variable": "variable",
        "with_click": "withClick",
        "x": "x",
        "y": "y",
    },
)
class SyntheticsTestBrowserStepParams:
    def __init__(
        self,
        *,
        attribute: typing.Optional[builtins.str] = None,
        check: typing.Optional[builtins.str] = None,
        click_type: typing.Optional[builtins.str] = None,
        code: typing.Optional[builtins.str] = None,
        delay: typing.Optional[jsii.Number] = None,
        element: typing.Optional[builtins.str] = None,
        email: typing.Optional[builtins.str] = None,
        file: typing.Optional[builtins.str] = None,
        files: typing.Optional[builtins.str] = None,
        modifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
        playing_tab_id: typing.Optional[builtins.str] = None,
        request: typing.Optional[builtins.str] = None,
        subtest_public_id: typing.Optional[builtins.str] = None,
        value: typing.Optional[builtins.str] = None,
        variable: typing.Optional[typing.Sequence["SyntheticsTestBrowserStepParamsVariable"]] = None,
        with_click: typing.Optional[builtins.bool] = None,
        x: typing.Optional[jsii.Number] = None,
        y: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param attribute: Name of the attribute to use for an "assert attribute" step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#attribute SyntheticsTest#attribute}
        :param check: Check type to use for an assertion step. Valid values are ``equals``, ``notEquals``, ``contains``, ``notContains``, ``startsWith``, ``notStartsWith``, ``greater``, ``lower``, ``greaterEquals``, ``lowerEquals``, ``matchRegex``, ``between``, ``isEmpty``, ``notIsEmpty``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#check SyntheticsTest#check}
        :param click_type: Type of click to use for a "click" step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#click_type SyntheticsTest#click_type}
        :param code: Javascript code to use for the step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#code SyntheticsTest#code}
        :param delay: Delay between each key stroke for a "type test" step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#delay SyntheticsTest#delay}
        :param element: Element to use for the step, json encoded string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#element SyntheticsTest#element}
        :param email: Details of the email for an "assert email" step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#email SyntheticsTest#email}
        :param file: For an "assert download" step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#file SyntheticsTest#file}
        :param files: Details of the files for an "upload files" step, json encoded string. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#files SyntheticsTest#files}
        :param modifiers: Modifier to use for a "press key" step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#modifiers SyntheticsTest#modifiers}
        :param playing_tab_id: ID of the tab to play the subtest. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#playing_tab_id SyntheticsTest#playing_tab_id}
        :param request: Request for an API step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request SyntheticsTest#request}
        :param subtest_public_id: ID of the Synthetics test to use as subtest. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#subtest_public_id SyntheticsTest#subtest_public_id}
        :param value: Value of the step. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#value SyntheticsTest#value}
        :param variable: variable block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#variable SyntheticsTest#variable}
        :param with_click: For "file upload" steps. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#with_click SyntheticsTest#with_click}
        :param x: X coordinates for a "scroll step". Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#x SyntheticsTest#x}
        :param y: Y coordinates for a "scroll step". Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#y SyntheticsTest#y}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if attribute is not None:
            self._values["attribute"] = attribute
        if check is not None:
            self._values["check"] = check
        if click_type is not None:
            self._values["click_type"] = click_type
        if code is not None:
            self._values["code"] = code
        if delay is not None:
            self._values["delay"] = delay
        if element is not None:
            self._values["element"] = element
        if email is not None:
            self._values["email"] = email
        if file is not None:
            self._values["file"] = file
        if files is not None:
            self._values["files"] = files
        if modifiers is not None:
            self._values["modifiers"] = modifiers
        if playing_tab_id is not None:
            self._values["playing_tab_id"] = playing_tab_id
        if request is not None:
            self._values["request"] = request
        if subtest_public_id is not None:
            self._values["subtest_public_id"] = subtest_public_id
        if value is not None:
            self._values["value"] = value
        if variable is not None:
            self._values["variable"] = variable
        if with_click is not None:
            self._values["with_click"] = with_click
        if x is not None:
            self._values["x"] = x
        if y is not None:
            self._values["y"] = y

    @builtins.property
    def attribute(self) -> typing.Optional[builtins.str]:
        '''Name of the attribute to use for an "assert attribute" step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#attribute SyntheticsTest#attribute}
        '''
        result = self._values.get("attribute")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def check(self) -> typing.Optional[builtins.str]:
        '''Check type to use for an assertion step.

        Valid values are ``equals``, ``notEquals``, ``contains``, ``notContains``, ``startsWith``, ``notStartsWith``, ``greater``, ``lower``, ``greaterEquals``, ``lowerEquals``, ``matchRegex``, ``between``, ``isEmpty``, ``notIsEmpty``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#check SyntheticsTest#check}
        '''
        result = self._values.get("check")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def click_type(self) -> typing.Optional[builtins.str]:
        '''Type of click to use for a "click" step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#click_type SyntheticsTest#click_type}
        '''
        result = self._values.get("click_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def code(self) -> typing.Optional[builtins.str]:
        '''Javascript code to use for the step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#code SyntheticsTest#code}
        '''
        result = self._values.get("code")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def delay(self) -> typing.Optional[jsii.Number]:
        '''Delay between each key stroke for a "type test" step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#delay SyntheticsTest#delay}
        '''
        result = self._values.get("delay")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def element(self) -> typing.Optional[builtins.str]:
        '''Element to use for the step, json encoded string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#element SyntheticsTest#element}
        '''
        result = self._values.get("element")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def email(self) -> typing.Optional[builtins.str]:
        '''Details of the email for an "assert email" step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#email SyntheticsTest#email}
        '''
        result = self._values.get("email")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def file(self) -> typing.Optional[builtins.str]:
        '''For an "assert download" step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#file SyntheticsTest#file}
        '''
        result = self._values.get("file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def files(self) -> typing.Optional[builtins.str]:
        '''Details of the files for an "upload files" step, json encoded string.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#files SyntheticsTest#files}
        '''
        result = self._values.get("files")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def modifiers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Modifier to use for a "press key" step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#modifiers SyntheticsTest#modifiers}
        '''
        result = self._values.get("modifiers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def playing_tab_id(self) -> typing.Optional[builtins.str]:
        '''ID of the tab to play the subtest.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#playing_tab_id SyntheticsTest#playing_tab_id}
        '''
        result = self._values.get("playing_tab_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def request(self) -> typing.Optional[builtins.str]:
        '''Request for an API step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request SyntheticsTest#request}
        '''
        result = self._values.get("request")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subtest_public_id(self) -> typing.Optional[builtins.str]:
        '''ID of the Synthetics test to use as subtest.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#subtest_public_id SyntheticsTest#subtest_public_id}
        '''
        result = self._values.get("subtest_public_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value of the step.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#value SyntheticsTest#value}
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def variable(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestBrowserStepParamsVariable"]]:
        '''variable block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#variable SyntheticsTest#variable}
        '''
        result = self._values.get("variable")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestBrowserStepParamsVariable"]], result)

    @builtins.property
    def with_click(self) -> typing.Optional[builtins.bool]:
        '''For "file upload" steps.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#with_click SyntheticsTest#with_click}
        '''
        result = self._values.get("with_click")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def x(self) -> typing.Optional[jsii.Number]:
        '''X coordinates for a "scroll step".

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#x SyntheticsTest#x}
        '''
        result = self._values.get("x")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def y(self) -> typing.Optional[jsii.Number]:
        '''Y coordinates for a "scroll step".

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#y SyntheticsTest#y}
        '''
        result = self._values.get("y")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestBrowserStepParams(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestBrowserStepParamsVariable",
    jsii_struct_bases=[],
    name_mapping={"example": "example", "name": "name"},
)
class SyntheticsTestBrowserStepParamsVariable:
    def __init__(
        self,
        *,
        example: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param example: Example of the extracted variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#example SyntheticsTest#example}
        :param name: Name of the extracted variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if example is not None:
            self._values["example"] = example
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def example(self) -> typing.Optional[builtins.str]:
        '''Example of the extracted variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#example SyntheticsTest#example}
        '''
        result = self._values.get("example")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the extracted variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestBrowserStepParamsVariable(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestBrowserVariable",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "example": "example",
        "id": "id",
        "pattern": "pattern",
    },
)
class SyntheticsTestBrowserVariable:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: builtins.str,
        example: typing.Optional[builtins.str] = None,
        id: typing.Optional[builtins.str] = None,
        pattern: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Name of the variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        :param type: Type of browser test variable. Valid values are ``element``, ``email``, ``global``, ``javascript``, ``text``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        :param example: Example for the variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#example SyntheticsTest#example}
        :param id: ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type ``global``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#id SyntheticsTest#id}
        :param pattern: Pattern of the variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#pattern SyntheticsTest#pattern}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if example is not None:
            self._values["example"] = example
        if id is not None:
            self._values["id"] = id
        if pattern is not None:
            self._values["pattern"] = pattern

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''Type of browser test variable. Valid values are ``element``, ``email``, ``global``, ``javascript``, ``text``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def example(self) -> typing.Optional[builtins.str]:
        '''Example for the variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#example SyntheticsTest#example}
        '''
        result = self._values.get("example")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        '''ID of the global variable to use.

        This is actually only used (and required) in the case of using a variable of type ``global``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#id SyntheticsTest#id}
        '''
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pattern(self) -> typing.Optional[builtins.str]:
        '''Pattern of the variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#pattern SyntheticsTest#pattern}
        '''
        result = self._values.get("pattern")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestBrowserVariable(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "locations": "locations",
        "name": "name",
        "status": "status",
        "type": "type",
        "api_step": "apiStep",
        "assertion": "assertion",
        "browser_step": "browserStep",
        "browser_variable": "browserVariable",
        "config_variable": "configVariable",
        "device_ids": "deviceIds",
        "message": "message",
        "options_list": "optionsList",
        "request_basicauth": "requestBasicauth",
        "request_client_certificate": "requestClientCertificate",
        "request_definition": "requestDefinition",
        "request_headers": "requestHeaders",
        "request_query": "requestQuery",
        "set_cookie": "setCookie",
        "subtype": "subtype",
        "tags": "tags",
    },
)
class SyntheticsTestConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        locations: typing.Sequence[builtins.str],
        name: builtins.str,
        status: builtins.str,
        type: builtins.str,
        api_step: typing.Optional[typing.Sequence[SyntheticsTestApiStep]] = None,
        assertion: typing.Optional[typing.Sequence[SyntheticsTestAssertion]] = None,
        browser_step: typing.Optional[typing.Sequence[SyntheticsTestBrowserStep]] = None,
        browser_variable: typing.Optional[typing.Sequence[SyntheticsTestBrowserVariable]] = None,
        config_variable: typing.Optional[typing.Sequence["SyntheticsTestConfigVariable"]] = None,
        device_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        message: typing.Optional[builtins.str] = None,
        options_list: typing.Optional[typing.Sequence["SyntheticsTestOptionsList"]] = None,
        request_basicauth: typing.Optional[typing.Sequence["SyntheticsTestRequestBasicauth"]] = None,
        request_client_certificate: typing.Optional[typing.Sequence["SyntheticsTestRequestClientCertificate"]] = None,
        request_definition: typing.Optional[typing.Sequence["SyntheticsTestRequestDefinition"]] = None,
        request_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        request_query: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        set_cookie: typing.Optional[builtins.str] = None,
        subtype: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param locations: Array of locations used to run the test. Refer to `Datadog documentation <https://docs.datadoghq.com/synthetics/api_test/#request>`_ for available locations (e.g. ``aws:eu-central-1``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#locations SyntheticsTest#locations}
        :param name: Name of Datadog synthetics test. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        :param status: Define whether you want to start (``live``) or pause (``paused``) a Synthetic test. Valid values are ``live``, ``paused``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#status SyntheticsTest#status}
        :param type: Synthetics test type. Valid values are ``api``, ``browser``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        :param api_step: api_step block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#api_step SyntheticsTest#api_step}
        :param assertion: assertion block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#assertion SyntheticsTest#assertion}
        :param browser_step: browser_step block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#browser_step SyntheticsTest#browser_step}
        :param browser_variable: browser_variable block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#browser_variable SyntheticsTest#browser_variable}
        :param config_variable: config_variable block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#config_variable SyntheticsTest#config_variable}
        :param device_ids: Array with the different device IDs used to run the test (only for ``browser`` tests). Valid values are ``laptop_large``, ``tablet``, ``mobile_small``, ``chrome.laptop_large``, ``chrome.tablet``, ``chrome.mobile_small``, ``firefox.laptop_large``, ``firefox.tablet``, ``firefox.mobile_small``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#device_ids SyntheticsTest#device_ids}
        :param message: A message to include with notifications for this synthetics test. Email notifications can be sent to specific users by using the same ``@username`` notation as events. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#message SyntheticsTest#message}
        :param options_list: options_list block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#options_list SyntheticsTest#options_list}
        :param request_basicauth: request_basicauth block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_basicauth SyntheticsTest#request_basicauth}
        :param request_client_certificate: request_client_certificate block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_client_certificate SyntheticsTest#request_client_certificate}
        :param request_definition: request_definition block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_definition SyntheticsTest#request_definition}
        :param request_headers: Header name and value map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_headers SyntheticsTest#request_headers}
        :param request_query: Query arguments name and value map. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_query SyntheticsTest#request_query}
        :param set_cookie: Cookies to be used for a browser test request, using the `Set-Cookie <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie>`_ syntax. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#set_cookie SyntheticsTest#set_cookie}
        :param subtype: The subtype of the Synthetic API test. Defaults to ``http``. Valid values are ``http``, ``ssl``, ``tcp``, ``dns``, ``multi``, ``icmp``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#subtype SyntheticsTest#subtype}
        :param tags: A list of tags to associate with your synthetics test. This can help you categorize and filter tests in the manage synthetics page of the UI. Default is an empty list (``[]``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#tags SyntheticsTest#tags}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "locations": locations,
            "name": name,
            "status": status,
            "type": type,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if api_step is not None:
            self._values["api_step"] = api_step
        if assertion is not None:
            self._values["assertion"] = assertion
        if browser_step is not None:
            self._values["browser_step"] = browser_step
        if browser_variable is not None:
            self._values["browser_variable"] = browser_variable
        if config_variable is not None:
            self._values["config_variable"] = config_variable
        if device_ids is not None:
            self._values["device_ids"] = device_ids
        if message is not None:
            self._values["message"] = message
        if options_list is not None:
            self._values["options_list"] = options_list
        if request_basicauth is not None:
            self._values["request_basicauth"] = request_basicauth
        if request_client_certificate is not None:
            self._values["request_client_certificate"] = request_client_certificate
        if request_definition is not None:
            self._values["request_definition"] = request_definition
        if request_headers is not None:
            self._values["request_headers"] = request_headers
        if request_query is not None:
            self._values["request_query"] = request_query
        if set_cookie is not None:
            self._values["set_cookie"] = set_cookie
        if subtype is not None:
            self._values["subtype"] = subtype
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def locations(self) -> typing.List[builtins.str]:
        '''Array of locations used to run the test. Refer to `Datadog documentation <https://docs.datadoghq.com/synthetics/api_test/#request>`_ for available locations (e.g. ``aws:eu-central-1``).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#locations SyntheticsTest#locations}
        '''
        result = self._values.get("locations")
        assert result is not None, "Required property 'locations' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of Datadog synthetics test.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def status(self) -> builtins.str:
        '''Define whether you want to start (``live``) or pause (``paused``) a Synthetic test. Valid values are ``live``, ``paused``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#status SyntheticsTest#status}
        '''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''Synthetics test type. Valid values are ``api``, ``browser``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_step(self) -> typing.Optional[typing.List[SyntheticsTestApiStep]]:
        '''api_step block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#api_step SyntheticsTest#api_step}
        '''
        result = self._values.get("api_step")
        return typing.cast(typing.Optional[typing.List[SyntheticsTestApiStep]], result)

    @builtins.property
    def assertion(self) -> typing.Optional[typing.List[SyntheticsTestAssertion]]:
        '''assertion block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#assertion SyntheticsTest#assertion}
        '''
        result = self._values.get("assertion")
        return typing.cast(typing.Optional[typing.List[SyntheticsTestAssertion]], result)

    @builtins.property
    def browser_step(self) -> typing.Optional[typing.List[SyntheticsTestBrowserStep]]:
        '''browser_step block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#browser_step SyntheticsTest#browser_step}
        '''
        result = self._values.get("browser_step")
        return typing.cast(typing.Optional[typing.List[SyntheticsTestBrowserStep]], result)

    @builtins.property
    def browser_variable(
        self,
    ) -> typing.Optional[typing.List[SyntheticsTestBrowserVariable]]:
        '''browser_variable block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#browser_variable SyntheticsTest#browser_variable}
        '''
        result = self._values.get("browser_variable")
        return typing.cast(typing.Optional[typing.List[SyntheticsTestBrowserVariable]], result)

    @builtins.property
    def config_variable(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestConfigVariable"]]:
        '''config_variable block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#config_variable SyntheticsTest#config_variable}
        '''
        result = self._values.get("config_variable")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestConfigVariable"]], result)

    @builtins.property
    def device_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array with the different device IDs used to run the test (only for ``browser`` tests).

        Valid values are ``laptop_large``, ``tablet``, ``mobile_small``, ``chrome.laptop_large``, ``chrome.tablet``, ``chrome.mobile_small``, ``firefox.laptop_large``, ``firefox.tablet``, ``firefox.mobile_small``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#device_ids SyntheticsTest#device_ids}
        '''
        result = self._values.get("device_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def message(self) -> typing.Optional[builtins.str]:
        '''A message to include with notifications for this synthetics test.

        Email notifications can be sent to specific users by using the same ``@username`` notation as events.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#message SyntheticsTest#message}
        '''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def options_list(self) -> typing.Optional[typing.List["SyntheticsTestOptionsList"]]:
        '''options_list block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#options_list SyntheticsTest#options_list}
        '''
        result = self._values.get("options_list")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestOptionsList"]], result)

    @builtins.property
    def request_basicauth(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestRequestBasicauth"]]:
        '''request_basicauth block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_basicauth SyntheticsTest#request_basicauth}
        '''
        result = self._values.get("request_basicauth")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestRequestBasicauth"]], result)

    @builtins.property
    def request_client_certificate(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestRequestClientCertificate"]]:
        '''request_client_certificate block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_client_certificate SyntheticsTest#request_client_certificate}
        '''
        result = self._values.get("request_client_certificate")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestRequestClientCertificate"]], result)

    @builtins.property
    def request_definition(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestRequestDefinition"]]:
        '''request_definition block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_definition SyntheticsTest#request_definition}
        '''
        result = self._values.get("request_definition")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestRequestDefinition"]], result)

    @builtins.property
    def request_headers(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Header name and value map.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_headers SyntheticsTest#request_headers}
        '''
        result = self._values.get("request_headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def request_query(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Query arguments name and value map.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#request_query SyntheticsTest#request_query}
        '''
        result = self._values.get("request_query")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def set_cookie(self) -> typing.Optional[builtins.str]:
        '''Cookies to be used for a browser test request, using the `Set-Cookie <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie>`_ syntax.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#set_cookie SyntheticsTest#set_cookie}
        '''
        result = self._values.get("set_cookie")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subtype(self) -> typing.Optional[builtins.str]:
        '''The subtype of the Synthetic API test. Defaults to ``http``. Valid values are ``http``, ``ssl``, ``tcp``, ``dns``, ``multi``, ``icmp``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#subtype SyntheticsTest#subtype}
        '''
        result = self._values.get("subtype")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of tags to associate with your synthetics test.

        This can help you categorize and filter tests in the manage synthetics page of the UI. Default is an empty list (``[]``).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#tags SyntheticsTest#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestConfigVariable",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "example": "example",
        "id": "id",
        "pattern": "pattern",
    },
)
class SyntheticsTestConfigVariable:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: builtins.str,
        example: typing.Optional[builtins.str] = None,
        id: typing.Optional[builtins.str] = None,
        pattern: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: Name of the variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        :param type: Type of test configuration variable. Valid values are ``global``, ``text``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        :param example: Example for the variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#example SyntheticsTest#example}
        :param id: When type = ``global``, ID of the global variable to use. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#id SyntheticsTest#id}
        :param pattern: Pattern of the variable. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#pattern SyntheticsTest#pattern}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if example is not None:
            self._values["example"] = example
        if id is not None:
            self._values["id"] = id
        if pattern is not None:
            self._values["pattern"] = pattern

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#name SyntheticsTest#name}
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''Type of test configuration variable. Valid values are ``global``, ``text``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#type SyntheticsTest#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def example(self) -> typing.Optional[builtins.str]:
        '''Example for the variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#example SyntheticsTest#example}
        '''
        result = self._values.get("example")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        '''When type = ``global``, ID of the global variable to use.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#id SyntheticsTest#id}
        '''
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pattern(self) -> typing.Optional[builtins.str]:
        '''Pattern of the variable.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#pattern SyntheticsTest#pattern}
        '''
        result = self._values.get("pattern")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestConfigVariable(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestOptionsList",
    jsii_struct_bases=[],
    name_mapping={
        "tick_every": "tickEvery",
        "accept_self_signed": "acceptSelfSigned",
        "allow_insecure": "allowInsecure",
        "follow_redirects": "followRedirects",
        "min_failure_duration": "minFailureDuration",
        "min_location_failed": "minLocationFailed",
        "monitor_name": "monitorName",
        "monitor_options": "monitorOptions",
        "monitor_priority": "monitorPriority",
        "no_screenshot": "noScreenshot",
        "retry": "retry",
    },
)
class SyntheticsTestOptionsList:
    def __init__(
        self,
        *,
        tick_every: jsii.Number,
        accept_self_signed: typing.Optional[builtins.bool] = None,
        allow_insecure: typing.Optional[builtins.bool] = None,
        follow_redirects: typing.Optional[builtins.bool] = None,
        min_failure_duration: typing.Optional[jsii.Number] = None,
        min_location_failed: typing.Optional[jsii.Number] = None,
        monitor_name: typing.Optional[builtins.str] = None,
        monitor_options: typing.Optional[typing.Sequence["SyntheticsTestOptionsListMonitorOptions"]] = None,
        monitor_priority: typing.Optional[jsii.Number] = None,
        no_screenshot: typing.Optional[builtins.bool] = None,
        retry: typing.Optional[typing.Sequence["SyntheticsTestOptionsListRetry"]] = None,
    ) -> None:
        '''
        :param tick_every: How often the test should run (in seconds). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#tick_every SyntheticsTest#tick_every}
        :param accept_self_signed: For SSL test, whether or not the test should allow self signed certificates. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#accept_self_signed SyntheticsTest#accept_self_signed}
        :param allow_insecure: Allows loading insecure content for an HTTP test. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#allow_insecure SyntheticsTest#allow_insecure}
        :param follow_redirects: For API HTTP test, whether or not the test should follow redirects. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#follow_redirects SyntheticsTest#follow_redirects}
        :param min_failure_duration: Minimum amount of time in failure required to trigger an alert. Default is ``0``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#min_failure_duration SyntheticsTest#min_failure_duration}
        :param min_location_failed: Minimum number of locations in failure required to trigger an alert. Default is ``1``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#min_location_failed SyntheticsTest#min_location_failed}
        :param monitor_name: The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#monitor_name SyntheticsTest#monitor_name}
        :param monitor_options: monitor_options block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#monitor_options SyntheticsTest#monitor_options}
        :param monitor_priority: Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#monitor_priority SyntheticsTest#monitor_priority}.
        :param no_screenshot: Prevents saving screenshots of the steps. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#no_screenshot SyntheticsTest#no_screenshot}
        :param retry: retry block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#retry SyntheticsTest#retry}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "tick_every": tick_every,
        }
        if accept_self_signed is not None:
            self._values["accept_self_signed"] = accept_self_signed
        if allow_insecure is not None:
            self._values["allow_insecure"] = allow_insecure
        if follow_redirects is not None:
            self._values["follow_redirects"] = follow_redirects
        if min_failure_duration is not None:
            self._values["min_failure_duration"] = min_failure_duration
        if min_location_failed is not None:
            self._values["min_location_failed"] = min_location_failed
        if monitor_name is not None:
            self._values["monitor_name"] = monitor_name
        if monitor_options is not None:
            self._values["monitor_options"] = monitor_options
        if monitor_priority is not None:
            self._values["monitor_priority"] = monitor_priority
        if no_screenshot is not None:
            self._values["no_screenshot"] = no_screenshot
        if retry is not None:
            self._values["retry"] = retry

    @builtins.property
    def tick_every(self) -> jsii.Number:
        '''How often the test should run (in seconds).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#tick_every SyntheticsTest#tick_every}
        '''
        result = self._values.get("tick_every")
        assert result is not None, "Required property 'tick_every' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def accept_self_signed(self) -> typing.Optional[builtins.bool]:
        '''For SSL test, whether or not the test should allow self signed certificates.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#accept_self_signed SyntheticsTest#accept_self_signed}
        '''
        result = self._values.get("accept_self_signed")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def allow_insecure(self) -> typing.Optional[builtins.bool]:
        '''Allows loading insecure content for an HTTP test.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#allow_insecure SyntheticsTest#allow_insecure}
        '''
        result = self._values.get("allow_insecure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def follow_redirects(self) -> typing.Optional[builtins.bool]:
        '''For API HTTP test, whether or not the test should follow redirects.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#follow_redirects SyntheticsTest#follow_redirects}
        '''
        result = self._values.get("follow_redirects")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_failure_duration(self) -> typing.Optional[jsii.Number]:
        '''Minimum amount of time in failure required to trigger an alert. Default is ``0``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#min_failure_duration SyntheticsTest#min_failure_duration}
        '''
        result = self._values.get("min_failure_duration")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_location_failed(self) -> typing.Optional[jsii.Number]:
        '''Minimum number of locations in failure required to trigger an alert. Default is ``1``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#min_location_failed SyntheticsTest#min_location_failed}
        '''
        result = self._values.get("min_location_failed")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitor_name(self) -> typing.Optional[builtins.str]:
        '''The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#monitor_name SyntheticsTest#monitor_name}
        '''
        result = self._values.get("monitor_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitor_options(
        self,
    ) -> typing.Optional[typing.List["SyntheticsTestOptionsListMonitorOptions"]]:
        '''monitor_options block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#monitor_options SyntheticsTest#monitor_options}
        '''
        result = self._values.get("monitor_options")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestOptionsListMonitorOptions"]], result)

    @builtins.property
    def monitor_priority(self) -> typing.Optional[jsii.Number]:
        '''Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#monitor_priority SyntheticsTest#monitor_priority}.'''
        result = self._values.get("monitor_priority")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def no_screenshot(self) -> typing.Optional[builtins.bool]:
        '''Prevents saving screenshots of the steps.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#no_screenshot SyntheticsTest#no_screenshot}
        '''
        result = self._values.get("no_screenshot")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def retry(self) -> typing.Optional[typing.List["SyntheticsTestOptionsListRetry"]]:
        '''retry block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#retry SyntheticsTest#retry}
        '''
        result = self._values.get("retry")
        return typing.cast(typing.Optional[typing.List["SyntheticsTestOptionsListRetry"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestOptionsList(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestOptionsListMonitorOptions",
    jsii_struct_bases=[],
    name_mapping={"renotify_interval": "renotifyInterval"},
)
class SyntheticsTestOptionsListMonitorOptions:
    def __init__(
        self,
        *,
        renotify_interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param renotify_interval: Specify a renotification frequency. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#renotify_interval SyntheticsTest#renotify_interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if renotify_interval is not None:
            self._values["renotify_interval"] = renotify_interval

    @builtins.property
    def renotify_interval(self) -> typing.Optional[jsii.Number]:
        '''Specify a renotification frequency.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#renotify_interval SyntheticsTest#renotify_interval}
        '''
        result = self._values.get("renotify_interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestOptionsListMonitorOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestOptionsListRetry",
    jsii_struct_bases=[],
    name_mapping={"count": "count", "interval": "interval"},
)
class SyntheticsTestOptionsListRetry:
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param count: Number of retries needed to consider a location as failed before sending a notification alert. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#count SyntheticsTest#count}
        :param interval: Interval between a failed test and the next retry in milliseconds. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#interval SyntheticsTest#interval}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if interval is not None:
            self._values["interval"] = interval

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''Number of retries needed to consider a location as failed before sending a notification alert.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#count SyntheticsTest#count}
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''Interval between a failed test and the next retry in milliseconds.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#interval SyntheticsTest#interval}
        '''
        result = self._values.get("interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestOptionsListRetry(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestRequestBasicauth",
    jsii_struct_bases=[],
    name_mapping={"password": "password", "username": "username"},
)
class SyntheticsTestRequestBasicauth:
    def __init__(self, *, password: builtins.str, username: builtins.str) -> None:
        '''
        :param password: Password for authentication. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#password SyntheticsTest#password}
        :param username: Username for authentication. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#username SyntheticsTest#username}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "password": password,
            "username": username,
        }

    @builtins.property
    def password(self) -> builtins.str:
        '''Password for authentication.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#password SyntheticsTest#password}
        '''
        result = self._values.get("password")
        assert result is not None, "Required property 'password' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username for authentication.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#username SyntheticsTest#username}
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestRequestBasicauth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestRequestClientCertificate",
    jsii_struct_bases=[],
    name_mapping={"cert": "cert", "key": "key"},
)
class SyntheticsTestRequestClientCertificate:
    def __init__(
        self,
        *,
        cert: typing.Sequence["SyntheticsTestRequestClientCertificateCert"],
        key: typing.Sequence["SyntheticsTestRequestClientCertificateKey"],
    ) -> None:
        '''
        :param cert: cert block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#cert SyntheticsTest#cert}
        :param key: key block. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#key SyntheticsTest#key}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "cert": cert,
            "key": key,
        }

    @builtins.property
    def cert(self) -> typing.List["SyntheticsTestRequestClientCertificateCert"]:
        '''cert block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#cert SyntheticsTest#cert}
        '''
        result = self._values.get("cert")
        assert result is not None, "Required property 'cert' is missing"
        return typing.cast(typing.List["SyntheticsTestRequestClientCertificateCert"], result)

    @builtins.property
    def key(self) -> typing.List["SyntheticsTestRequestClientCertificateKey"]:
        '''key block.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#key SyntheticsTest#key}
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(typing.List["SyntheticsTestRequestClientCertificateKey"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestRequestClientCertificate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestRequestClientCertificateCert",
    jsii_struct_bases=[],
    name_mapping={"content": "content", "filename": "filename"},
)
class SyntheticsTestRequestClientCertificateCert:
    def __init__(
        self,
        *,
        content: builtins.str,
        filename: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param content: Content of the certificate. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#content SyntheticsTest#content}
        :param filename: File name for the certificate. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#filename SyntheticsTest#filename}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "content": content,
        }
        if filename is not None:
            self._values["filename"] = filename

    @builtins.property
    def content(self) -> builtins.str:
        '''Content of the certificate.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#content SyntheticsTest#content}
        '''
        result = self._values.get("content")
        assert result is not None, "Required property 'content' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filename(self) -> typing.Optional[builtins.str]:
        '''File name for the certificate.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#filename SyntheticsTest#filename}
        '''
        result = self._values.get("filename")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestRequestClientCertificateCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestRequestClientCertificateKey",
    jsii_struct_bases=[],
    name_mapping={"content": "content", "filename": "filename"},
)
class SyntheticsTestRequestClientCertificateKey:
    def __init__(
        self,
        *,
        content: builtins.str,
        filename: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param content: Content of the certificate. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#content SyntheticsTest#content}
        :param filename: File name for the certificate. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#filename SyntheticsTest#filename}
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "content": content,
        }
        if filename is not None:
            self._values["filename"] = filename

    @builtins.property
    def content(self) -> builtins.str:
        '''Content of the certificate.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#content SyntheticsTest#content}
        '''
        result = self._values.get("content")
        assert result is not None, "Required property 'content' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filename(self) -> typing.Optional[builtins.str]:
        '''File name for the certificate.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#filename SyntheticsTest#filename}
        '''
        result = self._values.get("filename")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestRequestClientCertificateKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.SyntheticsTestRequestDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "body": "body",
        "dns_server": "dnsServer",
        "dns_server_port": "dnsServerPort",
        "host": "host",
        "method": "method",
        "no_saving_response_body": "noSavingResponseBody",
        "number_of_packets": "numberOfPackets",
        "port": "port",
        "should_track_hops": "shouldTrackHops",
        "timeout": "timeout",
        "url": "url",
    },
)
class SyntheticsTestRequestDefinition:
    def __init__(
        self,
        *,
        body: typing.Optional[builtins.str] = None,
        dns_server: typing.Optional[builtins.str] = None,
        dns_server_port: typing.Optional[jsii.Number] = None,
        host: typing.Optional[builtins.str] = None,
        method: typing.Optional[builtins.str] = None,
        no_saving_response_body: typing.Optional[builtins.bool] = None,
        number_of_packets: typing.Optional[jsii.Number] = None,
        port: typing.Optional[jsii.Number] = None,
        should_track_hops: typing.Optional[builtins.bool] = None,
        timeout: typing.Optional[jsii.Number] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param body: The request body. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#body SyntheticsTest#body}
        :param dns_server: DNS server to use for DNS tests (``subtype = "dns"``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#dns_server SyntheticsTest#dns_server}
        :param dns_server_port: DNS server port to use for DNS tests. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#dns_server_port SyntheticsTest#dns_server_port}
        :param host: Host name to perform the test with. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#host SyntheticsTest#host}
        :param method: The HTTP method. Valid values are ``GET``, ``POST``, ``PATCH``, ``PUT``, ``DELETE``, ``HEAD``, ``OPTIONS``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#method SyntheticsTest#method}
        :param no_saving_response_body: Determines whether or not to save the response body. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#no_saving_response_body SyntheticsTest#no_saving_response_body}
        :param number_of_packets: Number of pings to use per test for ICMP tests (``subtype = "icmp"``) between 0 and 10. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#number_of_packets SyntheticsTest#number_of_packets}
        :param port: Port to use when performing the test. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#port SyntheticsTest#port}
        :param should_track_hops: This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (``subtype = "icmp"``). Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#should_track_hops SyntheticsTest#should_track_hops}
        :param timeout: Timeout in seconds for the test. Defaults to ``60``. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#timeout SyntheticsTest#timeout}
        :param url: The URL to send the request to. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#url SyntheticsTest#url}
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if body is not None:
            self._values["body"] = body
        if dns_server is not None:
            self._values["dns_server"] = dns_server
        if dns_server_port is not None:
            self._values["dns_server_port"] = dns_server_port
        if host is not None:
            self._values["host"] = host
        if method is not None:
            self._values["method"] = method
        if no_saving_response_body is not None:
            self._values["no_saving_response_body"] = no_saving_response_body
        if number_of_packets is not None:
            self._values["number_of_packets"] = number_of_packets
        if port is not None:
            self._values["port"] = port
        if should_track_hops is not None:
            self._values["should_track_hops"] = should_track_hops
        if timeout is not None:
            self._values["timeout"] = timeout
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''The request body.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#body SyntheticsTest#body}
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_server(self) -> typing.Optional[builtins.str]:
        '''DNS server to use for DNS tests (``subtype = "dns"``).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#dns_server SyntheticsTest#dns_server}
        '''
        result = self._values.get("dns_server")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_server_port(self) -> typing.Optional[jsii.Number]:
        '''DNS server port to use for DNS tests.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#dns_server_port SyntheticsTest#dns_server_port}
        '''
        result = self._values.get("dns_server_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''Host name to perform the test with.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#host SyntheticsTest#host}
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''The HTTP method. Valid values are ``GET``, ``POST``, ``PATCH``, ``PUT``, ``DELETE``, ``HEAD``, ``OPTIONS``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#method SyntheticsTest#method}
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def no_saving_response_body(self) -> typing.Optional[builtins.bool]:
        '''Determines whether or not to save the response body.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#no_saving_response_body SyntheticsTest#no_saving_response_body}
        '''
        result = self._values.get("no_saving_response_body")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def number_of_packets(self) -> typing.Optional[jsii.Number]:
        '''Number of pings to use per test for ICMP tests (``subtype = "icmp"``) between 0 and 10.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#number_of_packets SyntheticsTest#number_of_packets}
        '''
        result = self._values.get("number_of_packets")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''Port to use when performing the test.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#port SyntheticsTest#port}
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def should_track_hops(self) -> typing.Optional[builtins.bool]:
        '''This will turn on a traceroute probe to discover all gateways along the path to the host destination.

        For ICMP tests (``subtype = "icmp"``).

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#should_track_hops SyntheticsTest#should_track_hops}
        '''
        result = self._values.get("should_track_hops")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def timeout(self) -> typing.Optional[jsii.Number]:
        '''Timeout in seconds for the test. Defaults to ``60``.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#timeout SyntheticsTest#timeout}
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''The URL to send the request to.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/synthetics_test.html#url SyntheticsTest#url}
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsTestRequestDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class User(
    cdktf.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdktf/provider-datadog.User",
):
    '''Represents a {@link https://www.terraform.io/docs/providers/datadog/r/user.html datadog_user}.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        email: builtins.str,
        disabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        roles: typing.Optional[typing.Sequence[builtins.str]] = None,
        send_user_invitation: typing.Optional[builtins.bool] = None,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
    ) -> None:
        '''Create a new {@link https://www.terraform.io/docs/providers/datadog/r/user.html datadog_user} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param email: Email address for user. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#email User#email}
        :param disabled: Whether the user is disabled. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#disabled User#disabled}
        :param name: Name for user. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#name User#name}
        :param roles: A list a role IDs to assign to the user. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#roles User#roles}
        :param send_user_invitation: Whether an invitation email should be sent when the user is created. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#send_user_invitation User#send_user_invitation}
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        '''
        config = UserConfig(
            email=email,
            disabled=disabled,
            name=name,
            roles=roles,
            send_user_invitation=send_user_invitation,
            count=count,
            depends_on=depends_on,
            lifecycle=lifecycle,
            provider=provider,
        )

        jsii.create(User, self, [scope, id, config])

    @jsii.member(jsii_name="resetDisabled")
    def reset_disabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisabled", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetRoles")
    def reset_roles(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRoles", []))

    @jsii.member(jsii_name="resetSendUserInvitation")
    def reset_send_user_invitation(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSendUserInvitation", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="emailInput")
    def email_input(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "emailInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="userInvitationId")
    def user_invitation_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "userInvitationId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="verified")
    def verified(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "verified"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="disabledInput")
    def disabled_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "disabledInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="rolesInput")
    def roles_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "rolesInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sendUserInvitationInput")
    def send_user_invitation_input(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "sendUserInvitationInput"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="disabled")
    def disabled(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "disabled"))

    @disabled.setter
    def disabled(self, value: builtins.bool) -> None:
        jsii.set(self, "disabled", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="email")
    def email(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "email"))

    @email.setter
    def email(self, value: builtins.str) -> None:
        jsii.set(self, "email", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        jsii.set(self, "name", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="roles")
    def roles(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "roles"))

    @roles.setter
    def roles(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "roles", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sendUserInvitation")
    def send_user_invitation(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "sendUserInvitation"))

    @send_user_invitation.setter
    def send_user_invitation(self, value: builtins.bool) -> None:
        jsii.set(self, "sendUserInvitation", value)


@jsii.data_type(
    jsii_type="@cdktf/provider-datadog.UserConfig",
    jsii_struct_bases=[cdktf.TerraformMetaArguments],
    name_mapping={
        "count": "count",
        "depends_on": "dependsOn",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "email": "email",
        "disabled": "disabled",
        "name": "name",
        "roles": "roles",
        "send_user_invitation": "sendUserInvitation",
    },
)
class UserConfig(cdktf.TerraformMetaArguments):
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        depends_on: typing.Optional[typing.Sequence[cdktf.ITerraformDependable]] = None,
        lifecycle: typing.Optional[cdktf.TerraformResourceLifecycle] = None,
        provider: typing.Optional[cdktf.TerraformProvider] = None,
        email: builtins.str,
        disabled: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        roles: typing.Optional[typing.Sequence[builtins.str]] = None,
        send_user_invitation: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param count: 
        :param depends_on: 
        :param lifecycle: 
        :param provider: 
        :param email: Email address for user. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#email User#email}
        :param disabled: Whether the user is disabled. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#disabled User#disabled}
        :param name: Name for user. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#name User#name}
        :param roles: A list a role IDs to assign to the user. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#roles User#roles}
        :param send_user_invitation: Whether an invitation email should be sent when the user is created. Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#send_user_invitation User#send_user_invitation}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = cdktf.TerraformResourceLifecycle(**lifecycle)
        self._values: typing.Dict[str, typing.Any] = {
            "email": email,
        }
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if disabled is not None:
            self._values["disabled"] = disabled
        if name is not None:
            self._values["name"] = name
        if roles is not None:
            self._values["roles"] = roles
        if send_user_invitation is not None:
            self._values["send_user_invitation"] = send_user_invitation

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[cdktf.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[cdktf.ITerraformDependable]], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[cdktf.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[cdktf.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[cdktf.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[cdktf.TerraformProvider], result)

    @builtins.property
    def email(self) -> builtins.str:
        '''Email address for user.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#email User#email}
        '''
        result = self._values.get("email")
        assert result is not None, "Required property 'email' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def disabled(self) -> typing.Optional[builtins.bool]:
        '''Whether the user is disabled.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#disabled User#disabled}
        '''
        result = self._values.get("disabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name for user.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#name User#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def roles(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list a role IDs to assign to the user.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#roles User#roles}
        '''
        result = self._values.get("roles")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def send_user_invitation(self) -> typing.Optional[builtins.bool]:
        '''Whether an invitation email should be sent when the user is created.

        Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/datadog/r/user.html#send_user_invitation User#send_user_invitation}
        '''
        result = self._values.get("send_user_invitation")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UserConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "Dashboard",
    "DashboardConfig",
    "DashboardJson",
    "DashboardJsonConfig",
    "DashboardList",
    "DashboardListConfig",
    "DashboardListDashItem",
    "DashboardTemplateVariable",
    "DashboardTemplateVariablePreset",
    "DashboardTemplateVariablePresetTemplateVariable",
    "DashboardWidget",
    "DashboardWidgetAlertGraphDefinition",
    "DashboardWidgetAlertValueDefinition",
    "DashboardWidgetChangeDefinition",
    "DashboardWidgetChangeDefinitionCustomLink",
    "DashboardWidgetChangeDefinitionRequest",
    "DashboardWidgetChangeDefinitionRequestApmQuery",
    "DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetChangeDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetChangeDefinitionRequestLogQuery",
    "DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetChangeDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetChangeDefinitionRequestProcessQuery",
    "DashboardWidgetChangeDefinitionRequestRumQuery",
    "DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetChangeDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetChangeDefinitionRequestSecurityQuery",
    "DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetCheckStatusDefinition",
    "DashboardWidgetDistributionDefinition",
    "DashboardWidgetDistributionDefinitionRequest",
    "DashboardWidgetDistributionDefinitionRequestApmQuery",
    "DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetDistributionDefinitionRequestLogQuery",
    "DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetDistributionDefinitionRequestProcessQuery",
    "DashboardWidgetDistributionDefinitionRequestRumQuery",
    "DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetDistributionDefinitionRequestSecurityQuery",
    "DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetDistributionDefinitionRequestStyle",
    "DashboardWidgetEventStreamDefinition",
    "DashboardWidgetEventTimelineDefinition",
    "DashboardWidgetFreeTextDefinition",
    "DashboardWidgetGeomapDefinition",
    "DashboardWidgetGeomapDefinitionCustomLink",
    "DashboardWidgetGeomapDefinitionRequest",
    "DashboardWidgetGeomapDefinitionRequestFormula",
    "DashboardWidgetGeomapDefinitionRequestFormulaLimit",
    "DashboardWidgetGeomapDefinitionRequestLogQuery",
    "DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetGeomapDefinitionRequestQuery",
    "DashboardWidgetGeomapDefinitionRequestQueryEventQuery",
    "DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute",
    "DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy",
    "DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort",
    "DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch",
    "DashboardWidgetGeomapDefinitionRequestQueryMetricQuery",
    "DashboardWidgetGeomapDefinitionRequestQueryProcessQuery",
    "DashboardWidgetGeomapDefinitionRequestRumQuery",
    "DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetGeomapDefinitionStyle",
    "DashboardWidgetGeomapDefinitionView",
    "DashboardWidgetGroupDefinition",
    "DashboardWidgetGroupDefinitionWidget",
    "DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition",
    "DashboardWidgetGroupDefinitionWidgetAlertValueDefinition",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinition",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinition",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle",
    "DashboardWidgetGroupDefinitionWidgetEventStreamDefinition",
    "DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition",
    "DashboardWidgetGroupDefinitionWidgetFreeTextDefinition",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinition",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle",
    "DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinition",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle",
    "DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinition",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle",
    "DashboardWidgetGroupDefinitionWidgetIframeDefinition",
    "DashboardWidgetGroupDefinitionWidgetImageDefinition",
    "DashboardWidgetGroupDefinitionWidgetLogStreamDefinition",
    "DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort",
    "DashboardWidgetGroupDefinitionWidgetManageStatusDefinition",
    "DashboardWidgetGroupDefinitionWidgetNoteDefinition",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinition",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumns",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormats",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinition",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormats",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinition",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis",
    "DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis",
    "DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition",
    "DashboardWidgetGroupDefinitionWidgetServicemapDefinition",
    "DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis",
    "DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinition",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormats",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle",
    "DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition",
    "DashboardWidgetGroupDefinitionWidgetWidgetLayout",
    "DashboardWidgetHeatmapDefinition",
    "DashboardWidgetHeatmapDefinitionCustomLink",
    "DashboardWidgetHeatmapDefinitionEvent",
    "DashboardWidgetHeatmapDefinitionRequest",
    "DashboardWidgetHeatmapDefinitionRequestApmQuery",
    "DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetHeatmapDefinitionRequestLogQuery",
    "DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetHeatmapDefinitionRequestProcessQuery",
    "DashboardWidgetHeatmapDefinitionRequestRumQuery",
    "DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetHeatmapDefinitionRequestSecurityQuery",
    "DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetHeatmapDefinitionRequestStyle",
    "DashboardWidgetHeatmapDefinitionYaxis",
    "DashboardWidgetHostmapDefinition",
    "DashboardWidgetHostmapDefinitionCustomLink",
    "DashboardWidgetHostmapDefinitionRequest",
    "DashboardWidgetHostmapDefinitionRequestFill",
    "DashboardWidgetHostmapDefinitionRequestFillApmQuery",
    "DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery",
    "DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy",
    "DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery",
    "DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute",
    "DashboardWidgetHostmapDefinitionRequestFillLogQuery",
    "DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery",
    "DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy",
    "DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery",
    "DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute",
    "DashboardWidgetHostmapDefinitionRequestFillProcessQuery",
    "DashboardWidgetHostmapDefinitionRequestFillRumQuery",
    "DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery",
    "DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy",
    "DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery",
    "DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute",
    "DashboardWidgetHostmapDefinitionRequestFillSecurityQuery",
    "DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery",
    "DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy",
    "DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery",
    "DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute",
    "DashboardWidgetHostmapDefinitionRequestSize",
    "DashboardWidgetHostmapDefinitionRequestSizeApmQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy",
    "DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute",
    "DashboardWidgetHostmapDefinitionRequestSizeLogQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy",
    "DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute",
    "DashboardWidgetHostmapDefinitionRequestSizeProcessQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeRumQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy",
    "DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute",
    "DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy",
    "DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery",
    "DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute",
    "DashboardWidgetHostmapDefinitionStyle",
    "DashboardWidgetIframeDefinition",
    "DashboardWidgetImageDefinition",
    "DashboardWidgetLogStreamDefinition",
    "DashboardWidgetLogStreamDefinitionSort",
    "DashboardWidgetManageStatusDefinition",
    "DashboardWidgetNoteDefinition",
    "DashboardWidgetQueryTableDefinition",
    "DashboardWidgetQueryTableDefinitionCustomLink",
    "DashboardWidgetQueryTableDefinitionRequest",
    "DashboardWidgetQueryTableDefinitionRequestApmQuery",
    "DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetQueryTableDefinitionRequestApmStatsQuery",
    "DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumns",
    "DashboardWidgetQueryTableDefinitionRequestConditionalFormats",
    "DashboardWidgetQueryTableDefinitionRequestLogQuery",
    "DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetQueryTableDefinitionRequestProcessQuery",
    "DashboardWidgetQueryTableDefinitionRequestRumQuery",
    "DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetQueryTableDefinitionRequestSecurityQuery",
    "DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetQueryValueDefinition",
    "DashboardWidgetQueryValueDefinitionCustomLink",
    "DashboardWidgetQueryValueDefinitionRequest",
    "DashboardWidgetQueryValueDefinitionRequestApmQuery",
    "DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetQueryValueDefinitionRequestConditionalFormats",
    "DashboardWidgetQueryValueDefinitionRequestFormula",
    "DashboardWidgetQueryValueDefinitionRequestFormulaLimit",
    "DashboardWidgetQueryValueDefinitionRequestLogQuery",
    "DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetQueryValueDefinitionRequestProcessQuery",
    "DashboardWidgetQueryValueDefinitionRequestQuery",
    "DashboardWidgetQueryValueDefinitionRequestQueryEventQuery",
    "DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute",
    "DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy",
    "DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort",
    "DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch",
    "DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery",
    "DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery",
    "DashboardWidgetQueryValueDefinitionRequestRumQuery",
    "DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetQueryValueDefinitionRequestSecurityQuery",
    "DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetScatterplotDefinition",
    "DashboardWidgetScatterplotDefinitionCustomLink",
    "DashboardWidgetScatterplotDefinitionRequest",
    "DashboardWidgetScatterplotDefinitionRequestX",
    "DashboardWidgetScatterplotDefinitionRequestXApmQuery",
    "DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery",
    "DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy",
    "DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery",
    "DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute",
    "DashboardWidgetScatterplotDefinitionRequestXLogQuery",
    "DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery",
    "DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy",
    "DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery",
    "DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute",
    "DashboardWidgetScatterplotDefinitionRequestXProcessQuery",
    "DashboardWidgetScatterplotDefinitionRequestXRumQuery",
    "DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery",
    "DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy",
    "DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery",
    "DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute",
    "DashboardWidgetScatterplotDefinitionRequestXSecurityQuery",
    "DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery",
    "DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy",
    "DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery",
    "DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute",
    "DashboardWidgetScatterplotDefinitionRequestY",
    "DashboardWidgetScatterplotDefinitionRequestYApmQuery",
    "DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery",
    "DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy",
    "DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery",
    "DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute",
    "DashboardWidgetScatterplotDefinitionRequestYLogQuery",
    "DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery",
    "DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy",
    "DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery",
    "DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute",
    "DashboardWidgetScatterplotDefinitionRequestYProcessQuery",
    "DashboardWidgetScatterplotDefinitionRequestYRumQuery",
    "DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery",
    "DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy",
    "DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery",
    "DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute",
    "DashboardWidgetScatterplotDefinitionRequestYSecurityQuery",
    "DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery",
    "DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy",
    "DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery",
    "DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute",
    "DashboardWidgetScatterplotDefinitionXaxis",
    "DashboardWidgetScatterplotDefinitionYaxis",
    "DashboardWidgetServiceLevelObjectiveDefinition",
    "DashboardWidgetServicemapDefinition",
    "DashboardWidgetServicemapDefinitionCustomLink",
    "DashboardWidgetTimeseriesDefinition",
    "DashboardWidgetTimeseriesDefinitionCustomLink",
    "DashboardWidgetTimeseriesDefinitionEvent",
    "DashboardWidgetTimeseriesDefinitionMarker",
    "DashboardWidgetTimeseriesDefinitionRequest",
    "DashboardWidgetTimeseriesDefinitionRequestApmQuery",
    "DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetTimeseriesDefinitionRequestFormula",
    "DashboardWidgetTimeseriesDefinitionRequestFormulaLimit",
    "DashboardWidgetTimeseriesDefinitionRequestLogQuery",
    "DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetTimeseriesDefinitionRequestMetadata",
    "DashboardWidgetTimeseriesDefinitionRequestNetworkQuery",
    "DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery",
    "DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy",
    "DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery",
    "DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute",
    "DashboardWidgetTimeseriesDefinitionRequestProcessQuery",
    "DashboardWidgetTimeseriesDefinitionRequestQuery",
    "DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery",
    "DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute",
    "DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy",
    "DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort",
    "DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch",
    "DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery",
    "DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery",
    "DashboardWidgetTimeseriesDefinitionRequestRumQuery",
    "DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetTimeseriesDefinitionRequestSecurityQuery",
    "DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetTimeseriesDefinitionRequestStyle",
    "DashboardWidgetTimeseriesDefinitionRightYaxis",
    "DashboardWidgetTimeseriesDefinitionYaxis",
    "DashboardWidgetToplistDefinition",
    "DashboardWidgetToplistDefinitionCustomLink",
    "DashboardWidgetToplistDefinitionRequest",
    "DashboardWidgetToplistDefinitionRequestApmQuery",
    "DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery",
    "DashboardWidgetToplistDefinitionRequestApmQueryGroupBy",
    "DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery",
    "DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute",
    "DashboardWidgetToplistDefinitionRequestConditionalFormats",
    "DashboardWidgetToplistDefinitionRequestFormula",
    "DashboardWidgetToplistDefinitionRequestFormulaLimit",
    "DashboardWidgetToplistDefinitionRequestLogQuery",
    "DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery",
    "DashboardWidgetToplistDefinitionRequestLogQueryGroupBy",
    "DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery",
    "DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute",
    "DashboardWidgetToplistDefinitionRequestProcessQuery",
    "DashboardWidgetToplistDefinitionRequestQuery",
    "DashboardWidgetToplistDefinitionRequestQueryEventQuery",
    "DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute",
    "DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy",
    "DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort",
    "DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch",
    "DashboardWidgetToplistDefinitionRequestQueryMetricQuery",
    "DashboardWidgetToplistDefinitionRequestQueryProcessQuery",
    "DashboardWidgetToplistDefinitionRequestRumQuery",
    "DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery",
    "DashboardWidgetToplistDefinitionRequestRumQueryGroupBy",
    "DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery",
    "DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute",
    "DashboardWidgetToplistDefinitionRequestSecurityQuery",
    "DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery",
    "DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy",
    "DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery",
    "DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute",
    "DashboardWidgetToplistDefinitionRequestStyle",
    "DashboardWidgetTraceServiceDefinition",
    "DashboardWidgetWidgetLayout",
    "DataDatadogDashboard",
    "DataDatadogDashboardConfig",
    "DataDatadogDashboardList",
    "DataDatadogDashboardListConfig",
    "DataDatadogIpRanges",
    "DataDatadogIpRangesConfig",
    "DataDatadogMonitor",
    "DataDatadogMonitorConfig",
    "DataDatadogMonitorMonitorThresholdWindows",
    "DataDatadogMonitorMonitorThresholds",
    "DataDatadogMonitors",
    "DataDatadogMonitorsConfig",
    "DataDatadogMonitorsMonitors",
    "DataDatadogPermissions",
    "DataDatadogPermissionsConfig",
    "DataDatadogRole",
    "DataDatadogRoleConfig",
    "DataDatadogSecurityMonitoringRules",
    "DataDatadogSecurityMonitoringRulesConfig",
    "DataDatadogSecurityMonitoringRulesRules",
    "DataDatadogSecurityMonitoringRulesRulesCase",
    "DataDatadogSecurityMonitoringRulesRulesFilter",
    "DataDatadogSecurityMonitoringRulesRulesOptions",
    "DataDatadogSecurityMonitoringRulesRulesOptionsNewValueOptions",
    "DataDatadogSecurityMonitoringRulesRulesQuery",
    "DataDatadogServiceLevelObjective",
    "DataDatadogServiceLevelObjectiveConfig",
    "DataDatadogServiceLevelObjectives",
    "DataDatadogServiceLevelObjectivesConfig",
    "DataDatadogServiceLevelObjectivesSlos",
    "DataDatadogSyntheticsLocations",
    "DataDatadogSyntheticsLocationsConfig",
    "DatadogProvider",
    "DatadogProviderConfig",
    "Downtime",
    "DowntimeConfig",
    "DowntimeRecurrence",
    "IntegrationAws",
    "IntegrationAwsConfig",
    "IntegrationAwsLambdaArn",
    "IntegrationAwsLambdaArnConfig",
    "IntegrationAwsLogCollection",
    "IntegrationAwsLogCollectionConfig",
    "IntegrationAwsTagFilter",
    "IntegrationAwsTagFilterConfig",
    "IntegrationAzure",
    "IntegrationAzureConfig",
    "IntegrationGcp",
    "IntegrationGcpConfig",
    "IntegrationPagerduty",
    "IntegrationPagerdutyConfig",
    "IntegrationPagerdutyServiceObject",
    "IntegrationPagerdutyServiceObjectConfig",
    "IntegrationSlackChannel",
    "IntegrationSlackChannelConfig",
    "IntegrationSlackChannelDisplay",
    "LogsArchive",
    "LogsArchiveAzureArchive",
    "LogsArchiveConfig",
    "LogsArchiveGcsArchive",
    "LogsArchiveOrder",
    "LogsArchiveOrderConfig",
    "LogsArchiveS3Archive",
    "LogsCustomPipeline",
    "LogsCustomPipelineConfig",
    "LogsCustomPipelineFilter",
    "LogsCustomPipelineProcessor",
    "LogsCustomPipelineProcessorArithmeticProcessor",
    "LogsCustomPipelineProcessorAttributeRemapper",
    "LogsCustomPipelineProcessorCategoryProcessor",
    "LogsCustomPipelineProcessorCategoryProcessorCategory",
    "LogsCustomPipelineProcessorCategoryProcessorCategoryFilter",
    "LogsCustomPipelineProcessorDateRemapper",
    "LogsCustomPipelineProcessorGeoIpParser",
    "LogsCustomPipelineProcessorGrokParser",
    "LogsCustomPipelineProcessorGrokParserGrok",
    "LogsCustomPipelineProcessorLookupProcessor",
    "LogsCustomPipelineProcessorMessageRemapper",
    "LogsCustomPipelineProcessorPipeline",
    "LogsCustomPipelineProcessorPipelineFilter",
    "LogsCustomPipelineProcessorPipelineProcessor",
    "LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor",
    "LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper",
    "LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor",
    "LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory",
    "LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter",
    "LogsCustomPipelineProcessorPipelineProcessorDateRemapper",
    "LogsCustomPipelineProcessorPipelineProcessorGeoIpParser",
    "LogsCustomPipelineProcessorPipelineProcessorGrokParser",
    "LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok",
    "LogsCustomPipelineProcessorPipelineProcessorLookupProcessor",
    "LogsCustomPipelineProcessorPipelineProcessorMessageRemapper",
    "LogsCustomPipelineProcessorPipelineProcessorServiceRemapper",
    "LogsCustomPipelineProcessorPipelineProcessorStatusRemapper",
    "LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor",
    "LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper",
    "LogsCustomPipelineProcessorPipelineProcessorUrlParser",
    "LogsCustomPipelineProcessorPipelineProcessorUserAgentParser",
    "LogsCustomPipelineProcessorServiceRemapper",
    "LogsCustomPipelineProcessorStatusRemapper",
    "LogsCustomPipelineProcessorStringBuilderProcessor",
    "LogsCustomPipelineProcessorTraceIdRemapper",
    "LogsCustomPipelineProcessorUrlParser",
    "LogsCustomPipelineProcessorUserAgentParser",
    "LogsIndex",
    "LogsIndexConfig",
    "LogsIndexExclusionFilter",
    "LogsIndexExclusionFilterFilter",
    "LogsIndexFilter",
    "LogsIndexOrder",
    "LogsIndexOrderConfig",
    "LogsIntegrationPipeline",
    "LogsIntegrationPipelineConfig",
    "LogsMetric",
    "LogsMetricCompute",
    "LogsMetricConfig",
    "LogsMetricFilter",
    "LogsMetricGroupBy",
    "LogsPipelineOrder",
    "LogsPipelineOrderConfig",
    "MetricMetadata",
    "MetricMetadataConfig",
    "MetricTagConfiguration",
    "MetricTagConfigurationConfig",
    "Monitor",
    "MonitorConfig",
    "MonitorMonitorThresholdWindows",
    "MonitorMonitorThresholds",
    "Role",
    "RoleConfig",
    "RolePermission",
    "SecurityMonitoringDefaultRule",
    "SecurityMonitoringDefaultRuleCase",
    "SecurityMonitoringDefaultRuleConfig",
    "SecurityMonitoringDefaultRuleFilter",
    "SecurityMonitoringRule",
    "SecurityMonitoringRuleCase",
    "SecurityMonitoringRuleConfig",
    "SecurityMonitoringRuleFilter",
    "SecurityMonitoringRuleOptions",
    "SecurityMonitoringRuleOptionsNewValueOptions",
    "SecurityMonitoringRuleQuery",
    "ServiceLevelObjective",
    "ServiceLevelObjectiveConfig",
    "ServiceLevelObjectiveQuery",
    "ServiceLevelObjectiveThresholds",
    "SloCorrection",
    "SloCorrectionConfig",
    "SyntheticsGlobalVariable",
    "SyntheticsGlobalVariableConfig",
    "SyntheticsGlobalVariableParseTestOptions",
    "SyntheticsGlobalVariableParseTestOptionsParser",
    "SyntheticsPrivateLocation",
    "SyntheticsPrivateLocationConfig",
    "SyntheticsTest",
    "SyntheticsTestApiStep",
    "SyntheticsTestApiStepAssertion",
    "SyntheticsTestApiStepAssertionTargetjsonpath",
    "SyntheticsTestApiStepExtractedValue",
    "SyntheticsTestApiStepExtractedValueParser",
    "SyntheticsTestApiStepRequestBasicauth",
    "SyntheticsTestApiStepRequestClientCertificate",
    "SyntheticsTestApiStepRequestClientCertificateCert",
    "SyntheticsTestApiStepRequestClientCertificateKey",
    "SyntheticsTestApiStepRequestDefinition",
    "SyntheticsTestAssertion",
    "SyntheticsTestAssertionTargetjsonpath",
    "SyntheticsTestBrowserStep",
    "SyntheticsTestBrowserStepParams",
    "SyntheticsTestBrowserStepParamsVariable",
    "SyntheticsTestBrowserVariable",
    "SyntheticsTestConfig",
    "SyntheticsTestConfigVariable",
    "SyntheticsTestOptionsList",
    "SyntheticsTestOptionsListMonitorOptions",
    "SyntheticsTestOptionsListRetry",
    "SyntheticsTestRequestBasicauth",
    "SyntheticsTestRequestClientCertificate",
    "SyntheticsTestRequestClientCertificateCert",
    "SyntheticsTestRequestClientCertificateKey",
    "SyntheticsTestRequestDefinition",
    "User",
    "UserConfig",
]

publication.publish()
