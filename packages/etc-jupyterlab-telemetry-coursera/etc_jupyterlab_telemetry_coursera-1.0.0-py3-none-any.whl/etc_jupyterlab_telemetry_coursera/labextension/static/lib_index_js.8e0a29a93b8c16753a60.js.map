{"version":3,"file":"lib_index_js.8e0a29a93b8c16753a60.js","mappings":";;;;;;;;;;;;;;;;;AAA+C;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD;AACA,qBAAqB,+EAA6B;AAClD,uBAAuB,8DAAW;AAClC;AACA;AACA;AACA,yBAAyB,8EAA4B;AACrD;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AClCwD;AAC0E;AACa;AAChC;AACxE;AACkF;AACzH;AACO;AACP;AACA;AACA,kBAAkB;AAClB,6BAA6B,oDAAU;AACvC;AACA;AACA,mDAAmD,EAAE;AACrD;AACA;AACA,sEAAsE;AACtE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,iBAAiB;AACjB,sEAAsE;AACtE;AACA,qCAAqC,oDAAU,SAAS,4CAA4C;AACpG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAgB;AACxB,QAAQ,4IAAyC;AACjD,QAAQ,yJAAgD;AACxD,QAAQ,yHAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mIAAa,GAAG,eAAe;AACnE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;AChFmB;AAClC;AACP,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA,2BAA2B,yDAAU;AACrC;AACA,iCAAiC;AACjC;AACA;AACA;AACA,sCAAsC;AACtC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4CAA4C,oDAAoD;AAChG,qCAAqC;AACrC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA,8CAA8C;AAC9C,kDAAkD;AAClD;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@educational-technology-collective/etc_jupyterlab_telemetry_coursera/./lib/handler.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_coursera/./lib/index.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_coursera/./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/notebook_state.js"],"sourcesContent":["import { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'etc-jupyterlab-telemetry-coursera', // API Namespace\n    endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data = await response.text();\n    if (data.length > 0) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch (error) {\n            console.log('Not a JSON response body.', response);\n        }\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data;\n}\n","import { INotebookTracker } from '@jupyterlab/notebook';\nimport { IETCJupyterLabTelemetryLibraryConstructor } from \"@educational-technology-collective/etc_jupyterlab_telemetry_extension\";\nimport { IETCJupyterLabTelemetryValidateButtonConstructor } from \"@educational-technology-collective/etc_jupyterlab_telemetry_validate_button\";\nimport { IValidateButtonExtension } from \"@educational-technology-collective/etc_jupyterlab_nbgrader_validate\";\nimport { requestAPI } from './handler';\nimport { NotebookState } from '@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/notebook_state';\nconst PLUGIN_ID = '@educational-technology-collective/etc_jupyterlab_telemetry_coursera:plugin';\nexport class AWSAPIGatewayAdapter {\n    constructor() {\n        this._userId = (async () => {\n            try { // to get the user id.\n                return await requestAPI(\"id\");\n            }\n            catch (e) {\n                console.error(`Error on GET id.\\n${e}`);\n                return \"UNDEFINED\";\n            }\n            //  This request is specific to the Coursera environment; hence, it may not be relevant in other contexts.\n            //  The request for the `id` resource will return the value of the WORKSPACE_ID environment variable that is assigned on the server.\n        })();\n    }\n    adaptMessage(sender, data) {\n        (async () => {\n            try {\n                //\n                data = Object.assign(Object.assign({}, data), {\n                    user_id: await this._userId\n                });\n                //  The user id is not a characteristic of the event; hence, it is added late. \n                console.log(data);\n                let response = await requestAPI(\"s3\", { method: \"POST\", body: JSON.stringify(data) });\n                //console.log(response);\n            }\n            catch (e) {\n                console.error(e);\n            }\n        })();\n    }\n}\n/**\n * Initialization data for the @educational-technology-collective/etc_jupyterlab_telemetry_coursera extension.\n */\nconst plugin = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    requires: [\n        INotebookTracker,\n        IETCJupyterLabTelemetryLibraryConstructor,\n        IETCJupyterLabTelemetryValidateButtonConstructor,\n        IValidateButtonExtension\n    ],\n    activate: (app, notebookTracker, ETCJupyterLabTelemetryLibrary, ETCJupyterLabTelemetryValidateButton, validateButtonExtension) => {\n        console.log('JupyterLab extension @educational-technology-collective/etc_jupyterlab_telemetry_coursera is activated!');\n        let messageAdapter = new AWSAPIGatewayAdapter();\n        notebookTracker.widgetAdded.connect(async (sender, notebookPanel) => {\n            await notebookPanel.revealed;\n            await notebookPanel.sessionContext.ready;\n            let notebookState = new NotebookState({ notebookPanel });\n            let etcJupyterLabTelemetryLibrary = new ETCJupyterLabTelemetryLibrary({\n                notebookPanel,\n                notebookState\n            });\n            etcJupyterLabTelemetryLibrary.notebookOpenEvent.notebookOpened.connect(messageAdapter.adaptMessage, messageAdapter);\n            etcJupyterLabTelemetryLibrary.notebookSaveEvent.notebookSaved.connect(messageAdapter.adaptMessage, messageAdapter);\n            etcJupyterLabTelemetryLibrary.activeCellChangeEvent.activeCellChanged.connect(messageAdapter.adaptMessage, messageAdapter);\n            etcJupyterLabTelemetryLibrary.cellAddEvent.cellAdded.connect(messageAdapter.adaptMessage, messageAdapter);\n            etcJupyterLabTelemetryLibrary.cellRemoveEvent.cellRemoved.connect(messageAdapter.adaptMessage, messageAdapter);\n            etcJupyterLabTelemetryLibrary.notebookScrollEvent.notebookScrolled.connect(messageAdapter.adaptMessage, messageAdapter);\n            etcJupyterLabTelemetryLibrary.cellExecutionEvent.cellExecuted.connect(messageAdapter.adaptMessage, messageAdapter);\n            let etcJupyterLabTelemetryValidateButton = new ETCJupyterLabTelemetryValidateButton({\n                notebookPanel,\n                validateButtonExtension,\n                notebookState\n            });\n            etcJupyterLabTelemetryValidateButton.validateButtonClicked.connect(messageAdapter.adaptMessage, messageAdapter);\n            etcJupyterLabTelemetryValidateButton.validationResultsDisplayed.connect(messageAdapter.adaptMessage, messageAdapter);\n            etcJupyterLabTelemetryValidateButton.validationResultsDismissed.connect(messageAdapter.adaptMessage, messageAdapter);\n        });\n    }\n};\nexport default plugin;\n","import { UUID } from \"@lumino/coreutils\";\nexport class NotebookState {\n    constructor({ notebookPanel }) {\n        var _a;\n        this._notebook = notebookPanel.content;\n        this._cellState = new WeakMap();\n        this._seq = 0;\n        this._session_id = UUID.uuid4();\n        this.updateCellState();\n        //  The notebook loaded; hence, update the cell state.\n        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect((sender, args) => {\n            if (args.type == \"add\" || args.type == \"set\") {\n                this.updateCellState();\n                //  A cell was added; hence, update the cell state.\n            }\n        }, this);\n    }\n    updateCellState() {\n        this._notebook.widgets.forEach((cell) => {\n            if (!this._cellState.has(cell)) {\n                this._cellState.set(cell, { changed: true, output: this.createCellOutput(cell) });\n                //  It's a new cell; hence, the changed state is set to true.\n                ////  This is a new cell; hence, add handlers that check for changes in the inputs and outputs.\n                cell.inputArea.model.value.changed.connect((sender, args) => {\n                    let state = this._cellState.get(cell);\n                    if (state !== undefined) {\n                        state.changed = true;\n                        //  The input area changed; hence, the changed state is set to true.\n                    }\n                });\n                if (cell.model.type == \"code\") {\n                    cell.model.outputs.changed.connect((sender, args) => {\n                        if (args.type == \"add\") {\n                            //  An output has been added to the cell; hence, compare the current state with the new state.\n                            let state = this._cellState.get(cell);\n                            if (state !== undefined) {\n                                let output = this.createCellOutput(cell);\n                                if (output !== (state === null || state === void 0 ? void 0 : state.output)) {\n                                    //  The output has changed; hence, set changed to true and update the output state.\n                                    state.changed = true;\n                                    state.output = output;\n                                }\n                                else {\n                                    //  The output hasn't changed; hence, leave the state as is.\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n        });\n    }\n    createCellOutput(cell) {\n        //  Combine the cell outputs into a string in order to check for changes.\n        let output = \"\";\n        if (cell.model.type == \"code\") {\n            let outputs = cell.model.outputs;\n            for (let index = 0; index < outputs.length; index++) {\n                for (let key of Object.keys(outputs.get(index).data).sort()) {\n                    output = output + JSON.stringify(outputs.get(index).data[key]);\n                }\n            }\n            return output;\n        }\n        return \"\";\n    }\n    getNotebookState() {\n        var _a;\n        let nbFormatNotebook = (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.toJSON();\n        for (let index = 0; index < this._notebook.widgets.length; index++) {\n            let cell = this._notebook.widgets[index];\n            let cellState = this._cellState.get(cell);\n            if (cellState === undefined) {\n                throw new Error(`The cell at index ${index} is not tracked.`);\n            }\n            if ((cellState === null || cellState === void 0 ? void 0 : cellState.changed) === false) {\n                //  The cell has not changed; hence, the notebook format cell will contain just its id.\n                nbFormatNotebook.cells[index] = { id: this._notebook.widgets[index].model.id };\n            }\n        }\n        for (let index = 0; index < this._notebook.widgets.length; index++) {\n            let cell = this._notebook.widgets[index];\n            let cellState = this._cellState.get(cell);\n            if (cellState !== undefined) {\n                cellState.changed = false;\n            }\n            //  The cell state is going to be captured; hence, set the state to not changed.\n            //  We need to be certain that all the cells were processed prior to making any changes to their state;\n            //  hence, this operation is done in a loop separate from the loop above.\n        }\n        let state = {\n            session_id: this._session_id,\n            seq: this._seq,\n            notebook: nbFormatNotebook\n        };\n        this._seq = this._seq + 1;\n        //  We've made changes to the state at this point; \n        //  hence, it's really important that nothing throws between now and recording the message.\n        //  We need all the messages in order to reconstruct the Notebook at each event;\n        //  hence, we need all the messages in order to reconstruct the Notebook at each event. :-)\n        return state;\n    }\n}\n"],"names":[],"sourceRoot":""}